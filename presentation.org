#    -*- mode: org -*-
#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:t reveal_control:t
#+OPTIONS: reveal_mathjax:t reveal_rolling_links:nil reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1600 reveal_height:900
#+OPTIONS: toc:nil <:nil timestamp:nil email:t reveal_slide_number:"c/t"
#+REVEAL_MARGIN: 0.1
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: none
#+REVEAL_THEME: blood
#+REVEAL_HLEVEL: 1
#+REVEAL_EXTRA_CSS: ./presentation.css
#+REVEAL_ROOT: ../reveal.js/

#+TITLE: Everyday Efficiency: In-place Construction
#+AUTHOR: Ben Deane
#+EMAIL: bdeane@quantlab.com
#+DATE: November 2018

#+REVEAL_HTML: <script type="text/javascript" src="./rison.js"></script>
#+REVEAL_HTML: <script type="text/javascript" src="./presentation.js"></script>

* Title slide settings                                             :noexport:
#+BEGIN_SRC emacs-lisp
(setq org-reveal-title-slide
(concat "<h2>Everyday Efficiency:</h2><h2>In-place Construction</h2>"
"<div class='vertspace2'></div>"
"<blockquote nil><p>&quot;Make no collection of it: let him show<br>His skill is in the construction.&quot;</p>"
"<div></div><div class='author'>-- William Shakespeare, <em>Cymbeline</em></div></blockquote>"
"<div class='vertspace3'></div>"
"<h3>%a / <a href=\"http://twitter.com/ben_deane\">@ben_deane</a></h3>"
"<h4>%d</h4>"))
#+END_SRC

* Get Ready

1. What happens when we ~move~ something?
1. Copy elision (RVO)
1. Putting stuff into a ~vector~
1. ~initializer_list~
1. Putting stuff into a ~map~
1. Putting stuff into other things
1. Final thoughts

#+BEGIN_NOTES
There will be a lot of code snippets in this talk.

I will be asking a lot of questions.

I'm assuming everyone is using C++14, although most things we talk about will
require no more than C++11. I'll mention a couple of C++17 features.
#+END_NOTES

* Disclaimer

I'm going to critique some code in this talk.

If it's your code, please don't feel slighted.

I assure you that I write and have written plenty of suboptimal code.

Let's make code better together!

* Preliminaries

#+BEGIN_SRC c++
#include <stdio.h>

struct Foo {};

struct S
{
  S() { puts("Default construct\n"); }
  S(Foo) { puts("Value construct\n"); }
  explicit S(int) { puts("Explicit value construct (1)\n"); }
  explicit S(int, int) { puts("Explicit value construct (2)\n");}
  ~S() { puts("Destruct\n"); }
  S(const S&) { puts("Copy construct\n"); }
  S(S&&) { puts("Move construct\n"); }
  S& operator=(const S&) { puts("Copy assign\n"); return *this; }
  S& operator=(S&&) { puts("Move assign\n"); return *this; }
};

int main()
{
    S s;
}
#+END_SRC

#+BEGIN_NOTES
You're going to see a lot of this later in the talk, when we examine how various
snippets of code behave.
#+END_NOTES

* 1. What happens when we ~move~ something?
#+REVEAL_HTML: <div class='vertspace2'></div>
#+REVEAL_HTML: <blockquote nil><p>&quot;Mov'd! In good time! Let him that mov'd you hither<br>remove you hence.&quot;</p>
#+REVEAL_HTML: <div></div><div class='author'>-- William Shakespeare, <em>The Taming of the Shrew</em></div></blockquote>

** A moved-from ~vector~
#+BEGIN_SRC c++
std::vector<int> v1 = {1, 2, 3, 4, 5};
std::vector<int> v2 = std::move(v1);
#+END_SRC

What's in ~v1~ after the move?

#+BEGIN_NOTES
The standard says "valid but unspecified". We know that we're allowed to destroy
it, because for things to be otherwise would be a nonsense. ~v1~ _will_ be
destroyed like any other C++ object when it goes out of scope.

Here's where we deviate from the standard. How is ~vector~ implemented,
basically? (pointer-to-buffer, size, capacity). On destruction, what must it do?
#+END_NOTES

** A moved-from ~vector~
It must be destroyable.

What is sufficient? What is likely?
 - begin pointer is null?
 - size is zero?
 - capacity is zero?

** Exhibit A
#+BEGIN_SRC c++
void WebSocketHandshakerImpl::ProcessServerHandshake(HttpMessage message)
{
  // some stuff...

  m_result.extra = std::move(m_readBuffer);
  m_result.headers = std::move(message.headers);
}
#+END_SRC

This code assumes that it's safe to do whatever comes later to a moved-from ~vector~.

** Now consider:

#+BEGIN_SRC c++
std::string s1 = "Greetings, planet";
std::string s2 = std::move(s1);
#+END_SRC

What's the moved-from state of ~s1~?

#+BEGIN_SRC c++
std::string s3 = "Hello, world";
std::string s4 = std::move(s3);
#+END_SRC

What's the moved-from state of ~s3~?

#+BEGIN_NOTES
What is the state of s1 in the second case? Same as the vector case basically.

But the first example is small-string optimized. What happens when you move from
a small string? You have to copy.

What is the state of s1 in the first case? It happens that all major
implementations will set the size to zero on a move, even when in the small
string buffer. So it's actually ever so slightly /slower/ than a copy.

If you're lucky, the optimizer can help you out and spot dead stores...

Bloomberg's STL does not clear a moved-from SSO string.
#+END_NOTES

** Observation
Moving from a ~string~ usually /isn't any faster/ than copying from it.

(If you doubt this, ask yourself why the small string optimization exists in the
first place.)

Moves /only/ matter for objects on the heap.

http://quick-bench.com/7zo0OLXgCyR3v_KwZKNIe5Z5Z64

#+BEGIN_NOTES
And as noted, it may be technically slower.
#+END_NOTES

** Exhibit B
#+BEGIN_SRC c++
void Context::Trigger(/* some args */)
{
  // Make sure that it will trigger only once.
  const OnResponseCallback cb = std::move(m_responseCallback);

  if (cb)
  {
    cb(errorCode, errorReason, payload, size, opaque);
  }
}
#+END_SRC
Is this comment telling the truth?

#+BEGIN_NOTES
Playing with fire. The comment is misleading. We're relying on implementation.

Function has a small buffer optimization just like string. There's no reason for
function to be null after a move.

Think back to the vector case now: what happens if the container is replaced
with a small-buffer optimizable container?
#+END_NOTES

** Guideline (specific)
Don't assume things are empty after a ~move~.

Use ~exchange~ to make sure. Assigning an empty object is a trivial price for
safety.

#+BEGIN_SRC c++
m_result.extra = std::exchange(m_readBuffer, {});

const OnResponseCallback cb = std::exchange(m_responseCallback, nullptr);
#+END_SRC

Make your code safe for future small-buffer optimizations.

** Guideline (more general)
If you didn't write the move constructor/operator yourself, after a ~move~, you
may assume:

 - the object is destroyable
 - the object is (re-)assignable

/NOTHING ELSE/

Note: This is a stronger constraint than what the standard says.

#+BEGIN_NOTES
[defns.valid] "the object's invariants are met and operations on the object
behave as specified for its type"

The standard says you can call any function without preconditions.

But I'm not saying anything that, I'm just saying something /more/ constrained,
and safer.
#+END_NOTES

** Let's look at this again
#+BEGIN_SRC c++
void WebSocketHandshakerImpl::ProcessServerHandshake(HttpMessage message)
{
  // some stuff...

  // which would be right here? this?
  m_result.headers = std::move(message.headers);

  // or this?
  m_result.headers = std::move(message).headers;
}
#+END_SRC

#+BEGIN_NOTES
The first option is saying a much stronger thing. The result of ~move~ is always
an rvalue reference. That's literally all ~move~ does: a cast to an rvalue
reference.

The second one is using C++ member access rules to infer the rvalue-ness of the
member. That's fine. We still get the rvalue.

The first one is saying "this is definitely an rvalue - trust me!".

The second is saying "hey, this is an rvalue, unless something else prevents it".

So what would "prevent it"?
#+END_NOTES

** There may be trouble ahead
Let's say we want always want pretty much the same headers for all requests.

What if we decided to change this...
#+BEGIN_SRC c++
struct HttpMessage
{
  std::string requestLine;
  Headers headers;
};
#+END_SRC
...to this?
#+BEGIN_SRC c++
struct HttpMessage
{
  std::string requestLine;
  Headers& headers;
};
#+END_SRC

#+BEGIN_NOTES
What happens when we change ~Header~ to a reference?

The HttpMessage itself can be an rvalue, but what it's referencing isn't.
#+END_NOTES

** Guideline
Use ~std::move(obj).member~ rather than ~std::move(obj.member)~

#+BEGIN_SRC c++
// always safe, non-reference member is still an rvalue
auto x = std::move(obj).member;

// could erroneously move from an lvalue-ref!
auto x = std::move(obj.member);
#+END_SRC

#+BEGIN_NOTES
If we cast obj to an rvalue-ref, its member will also (usually) be an rvalue
ref, no problem. We aren't losing anything and we're gaining safety.
#+END_NOTES

** ~move~ safety guidelines
 - after ~std::move~, destroy or assign /only/
 - use ~std::exchange~ to move-and-clear
 - use ~std::move(obj).member~, not ~std::move(obj.member)~

#+BEGIN_NOTES
The last two points here are useful a lot of the time for writing move
constructors. You're going to be working in terms of the subobjects.
#+END_NOTES

* 2. Copy Elision
#+REVEAL_HTML: <div class='vertspace2'></div>
#+REVEAL_HTML: <blockquote nil><p>&quot;If you will, lead these graces to the grave<br>And leave the world no copy.&quot;</p>
#+REVEAL_HTML: <div></div><div class='author'>-- William Shakespeare, <em>Twelfth Night, or What You Will</em></div></blockquote>

** Copy Elision, aka RVO

What is the return value optimization?

#+BEGIN_SRC c++
string bar()
{
  string a{"Hi"};
  int b = 42;
  // ...
  return a;
}

void foo()
{
  string s{bar()};
}
#+END_SRC

#+BEGIN_NOTES
The caller sets aside space in its own stack frame for the result of the
function, and the callee constructs the result directly in that space.

bar() has two local variables.

when foo() calls bar() it "passes" the address of the stack variable s.
#+END_NOTES

** RVO in pictures: No RVO
#+REVEAL_HTML: <div class='vertspace2'></div>
[[./no-rvo1.svg]]

** RVO in pictures: No RVO
#+REVEAL_HTML: <div class='vertspace2'></div>
[[./no-rvo2.svg]]

** RVO in pictures: No RVO
#+REVEAL_HTML: <div class='vertspace2'></div>
[[./no-rvo3.svg]]

** RVO in pictures: No RVO
#+REVEAL_HTML: <div class='vertspace2'></div>
[[./no-rvo4.svg]]

** RVO in pictures: No RVO
#+REVEAL_HTML: <div class='vertspace2'></div>
[[./no-rvo5.svg]]

** RVO in pictures: RVO
#+REVEAL_HTML: <div class='vertspace2'></div>
[[./rvo1.svg]]

** RVO in pictures: RVO
#+REVEAL_HTML: <div class='vertspace2'></div>
[[./rvo2.svg]]

** RVO in pictures: RVO
#+REVEAL_HTML: <div class='vertspace2'></div>
[[./rvo3.svg]]

** RVO in pictures: RVO
#+REVEAL_HTML: <div class='vertspace2'></div>
[[./rvo4.svg]]

** RVO in pictures: RVO
#+REVEAL_HTML: <div class='vertspace2'></div>
[[./rvo5.svg]]

** When can RVO not apply?

RVO Rules: what is returned has to be either:

 - a temporary (prvalue)
 - the name of a stack variable

** When can RVO not apply?

RVO Ability: sometimes, the callee /can't/ construct the object in-place.

 - if there is no opportunity to
 - if it's not of the right type
 - if the callee doesn't know enough

#+BEGIN_NOTES
Function arguments that are passed to you already-constructed can't be RVOed on
return. But you can move them.

You have to know at construction time that you're going to be returning that
variable in order to RVO it.
#+END_NOTES

** No RVO because no opportunity

You can't RVO a variable if you didn't get the chance to construct it in the
first place.
#+BEGIN_SRC c++
std::string sad_function(std::string s)
{
  s += "No RVO for you!";
  return s;
}
#+END_SRC
But the compiler will still move it. (Since C++11)

#+BEGIN_NOTES
C++11 mandates that if you can't do the RVO, you must try to move and only copy
as a last resort.
#+END_NOTES

** No RVO because wrong type, 1

An rvalue-ref is not the same type.
#+BEGIN_SRC c++
std::string sad_function()
{
  std::string s = "No RVO for you!";
  return std::move(s);
}
#+END_SRC
Don't ~return std::move(x)~ in most cases - you will get a move when you didn't need anything!

#+BEGIN_NOTES
There are legitimate cases for returning an rvalue reference.

One of the few times when ~return std::move(x)~ is proper is when you're returning a
member variable out of a rvalue-ref-qualified member function.
#+END_NOTES

** No RVO because wrong type, 2

Factory functions can't RVO.
#+BEGIN_SRC c++
struct Base { ... };
struct Derived : Base { ... };

std::shared_ptr<Base> factory()
{
  return std::make_shared<Derived>();
}
#+END_SRC
But will still move.

#+BEGIN_NOTES
This is also true of any types that are inter-convertible.
e.g. returning a pair when the function returns a tuple, or something like that.
#+END_NOTES

** No RVO because not enough info

It has to be decidable at construction time.
#+BEGIN_SRC c++
std::string undecided_function()
{
  std::string happy = "Hooray";
  std::string sad = "Boo hoo";

  if (getHappiness() > 0.5)
    return happy;
  else
    return sad;
}

#+END_SRC
Again, return value will still be moved.

** Why is RVO important?

#+BEGIN_SRC c++
using M = std::map<std::string, int>;

M build_map()
{
  M m;
  m.insert(std::make_pair("Jenny", 8675309));
  return m;
}
#+END_SRC

#+BEGIN_NOTES
RVO is really important for performance. It's probably the single most important
optimization compilers make. Hence why it's been around for decades, even
without a standard.

If we accidentally inhibit RVO, we might also inhibit ~move~. We might get a
copy.

~move~ isn't necessarily cheap. Microsoft's node-based containers allocate in
their move constructors because they use sentinel nodes.
#+END_NOTES

** Quiz time

Wake up!

And tell me if the upcoming code snippets will activate RVO.

** Will it RVO?
#+BEGIN_SRC c++
const S will_it_rvo()
{
  return S{1};
}
#+END_SRC

#+ATTR_REVEAL: :frag (appear)
Yes.

#+BEGIN_NOTES
Yes. You're allowed to cv-qualify return types and RVO still works.

But don't do this. The compiler ignores const-qualified builtin types anyway.
#+END_NOTES

** Will it RVO?
#+BEGIN_SRC c++
S will_it_rvo(bool b)
{
  if (b)
    return S{1};
  else
    return S{0};
}
#+END_SRC

#+ATTR_REVEAL: :frag (appear)
Yes. Even in debug builds.

#+BEGIN_NOTES
Yes. This is URVO, and works pretty reliably even in debug builds.
#+END_NOTES

** Will it RVO?
#+BEGIN_SRC c++
S will_it_rvo(bool b, S s)
{
  if (b)
    s = S{1};
  return s;
}
#+END_SRC

#+ATTR_REVEAL: :frag (appear)
No (no opportunity).

#+BEGIN_NOTES
No - can't RVO a function parameter. It will move though.
#+END_NOTES

** Will it RVO?
#+BEGIN_SRC c++
S get_S() { return S{1}; }

S will_it_rvo(bool b)
{
  if (b)
    return get_S();
  return S{0};
}
#+END_SRC

#+ATTR_REVEAL: :frag (appear)
Yes (can elide multiple copies).

#+BEGIN_NOTES
Yes. This RVOs.
RVO is allowed to elide multiple copies down the callstack.
#+END_NOTES

** Will it RVO?
#+BEGIN_SRC c++
S will_it_rvo(bool b)
{
  if (b)
  {
    S s{1};
    return s;
  }
  return S{0};
}
#+END_SRC

#+ATTR_REVEAL: :frag (appear)
Yes (Clang), no (MSVC/GCC).

#+BEGIN_NOTES
There's nothing stopping it... but only Clang successfully RVO's this.
#+END_NOTES

** Will it RVO?
#+BEGIN_SRC c++
S will_it_rvo(bool b)
{
  S s{1};
  if (b)
    return s;
  return S{0};
}
#+END_SRC

#+ATTR_REVEAL: :frag (appear)
No. Possibly in future?

#+BEGIN_NOTES
We hoisted the S out of the condition.

No RVO here (a sufficiently smart compiler might be able to...)

It still moves.
#+END_NOTES

** Will it RVO?
#+BEGIN_SRC c++
S will_it_rvo(bool b)
{
  S s{1};
  return b ? s : S{0};
}
#+END_SRC

#+ATTR_REVEAL: :frag (appear)
No. (Against the rules.)

#+BEGIN_NOTES
No RVO. We're not naming a variable.
Will it still move? No.

We're not naming a variable. And it's not a prvalue - the conditional operator
produces an lvalue reference here. We have to copy.

This is perhaps a semi-common pattern that defeats RVO!
#+END_NOTES

** Will it RVO?
#+BEGIN_SRC c++
S get_S() { return S{1}; }

S will_it_rvo(bool b)
{
  return b ? get_S() : S{0};
}
#+END_SRC

#+ATTR_REVEAL: :frag (appear)
Yes. (Returning temporary.)

#+BEGIN_NOTES
This RVOs. This time the conditional operator produces a prvalue because both of
its operands are prvalues.
#+END_NOTES

** Will it RVO?
#+BEGIN_SRC c++
S will_it_rvo()
{
  S s{1};
  s = S{2};
  return s;
}
#+END_SRC

#+ATTR_REVEAL: :frag (appear)
Yes.

#+BEGIN_NOTES
Yep. Plain NRVO.
#+END_NOTES

** Will it RVO?
#+BEGIN_SRC c++
S will_it_rvo()
{
  S s{1};
  return (s);
}
#+END_SRC

#+ATTR_REVEAL: :frag (appear)
Yes.
#+ATTR_REVEAL: :frag (appear)
[[http://eel.is/c++draft/class.copy.elision#3.1][class.copy.elision \S 3.1]]

#+BEGIN_NOTES
The standard explicitly allows this -- (possibly parenthesized) /id-expression/.

However... there seems to be a bug in GCC where it doesn't RVO this. MSVC does
and Clang does.

Technically GCC is still adhering to the standard, because it's not required to
RVO. It does in C++11 mode, just not in C++14 or C++17 mode.
#+END_NOTES

** Exhibit C

#+BEGIN_SRC c++
unsigned long long Time() const override
{
  auto ts = std::get<1>(std::move(Base::metrics_->GetDataPointAndTime()));
  return ts;
}
#+END_SRC

Superfluous (potentially dangerous?) call to ~std::move~.

NRVO is not guaranteed in debug mode. Better:

#+BEGIN_SRC c++
unsigned long long Time() const override
{
  return std::get<1>(Base::metrics_->GetDataPointAndTime());
}
#+END_SRC

#+BEGIN_NOTES
Just an integral type here, so no big deal. But if it gets changed, or this
pattern gets copied...
#+END_NOTES

** Guidelines for RVO-friendliness

 - don't const-qualify returned value types
 - almost never return ~std::move(x)~
 - return temporaries where you can
 - when you return named things, avoid conditions
 - don't parenthesize return expressions

#+BEGIN_NOTES
First point does not affect RVO but is generally useless.

Returning ~std::move(x)~ is only for ref-qualified accessors.

URVO is easier for the compiler than NRVO. You are likely to get URVO in debug
builds.

Beware of the conditional operator.
#+END_NOTES

* 3. Putting stuff into a ~vector~
Should you use ~push_back~ or should you use ~emplace_back~?

How should you use them?

#+REVEAL_HTML: <div class='vertspace2'></div>
#+REVEAL_HTML: <blockquote nil><p>&quot;Didst thou not say, when I did push thee back --<br>Which was when I perceived thee -- that thou camest<br>From good descending?&quot;</p>
#+REVEAL_HTML: <div></div><div class='author'>-- William Shakespeare, <em>Pericles</em></div></blockquote>

** ~push_back~ and ~emplace_back~

#+BEGIN_SRC c++
void push_back(const T& x);
void push_back(T&& x);

template <class... Args>
reference emplace_back(Args&&... args);
#+END_SRC

#+BEGIN_NOTES
Until C++17, ~emplace_back~ returns ~void~.
#+END_NOTES

** Example 1

What's the difference here?

#+BEGIN_SRC c++
std::vector<std::string> v;
std::string s;
// ...

v.push_back(std::move(s));
v.emplace_back(std::move(s));
#+END_SRC

#+BEGIN_NOTES
There is no difference.
#+END_NOTES

** Example 1.1

What's the difference here?

#+BEGIN_SRC c++
std::vector<std::string> v;
std::string s;

v.push_back(std::move(s));
std::string& last_s = v.emplace_back(std::move(s));
#+END_SRC

#+BEGIN_NOTES
If we want to capture a reference to the thing that was pushed, we can use
~emplace_back~.
#+END_NOTES

** Example 2

What's the difference here?

#+BEGIN_SRC c++
std::vector<std::string> v;
const char* s = "Hello";

v.push_back(s);
v.emplace_back(s);
#+END_SRC

#+BEGIN_NOTES
~push_back~ constructs a temporary then moves it.

~emplace_back~ constructs directly in place.

Remember, for string, a move is usually as expensive as a copy.
#+END_NOTES

** Example 2.1

Default in-place construct.

#+BEGIN_SRC c++
std::vector<S> v;

// first default-construct in the vector
S& s = v.emplace_back();

// now mutate s
// ...
#+END_SRC

~emplace_back~ takes a parameter pack. Parameter packs can be empty.

#+BEGIN_NOTES
~emplace_back~ is especially useful for this use case.
#+END_NOTES

** Example 3

In-place construct with ~explicit~ constructor.

#+BEGIN_SRC c++
// recall: S has an explicit constructor from int
std::vector<S> v;

// push_back can't do explicit construction
v.push_back(1);  // compiler error!

// explicit construction is no problem for emplace_back
S& s = v.emplace_back(1);
#+END_SRC

~emplace_back~ does perfect forwarding. It can call ~explicit~ constructors.

#+BEGIN_NOTES
~emplace_back~ is especially useful for this use case.
#+END_NOTES

** Example: copy
Recall: our ~S~ class has a constructor from ~Foo~, and an ~explicit~ constructor
from ~int~.

#+BEGIN_SRC c++
std::vector<S> v;
std::array<Foo, 3> a = { Foo{}, Foo{}, Foo{} };
v.reserve(a.size());

std::copy(a.cbegin(), a.cend(), std::back_inserter(v));
#+END_SRC

What does ~back_insert_iterator~ do here?

#+BEGIN_NOTES
For each element, we construct an ~S~ (from the ~Foo~) and then we move it into
the ~vector~.
#+END_NOTES

** Example: copy
What if we have an ~array~ of ~int~?

#+BEGIN_SRC c++
std::vector<S> v;
std::array a = { 1,2,3,4,5 };
v.reserve(a.size());

std::copy(a.cbegin(), a.cend(), std::back_inserter(v));
#+END_SRC

#+ATTR_REVEAL: :frag (appear)
Oops. The compiler is angry at us.

#+BEGIN_NOTES
~back_insert_iterator~ calls ~push_back~ - it can't call our explicit
constructor.
#+END_NOTES

** Example: copy?
OK, no problem, right?

#+BEGIN_SRC c++
std::vector<S> v;
std::array a = { 1,2,3,4,5 };
v.reserve(a.size());

std::transform(a.cbegin(), a.cend(), std::back_inserter(v),
               [] (int i) { return S{i}; });
#+END_SRC

#+BEGIN_NOTES
For each element, we construct an ~S~ (from the ~int~) and then we move it into
the ~vector~. No extra cost over the first solution, because the ~return~ from the
lambda RVOs.

But what we actually want to do is construct in place.
#+END_NOTES

** ~back_emplacer~
#+BEGIN_SRC c++
template <typename Container>
struct back_emplace_iterator
{
  explicit back_emplace_iterator(Container& c) : c(&c) {}

  back_emplace_iterator& operator++() { return *this; }
  back_emplace_iterator& operator*() { return *this; }

  template <typename Arg>
  back_emplace_iterator& operator=(Arg&& arg) {
    c->emplace_back(std::forward<Arg>(arg));
    return *this;
  }

private:
  Container* c;
};
#+END_SRC

** ~back_emplacer~
#+BEGIN_SRC c++
// pre-CTAD maker function

template <typename Container>
auto back_emplacer(Container& c)
{
  return back_emplace_iterator<Container>(c);
}
#+END_SRC

** ~back_emplacer~
What if we have an ~array~ of ~int~?

#+BEGIN_SRC c++
std::vector<S> v;
std::array a = { 1,2,3,4,5 };
v.reserve(a.size());

std::copy(a.cbegin(), a.cend(), back_emplacer(v));
#+END_SRC

** Exhibit D
#+BEGIN_SRC c++
std::vector<std::string_view> tokens;
// ...
std::string_view token = /* stuff */;
tokens.emplace_back(std::move(token));
#+END_SRC

#+BEGIN_NOTES
A few things here:
 - ~string_view~ is a pointer + length. recommendation is to pass by value;
   ~move~ gains nothing anyway.
 - ~push_back~ works with rvalues just fine - ~emplace_back~ gains nothing here.
 - if you want to, you should pass ~/* stuff */~ directly to ~emplace_back~.
#+END_NOTES

** Exhibit E

#+BEGIN_SRC c++
context->m_result->m_headers.emplace_back(std::string(headerData, numBytes));
#+END_SRC

A superfluous move! Better:

#+BEGIN_SRC c++
context->m_result->m_headers.emplace_back(headerData, numBytes);
#+END_SRC

Don't explicitly call a constructor with ~emplace_back~.

#+BEGIN_NOTES
And remember, likely a superfluous copy if the string is small-buffer-optimized.
#+END_NOTES

** ~vector~ of ~pair~ = ~map~
Sometimes, we use a  sorted ~vector~ of ~pair~ as a replacement for ~map~.

What do you do if part of your ~pair~ has a multi-argument constructor?

#+BEGIN_SRC c++
struct Foo { Foo(int, std::string, double); };

std::vector<std::pair<int, Foo>> v;

// this is very common!
v.push_back(std::make_pair(1, Foo{42, "hello", 3.14}));

// this is no better
v.emplace_back(std::make_pair(1, Foo{42, "hello", 3.14}));

// how can we do better?
v.emplace_back( /* what here? */ );
#+END_SRC

** ~piecewise_construct~ to the rescue!

~pair~ has a constructor that will handle your multi-argument constructor.

#+BEGIN_SRC c++
template <class... Args1, class... Args2>
pair(piecewise_construct_t,
     tuple<Args1...> first_args,
     tuple<Args2...> second_args);

template <class... Types>
constexpr tuple<Types&&...> forward_as_tuple(Types&&... args) noexcept;
#+END_SRC

~piecewise_construct_t~ is a tag type.

** Using ~piecewise_construct~
#+BEGIN_SRC c++
struct Foo { Foo(int, std::string, double); };

std::vector<std::pair<int, Foo>> v;

// instead of this...
v.push_back(std::make_pair(1, Foo{42, "hello", 3.14}));

// ...we can do this
v.emplace_back(
  std::piecewise_construct,
  std::forward_as_tuple(1),                   // args to int "constructor"
  std::forward_as_tuple(42, "hello", 3.14))); // args to Foo constructor
#+END_SRC
Perfect forwarding and in-place construction.

** Recommendations
 - ~push_back~ is perfectly fine for rvalues
 - use ~emplace_back~ only when you need its powers
   - in-place construction (including nullary construction)
   - a reference to what's added (C++17)
 - never pass an explicit temporary to ~emplace_back~
 - try to construct in place when you can
 - use ~piecewise_construct~ / ~forward_as_tuple~ to forward args through ~pair~

* 4. ~initializer_list~

#+REVEAL_HTML: <div class='vertspace2'></div>
#+REVEAL_HTML: <blockquote nil><p>&quot;I fear these stubborn lines lack power to move.&quot;</p>
#+REVEAL_HTML: <div></div><div class='author'>-- William Shakespeare, <em>Love's Labours Lost</em></div></blockquote>

** What is ~initializer_list~?
When you write:
#+BEGIN_SRC c++
std::vector<int> v{ 1,2,3 };
#+END_SRC
It's as if you wrote:
#+BEGIN_SRC c++
const int a[] = { 1,2,3 };
std::vector<int> v = std::initializer_list<int>(a, a+3);
#+END_SRC

#+BEGIN_NOTES
Notice: the backing array is ~const~.
#+END_NOTES

** ~initializer_list~ has ~const~ storage, 1
#+BEGIN_SRC c++
template <int... Is>
auto f() ()
{
  return std::initializer_list<int>{ Is... };
}

void foo() {
  for (int i: {1,2,3})
    cout << i << '\n';
}

void bar() {
  for (int i: f<1,2,3>())
    cout << i << '\n';
}
#+END_SRC

#+BEGIN_NOTES
This is nasty, because it could work on one compiler and you wouldn't notice it.

The compiler probably won't warn for this.

~initializer_list~ is a "view" type like ~string_view~ and doesn't own its
contents.
#+END_NOTES

** ~initializer_list~ has ~const~ storage, 2
#+BEGIN_SRC c++
unique_ptr<int> v = { make_unique<int>(1), make_unique<int>(2) };
#+END_SRC
That also means ~move~ can't work.
#+BEGIN_SRC c++
const std::unique_ptr<int> a[] = { std::make_unique<int>(1),
                                   std::make_unique<int>(2) };
std::vector<std::unique_ptr<int>> v =
  std::initializer_list<std::unique_ptr<int>>(a, a+3);
#+END_SRC

#+BEGIN_NOTES
You can't move from an ~initializer_list~ - this won't compile.
#+END_NOTES

** But they're so convenient!
I'd much rather write:

#+BEGIN_SRC c++
std::vector<S> v = { S{1}, S{2}, S{3} };
#+END_SRC
(3 constructs, 3 copies, 3 destructs)

Than:
#+BEGIN_SRC c++
std::vector<S> v;
v.reserve(3);
v.emplace_back(1);
v.emplace_back(2);
v.emplace_back(3);
#+END_SRC
(3 constructs)

#+BEGIN_NOTES
The first version is probably OK for builtin primitive types.

It's way worse than the second version for types with more than trivial
construction.
#+END_NOTES

** We can make it a little better...

#+BEGIN_SRC c++
std::vector<S> v = { S{1}, S{2}, S{3} };
#+END_SRC
(3 constructs, 3 copies, 3 destructs)

#+BEGIN_SRC c++
S a[3] = { S{1}, S{2}, S{3} };
std::vector<S> v(std::make_move_iterator(std::begin(a)),
                 std::make_move_iterator(std::end(a)));
#+END_SRC
(3 constructs, 3 moves, 3 destructs)

** What we really need...

Is an in-place constructor for ~vector~. (For everything?)

#+BEGIN_SRC c++
template <class... Args>
explicit vector(in_place_t, Args&&... args);
#+END_SRC

Future (?) proposal by Simon Brand.

https://wg21.tartanllama.xyz/initializer_list

** Exhibit F
#+BEGIN_SRC c++
std::unordered_set<std::string> kKeywords = {
	"alignas", "alignof", "and", "and_eq", "asm", "auto", "bitand", "bitor",
	"bool", "break", "case", "catch", "char", "class", "compl", "const",
	"constexpr", "const_cast", "continue", "decltype", "default", "delete", "do",
	"double", "dynamic_cast", "else", "enum", "explicit", "extern", "false",
	"float", "for", "friend", "goto", "if", "inline", "int", "long", "mutable",
	"namespace", "new", "noexcept", "not", "not_eq", "NULL", "operator", "or",
	"or_eq", "private", "protected", "public", "register", "reinterpret_cast",
	"return", "short", "signed", "sizeof", "static", "static_assert",
	"static_cast", "struct", "switch", "template", "this", "thread_local",
	"throw", "true", "try", "typedef", "typeid", "typename", "union", "unsigned",
	"using", "virtual", "void", "volatile", "wchar_t", "while", "xor", "xor_eq"
};
#+END_SRC

** Caveat Constructor

~std::string~ is an interesting case here. We intuit/are taught:

#+REVEAL_HTML: <blockquote nil><p>Delay construction, allocation, etc. as late as possible.</p></blockquote>

But that might hurt us with ~std::string~.

[[https://www.youtube.com/watch?v=sSlmmZMFsXQ]["Initializer Lists are Broken, Let's Fix Them"]] -- Jason Turner, C++Now 2018

** Surprising: ~string~ vs ~const char*~

SBO-strings
http://quick-bench.com/5dPSX8rx-R8_BIUYbYOp6DcqhAc

Non SBO-strings 1:
http://quick-bench.com/mr6ZIQ8Jy0ghe1scBcTznYF2s5w

Non SBO-strings 2:
http://quick-bench.com/vzlG11LwZN-uMAKdK8X1XgRuaWs

#+BEGIN_NOTES
Two things mess with our mental model for strings. First - the small buffer
optimization. As previously mentioned, it makes copy the same cost as move.

Second - we often make strings from string literals. What's the type of a string
literal at declaration? Array of char. What's the type of it when you pass it to
a function? It decays to pointer to char.

So, if a string isn't small-buffer optimized, move is cheap. And if we're
constructing it from a string literal, the compiler knows the size. If we let it
decay to a char*, we're going to call strlen at some point.
#+END_NOTES

** Recommendations

 - use ~initializer_list~ only for literal types
 - consider using ~array~ and manually moving
 - probably don't use ~initializer_list~ for anything that'll get run more than
   once
 - wait for an ~in_place_t~ constructor on ~vector~ ?
 - watch Jason's talk

#+BEGIN_NOTES
I'm not sure what to recommend. Really the first point.
#+END_NOTES

* 5. Putting stuff into a ~map~

(or other associative container)

It's a bit complicated.

#+REVEAL_HTML: <div class='vertspace2'></div>
#+REVEAL_HTML: <blockquote nil><p>&quot;A plague upon it! I have forgot the map.&quot;</p>
#+REVEAL_HTML: <div></div><div class='author'>-- William Shakespeare, <em>Henry IV, Part I</em></div></blockquote>

#+BEGIN_NOTES
When I say ~map~, I mean ~map~, ~unordered_map~, ~multimap~, ~unordered_multimap~,
etc, and also the various flavours of ~set~.

Note: the ~value_type~ of a ~map~ is ~pair<const K, V>~. Confusingly, if we want
to refer to just the value in the map and not the key, it's called the
~mapped_type~.
#+END_NOTES

** ~initializer_list~ with ~map~

It's perfectly possible to initialize a map with an ~initializer_list~.
#+BEGIN_SRC c++
// recall S has an implicit constructor from Foo

using M = std::map<int, S>;
M m { {0, Foo{}} }; // how many constructs/copies/moves?
#+END_SRC

Use aggregate initialization with ~pair~.

Is this good?

#+BEGIN_NOTES
Same as the ~vector~ init case basically. ~initializer_list~ still suffers from
the same problems.

You can't use explicit constructors easily here.

If you have explicit constructors you might need to explicitly call out the type
 of pair; it's not going to make a lot of difference.
#+END_NOTES

** Alternative: templatery

https://gist.github.com/elbeno/609e929ef6898f09e96a#file-for_each_args-cpp-L55
#+BEGIN_SRC c++
// call an N-ary function on each lot of N args passed in
template <size_t N, typename F, typename... Ts>
void for_each_n_args(F&& f, Ts&&... ts);
#+END_SRC

#+BEGIN_SRC c++
using M = std::map<int, S>;
M m;
for_each_n_args<2>(
  [&] (auto&& k, auto&& v) {
      m.emplace(forward<decltype(k)>(k),
                forward<decltype(v)>(v)); },
  0, 1); // we can call explicit constructor
#+END_SRC

If you know the types, you can probably write the lambda in a less ugly way.

#+BEGIN_NOTES
~for_each_n_args~ is a function template that perfectly-forwards its arguments
in groups of N to the function you give it.

Everything here gets constructed in place. No moves or copies.

This lambda deals with single-argument constructors for value. But...
#+END_NOTES

** Alternative: multi-arg templatery

#+BEGIN_SRC c++
using M = std::map<int, S>;
M m;
for_each_n_args<3>(
  [&] (auto&& k, auto&&... v) {
      m.emplace(
        std::piecewise_construct,
        std::forward_as_tuple(std::forward<decltype(k)>(k)),
        std::forward_as_tuple(std::forward<decltype(v)>(v)...); },
  0, 1, 2); // explicit multi-arg value constructor
#+END_SRC

Everything constructed in place.

#+BEGIN_NOTES
Here we are calling S's two-arg constructor.

~for_each_n_args~ also works with vector (including vector-of-pair) as an
alternative to ~initializer_list~

There are some issues with calling ~explicit~ constructors... it depends on the
compiler/library. It is supposed to work.
#+END_NOTES

** Enough about initializing

How about putting things into an existing ~map~?

** The Easy Way: ~operator[]~

#+BEGIN_SRC c++
// recall S has an implicit constructor from Foo
// but an explicit constructor from int

using M = std::map<int, S>;
M m;
m[0] = S{1};
m[1] = Foo{};
#+END_SRC

How many constructs/moves/copies?

#+BEGIN_NOTES
These each have a construct, a default construct, and a move.

The advantage of this is that when you know the element is there already, it's
fine. You just get a lookup and an assign.

But if the element isn't there, you never get a copy construct or a move
construct here.

You always get an assign! Because you always get a default construct if the
element isn't there.

In fact this is the only function on map that requires your mapped_type to have
a default constructor! It's fine to use objects without default constructors in
a map, if you never use this function. And that can be a significant thing.
#+END_NOTES

** The Other Easy Way: ~insert~

#+BEGIN_SRC c++
// recall S has an implicit constructor from Foo
// but an explicit constructor from int

using M = std::map<int, S>;
M m;

// pair<iterator,bool> insert(value_type&& value);

// template <class T1, class T2>
// pair<V1,V2> make_pair(T1&& t, T2&& u);

// alternatives:
m.insert(std::make_pair(0, S{1}));
m.insert(std::pair<int, S&&>(0, S{1}));
m.insert(std::make_pair(0, 1));
#+END_SRC

How many constructs/moves/copies?

#+BEGIN_NOTES

The first line here creates an S, moves it into pair<int, S>, then moves the
pair into the map.

Remember that make_pair deduces the type of its arguments. And V1 and V2 here
are the decayed types of T1 and T2.

The second line forces a pair of type <int, S&&>, so you get one move after the
initial construct.

The third line makes a pair<int, int> then uses that pair to construct a pair of
<int, S> in the map.
#+END_NOTES

** ~emplace~

Enter the /wonderful C++11 panacea/ that is move semantics.

#+BEGIN_SRC c++
// recall S has an implicit constructor from Foo
// but an explicit constructor from int

using M = std::map<int, S>;
M m;

// template <class... Args>
// pair<iterator,bool> emplace(Args&&... args);

// this was 2 moves
// m.insert(make_pair(0, S{1}));

// much better, right?
m.emplace(std::make_pair(0, S{1}));
#+END_SRC

You guessed it...

#+BEGIN_NOTES
Don't do this. It is /exactly/ the same as ~insert~ here. Two moves.
#+END_NOTES

** ~emplace~, better usage

#+BEGIN_SRC c++
// recall S has an implicit constructor from Foo
// but an explicit constructor from int

using M = std::map<int, S>;
M m;

// template <class... Args>
// pair<iterator,bool> emplace(Args&&... args);

m.emplace(0, 1); // no moves, just a construct
#+END_SRC

#+BEGIN_NOTES
Again, the point of ~emplace~ is in-place construction.

It doesn't help you over ~insert~ if you just pass rvalues. ~insert~ works just
fine with rvalues.
#+END_NOTES

** ~emplace~ problem

What do we do when we want to default-construct the value?

#+BEGIN_SRC c++
using M = std::map<int, S>;
M m;
m.emplace(0); // default construct S please!
#+END_SRC

#+ATTR_REVEAL: :frag (appear)
/error 2665: ~std::pair<const _Kty,_Ty>::pair~: none of the 2 overloads could
convert all the argument types/

#+BEGIN_NOTES
Here's a problem: how can we tell ~emplace~ to zero-arg construct the value when
we can't syntactically pass "zero arguments" in the place of an argument.

We don't want to default-construct an S explicitly here and move it in.

We could use ~operator[]~ but that would be weird. I don't like expression
statements and I would probably write ~operator[]~ with nodiscard.

Remember the ~value_type~ of the ~map~ is a ~pair~ - that's what ~emplace~ is
trying to construct.
#+END_NOTES

** ~emplace~ with zero-arg constructor

Our old friend ~piecewise_construct~ can help.

#+BEGIN_SRC c++
using M = std::map<int, S>;
M m;
m.emplace(std::piecewise_construct,
          std::forward_as_tuple(0),
          std::forward_as_tuple()); // default construct S please!
#+END_SRC

Tuples are allowed to be empty!

Yes, we can also use this for more-than-one-arg constructors.

#+BEGIN_NOTES
Here's the piecewise constructor on ~pair~ again.
#+END_NOTES

** Exhibit G

#+BEGIN_SRC c++
// explicit ClientIdRecord(
//  const string& clientId, const ProcessId& clientProc, const ProcessId& serverProc);

using Storage = std::unordered_set<ClientIdRecord>;
Storage m_storage;
m_storage.emplace(inClientId, clientProc, serverProc);
#+END_SRC

Perfectly fine as far as ~emplace~ usage.

Then we want to change the ~unordered_set~ to an ~unordered_map~.

#+BEGIN_NOTES
ClientIdRecord has a 3-argument constructor.

~inClientId~ is a string.

One in-place construct. This is fine.
#+END_NOTES

** Exhibit G

#+BEGIN_SRC c++
// explicit ClientIdRecord(
//  const string& clientId, const ProcessId& clientProc, const ProcessId& serverProc);

using Storage = std::unordered_map<std::string, ClientIdRecord>;
Storage m_storage;
m_storage.emplace(
  std::make_pair(inClientId,
                 ClientIdRecord(inClientId, clientProc, serverProc)));
#+END_SRC

Is this optimal?

#+BEGIN_NOTES
2 extra moves here.

How do we do better?
#+END_NOTES

** Exhibit G

#+BEGIN_SRC c++
using Storage = std::unordered_map<std::string, ClientIdRecord>;
Storage m_storage;
m_storage.emplace(std::piecewise_construct,
                  std::forward_as_tuple(inClientId),
                  std::forward_as_tuple(inClientId, clientProc, serverProc));
#+END_SRC

Use ~piecewise_construct~ again.

** ~emplace~ problem 2

What do you do if you want to ~emplace~ the result of a function call?

#+BEGIN_SRC c++
S get_S() { return S{1}; }
#+END_SRC

#+BEGIN_SRC c++
using M = std::map<int, S>;
M m;
m.emplace(0, get_S());
#+END_SRC

How can we avoid the move?

Is it possible to in-place construct here?

** In-place construct a function call result

We can't avoid evaluating the function call before calling ~emplace~.

But, we can control when the result of the function call becomes an ~S~.

** In-place construct a function call result

#+BEGIN_SRC c++
template <typename F>
struct with_result_of_t
{
  using T = std::result_of_t<F()>;
  explicit with_result_of_t(F f) : f(std::move(f)) {}
  operator T() { return f(); }

private:
  F f;
};

// prior to CTAD
template <typename F>
inline auto with_result_of(F&& f) {
  return with_result_of_t<F>(std::forward<F>(f));
}
#+END_SRC

#+BEGIN_NOTES
Capture the function and call it only at the point that we want to convert the
result to an ~S~.

~invoke_result_t~ is C++17 - before that you can use ~result_of_t~.
#+END_NOTES

** ~emplace~ problem 2

#+BEGIN_SRC c++
S get_S() { return S{1}; }

using M = std::map<int, S>;
M m;
m.emplace(0, with_result_of([] { return get_S(); }));

// m.emplace(0, with_result_of(get_S));
#+END_SRC

Compilers are really good at optimizing single-use lambdas.

#+BEGIN_NOTES
You would think the second line here would work just as well. But VC++
doesn't manage to elide the move.
#+END_NOTES

** C++17: ~insert_or_assign~

Of course, ~insert~ / ~emplace~ and ~operator[]~ actually do different things.

What do you do if you want to insert, or assign if the element is already there?

#+BEGIN_SRC c++
template <class M>
pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);

template <class M>
pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
#+END_SRC

Introduced with C++17.

#+BEGIN_NOTES
~insert_or_assign~ doesn't need default construction (unlike ~operator[]~).

~insert_or_assign~ was introduced with C++17. Can be written as a free function,
but difficult/impossible to make as efficient as map can as a member function.
#+END_NOTES

** C++17: ~insert_or_assign~

Yet another slightly different interface...

#+BEGIN_SRC c++
using M = std::map<int, S>;
M m;
m.insert_or_assign(0, Foo{}); // implicit construction - fine

// m.insert_or_assign(1, 1);  // explicit construction - error!
m.insert_or_assign(1, with_result_of([]{ return S{1}; })); // RVO
#+END_SRC

#+BEGIN_NOTES
Unfortunately there is no ~emplace_or_assign~. (In the assign case presumably
could not avoid making a temporary to assign). But you can use the same
~with_result_of~ technique with ~insert_or_assign~.
#+END_NOTES

** Exhibit H

#+BEGIN_SRC c++
template <typename K, typename V>
typename LRUCache<K, V>::EntryPtr LRUCache<K, V>::Insert(const K& key, V value)
{
  // Is the key already present?
  if (m_entries.find(key) != m_entries.end()) return nullptr;

  // Is the cache full?
  if (m_entries.size() == m_capacity) Evict(1);

  // Insert the new value.
  EntryPtr e = std::make_shared<Entry>(key, std::move(value));
  Append(e.get());
  m_entries[key] = e;

  return e;
}
#+END_SRC

#+BEGIN_NOTES
Given everything we've learned, let's critique this code.

We can see that it's inserting a KV pair into a cache with a least-recently-used
eviction strategy. There is a map that owns a shared_ptr, and that shared_ptr is
also weakly-referenced from a deque (see Append call)?

+ use pass-by-value to simplify handling
+ use ~make_shared~

- use ~operator[]~ - default construct shared_ptr + assign
- extra shared_ptr ref
#+END_NOTES

** Exhibit H

#+BEGIN_SRC c++
// Insert the new value.
decltype(m_entries.begin()) it;
std::tie(it, std::ignore) =
  m_entries.emplace(key, std::make_shared<Entry>(key, std::move(value)));
Append(it->second.get());

return it->second;
#+END_SRC

#+BEGIN_NOTES
+ m_entries can still be any associative container (no loss of generality)
+ save 2 shared_ptr reference updates (plus check on assign of the default-constructed one)

We could use with_result_of here to construct the shared_ptr directly in place.
#+END_NOTES

** Recommendations

Yes, C++ is complicated.

 - Initialization: consider ~for_each_n_args~
 - You can use ~insert~ with ~make_pair~ and implicit construction
   - But don't use call-site explicit construction
 - Use ~emplace~ but beware of explicit construction
 - Use ~piecewise_construct~ for other than single-arg construction
 - Try to avoid ~operator[]~
 - Adopt ~insert_or_assign~ when it's available
 - Consider ~with_result_of~

* 6. Putting stuff into other things

Like ~optional~, ~variant~, ~any~.

#+REVEAL_HTML: <div class='vertspace2'></div>
#+REVEAL_HTML: <blockquote nil><p>&quot;There's more depends on this than on the value.&quot;</p>
#+REVEAL_HTML: <div></div><div class='author'>-- William Shakespeare, <em>The Merchant of Venice</em></div></blockquote>

** ~optional~ and friends

#+BEGIN_SRC c++
template <class... Args>
constexpr explicit optional(in_place_t, Args&&... args);

template <class T, class... Args>
constexpr explicit variant(in_place_type_t<T>, Args&&... args);
template <size_t I, class... Args>
constexpr explicit variant(in_place_index_t<I>, Args&&... args);

template <class ValueType, class... Args>
explicit any(in_place_type_t<ValueType>, Args&&... args);
#+END_SRC

#+BEGIN_NOTES
All these new vocabulary types have constructors that take ~in_place~ tag
arguments. They work similarly to ~piecewise_construct~ but they're only
constructing one thing.
#+END_NOTES

** ~optional~ construction

implicit constructor
#+BEGIN_SRC c++
std::optional<S> opt = Foo{};
#+END_SRC

~explicit~ constructor (naive method)
#+BEGIN_SRC c++
std::optional<S> opt = S{1};
#+END_SRC

~explicit~ constructor (in-place method)
#+BEGIN_SRC c++
std::optional<S> opt(std::in_place, 1);
#+END_SRC

#+BEGIN_NOTES
In the first case, it's fine: just one in-place construct.

In the second case, we have an ~explicit~ constructor. So if we use this style,
we get a construct and a move.

The third case is the way to go for in-place construction. It can also be used
with an implicit constructor of course.
#+END_NOTES

** ~optional~ assignment

implicit constructor
#+BEGIN_SRC c++
std::optional<S> opt;
opt = Foo{};
#+END_SRC

~explicit~ constructor (naive method)
#+BEGIN_SRC c++
std::optional<S> opt;
opt = S{1};
#+END_SRC

~explicit~ constructor (in-place method)
#+BEGIN_SRC c++
std::optional<S> opt;
opt.emplace(1);
#+END_SRC

#+BEGIN_NOTES
Similar story here.
#+END_NOTES

** ~optional~ recommendations

 - use the ~in_place_t~ constructor
 - avoid ~explicit~ construction
 - use ~emplace~ for assignment

#+BEGIN_SRC c++
std::optional<S> opt(std::in_place, 1);
opt.emplace(2);
#+END_SRC

#+BEGIN_NOTES
You'll never go wrong with these.

Again we could use the with_result_of to in-place construct the result of a
function call.
#+END_NOTES

** ~variant~ construction

implicit constructor
#+BEGIN_SRC c++
std::variant<int, S> v = Foo{};
#+END_SRC

~explicit~ constructor (naive method)
#+BEGIN_SRC c++
std::variant<int, S> v = S{1};
#+END_SRC

~explicit~ constructor (oops method)
#+BEGIN_SRC c++
std::variant<int, S> v = 1;
#+END_SRC

#+BEGIN_NOTES
Similar story as ~optional~.

But there is the potential for a bug with the ~explicit~ constructor. What makes
this somewhat likely is that it might be the case that someone makes a
constructor explicit later on.
#+END_NOTES

** ~variant~ construction

Recommendation: use either of these two constructions.

#+BEGIN_SRC c++
std::variant<int, S> v(std::in_place_type<S>, 1);
#+END_SRC

#+BEGIN_SRC c++
std::variant<int, S> v(std::in_place_index<1>, 1);
#+END_SRC

#+BEGIN_NOTES
I would generally prefer the first except in cases where the same type occurs in
multiple places in the ~variant~, which is relatively rarer.
#+END_NOTES

** ~variant~ assignment

Similar story to construction.

#+BEGIN_SRC c++
std::variant<int, S> v;

v = Foo{}; // fine
v = S{1};  // constructs a temporary
v = 1;     // oops
#+END_SRC

** ~variant~ danger!

Implicitly-typed ~variant~ construction/assignment can be dangerous.

#+BEGIN_SRC c++
int main() {
  std::variant<bool, std::string> v = "Hello";
  std::cout << "index is " << v.index() << '\n';
}
#+END_SRC

What does this output?

#+BEGIN_NOTES
Avoid implicit type conversions. They're dangerous. The first possible one will apply.
#+END_NOTES

** Safe, efficient ~variant~ assignment

#+BEGIN_SRC c++
std::variant<int, S> v;
// template <class T, class... Args>
// T& emplace(Args&&... args);
v.emplace<S>(1);  // S{1}
#+END_SRC

#+BEGIN_SRC c++
std::variant<int, S> v;
// template <size_t I, class... Args>
// variant_alternative_t<I, variant>& emplace(Args&&... args);
v.emplace<1>(1);  // S{1}
#+END_SRC

** ~variant~ recommendations

 - always be explicit about types
 - use ~in_place_type~ or ~in_place_index~ constructors
 - use ~emplace<T>~ or ~emplace<I>~
 - avoid ~operator=~ (except actual ~variant~-to-~variant~)

#+BEGIN_NOTES
Obviously ~operator=~ is used implicitly by the compiler.
#+END_NOTES

* 7. Final Guidelines and Recommendations

#+REVEAL_HTML: <div class='vertspace2'></div>
#+REVEAL_HTML: <blockquote nil><p>&quot;Share the advice betwixt you; if both gain all,<br>The gift doth stretch itself as 'tis receiv'd,<br>And is enough for both.&quot;</p>
#+REVEAL_HTML: <div></div><div class='author'>-- William Shakespeare, <em>All's Well That Ends Well</em></div></blockquote>

** Recommendations

Think about copies and moves.

Moves aren't free, and may not be cheap.

Usually, in-place construction is preferable. And it is nearly always possible.

Know how RVO works, and check that the compiler is doing it when you think it is.

Beware ~initializer_list~.

Feel free to ping me with any questions, any time.
