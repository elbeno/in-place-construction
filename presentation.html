<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Everyday Efficiency: In-place Construction</title>
<meta name="author" content="(Ben Deane)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="../reveal.js/css/theme/blood.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h2>Everyday Efficiency: In-place Construction</h2><div class='vertspace2'></div><blockquote nil><p>&quot;Make no collection of it: let him show<br>His skill is in the construction.&quot;</p><div></div><div class='author'>-- William Shakespeare, <em>Cymbeline</em></div></blockquote><div class='vertspace3'></div><h3>Ben Deane / <a href="mailto:bdeane@blizzard.com">bdeane@blizzard.com</a></h3><h4>13th July 2018</h4>
</section>
<script type="text/javascript" src="./presentation.js"></script>

<section>
<section id="slide-orgecf37bf">
<h2 id="orgecf37bf">Get Ready</h2>
<ol>
<li>What happens when we <code>move</code> something?</li>
<li>Copy elision (RVO)</li>
<li>Putting stuff into a <code>vector</code></li>
<li><code>initializer_list</code></li>
<li>Putting stuff into a <code>map</code></li>
<li>Putting stuff into other things</li>
<li>Final thoughts</li>

</ol>

<aside class="notes">
<p>
There will be a lot of code snippets in this talk.
</p>

<p>
I will be asking a lot of questions.
</p>

<p>
I'm assuming everyone is using C++14, although most things we talk about will
require no more than C++11. I'll mention a couple of C++17 features.
</p>

<p>
Most of what you see is common to either <code>blz</code> or toolchain-STL. I've omitted
namespaces from the slides for brevity.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org8a8e364">
<h2 id="org8a8e364">Disclaimer</h2>
<p>
I'm going to critique some code in this talk.
</p>

<p>
If it's your code, please don't feel slighted.
</p>

<p>
I assure you that I write and have written plenty of suboptimal code.
</p>

<p>
Let's make code better together!
</p>

</section>
</section>
<section>
<section id="slide-orgd016b62">
<h2 id="orgd016b62">Preliminaries</h2>
<iframe width="1400px" height="600px" src="http://localhost:10240/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,lang:c%2B%2B,source:'%23include+%3Cstdio.h%3E%0A%0Astruct+Foo+%7B%7D%3B%0A%0Astruct+S%0A%7B%0A++S()+%7B+puts(%22Default+construct%5Cn%22)%3B+%7D%0A++S(Foo)+%7B+puts(%22Value+construct%5Cn%22)%3B+%7D%0A++explicit+S(int)+%7B+puts(%22Explicit+value+construct+(1)%5Cn%22)%3B+%7D%0A++explicit+S(int,+int)+%7B+puts(%22Explicit+value+construct+(2)%5Cn%22)%3B%7D%0A++~S()+%7B+puts(%22Destruct%5Cn%22)%3B+%7D%0A++S(const+S%26)+%7B+puts(%22Copy+construct%5Cn%22)%3B+%7D%0A++S(S%26%26)+%7B+puts(%22Move+construct%5Cn%22)%3B+%7D%0A++S%26+operator%3D(const+S%26)+%7B+puts(%22Copy+assign%5Cn%22)%3B+return+*this%3B+%7D%0A++S%26+operator%3D(S%26%26)+%7B+puts(%22Move+assign%5Cn%22)%3B+return+*this%3B+%7D%0A%7D%3B%0A%0Aint+main()%0A%7B%0A++++S+s%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:67.78783958602847,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:/usr/bin/clang%2B%2B-6.0,filters:(b:'0',binary:'0',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',trim:'0'),lang:c%2B%2B,libs:!((name:bc,ver:master),(name:blz,ver:master)),options:'-O3+-std%3Dc%2B%2B17+-DBC_ASSERTIONS_ENABLED%3D0',source:1),l:'5',n:'0',o:'/usr/bin/clang%2B%2B-6.0+(Editor+%231,+Compiler+%231)+C%2B%2B',t:'0')),k:50.268733850129195,l:'4',m:25.410872313527182,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:1.8575209267199997,wrap:'1'),l:'5',n:'0',o:'%231+with+/usr/bin/clang%2B%2B-6.0',t:'0')),header:(),l:'4',m:74.5891276864728,n:'0',o:'',s:0,t:'0')),k:32.21216041397154,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

<aside class="notes">
<p>
You're going to see a lot of this later in the talk, when we examine how various
snippets of code behave.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org2adbf31">
<h2 id="org2adbf31">1. What happens when we <code>move</code> something?</h2>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v1</span> = <span style="color: #707183;">{</span><span style="color: #008b8b;">1</span>, <span style="color: #008b8b;">2</span>, <span style="color: #008b8b;">3</span>, <span style="color: #008b8b;">4</span>, <span style="color: #008b8b;">5</span><span style="color: #707183;">}</span>;
<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v2</span> = move<span style="color: #707183;">(</span>v1<span style="color: #707183;">)</span>;
</pre>
</div>

<p>
What's in <code>v1</code> after the move?
</p>

<aside class="notes">
<p>
The standard says "valid but unspecified". We know that we're allowed to destroy
it, because for things to be otherwise would be a nonsense. <code>v1</code> <span class="underline">will</span> be
destroyed like any other C++ object when it goes out of scope.
</p>

<p>
Here's where we deviate from the standard. How is <code>vector</code> implemented,
basically? (pointer-to-buffer, size, capacity). On destruction, what must it do?
</p>

</aside>

</section>
<section id="slide-org7ce3d8d">
<h3 id="org7ce3d8d">A moved-from <code>vector</code></h3>
<p>
It must be destroyable.
</p>

<p>
What is sufficient? What is likely?
</p>
<ul>
<li>begin pointer is null?</li>
<li>size is zero?</li>
<li>capacity is zero?</li>

</ul>

</section>
<section id="slide-org62ccfcf">
<h3 id="org62ccfcf">Exhibit A</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #008b8b;">WebSocketHandshakerImpl</span>::<span style="color: #0000ff;">ProcessServerHandshake</span><span style="color: #707183;">(</span><span style="color: #228b22;">HttpMessage</span> <span style="color: #a0522d;">message</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #006400;">// </span><span style="color: #006400;">some stuff...</span>

  m_result.extra = <span style="color: #008b8b;">blz</span>::move<span style="color: #7388d6;">(</span>m_readBuffer<span style="color: #7388d6;">)</span>;
  m_result.headers = <span style="color: #008b8b;">blz</span>::move<span style="color: #7388d6;">(</span>message.headers<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
This code assumes that it's safe to do whatever comes later to a moved-from <code>vector</code>.
</p>

</section>
<section id="slide-org5430ec8">
<h3 id="org5430ec8">Now consider:</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">string</span> <span style="color: #a0522d;">s1</span> = <span style="color: #b22222;">"Greetings, planet"</span>;
<span style="color: #228b22;">string</span> <span style="color: #a0522d;">s2</span> = move<span style="color: #707183;">(</span>s1<span style="color: #707183;">)</span>;
</pre>
</div>

<p>
What's the moved-from state of <code>s1</code>?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">string</span> <span style="color: #a0522d;">s3</span> = <span style="color: #b22222;">"Hello, world"</span>;
<span style="color: #228b22;">string</span> <span style="color: #a0522d;">s4</span> = move<span style="color: #707183;">(</span>s3<span style="color: #707183;">)</span>;
</pre>
</div>

<p>
What's the moved-from state of <code>s3</code>?
</p>

<aside class="notes">
<p>
What is the state of s1 in the second case? Same as the vector case basically.
</p>

<p>
But the first example is small-string optimized. What happens when you move from
a small string? You have to copy.
</p>

<p>
What is the state of s1 in the first case? It happens that all major
implementations (blz included) will set the size to zero on a move, even when in
the small string buffer. So it's actually ever so slightly <i>slower</i> than a copy.
</p>

<p>
If you're lucky, the optimizer can help you out and spot dead stores&#x2026;
</p>

<p>
Bloomberg's STL does not clear a moved-from SSO string.
</p>

</aside>

</section>
<section id="slide-orgd0b5519">
<h3 id="orgd0b5519">Observation</h3>
<p>
Moving from a <code>string</code> usually <i>isn't any faster</i> than copying from it.
</p>

<p>
(If you doubt this, ask yourself why the small string optimization exists in the
first place.)
</p>

<p>
Moves <i>only</i> matter for objects on the heap.
</p>

<p>
<a href="http://quick-bench.com/GtvOqmK-eltAretuiNzQQEcBxdY">http://quick-bench.com/GtvOqmK-eltAretuiNzQQEcBxdY</a>
</p>

<aside class="notes">
<p>
And as noted, it may be technically slower.
</p>

</aside>

</section>
<section id="slide-org3b34bd7">
<h3 id="org3b34bd7">Exhibit B</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #008b8b;">Context</span>::<span style="color: #0000ff;">Trigger</span><span style="color: #707183;">(</span><span style="color: #006400;">/* </span><span style="color: #006400;">some args */</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #006400;">// </span><span style="color: #006400;">Make sure that it will trigger only once.</span>
  <span style="color: #a020f0;">const</span> <span style="color: #228b22;">OnResponseCallback</span> <span style="color: #a0522d;">cb</span> = <span style="color: #008b8b;">blz</span>::move<span style="color: #7388d6;">(</span>m_responseCallback<span style="color: #7388d6;">)</span>;

  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>cb<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">{</span>
    cb<span style="color: #909183;">(</span>errorCode, errorReason, payload, size, opaque<span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
Is this comment telling the truth?
</p>

<aside class="notes">
<p>
Playing with fire. The comment is misleading. We're relying on implementation.
</p>

<p>
Function has a small buffer optimization just like string. There's no reason for
function to be null after a move.
</p>

<p>
Think back to the vector case now: what happens if the container is replaced
with a small-buffer optimizable container?
</p>

</aside>

</section>
<section id="slide-org134a15f">
<h3 id="org134a15f">Guideline (specific)</h3>
<p>
Don't assume things are empty after a <code>move</code>.
</p>

<p>
Use <code>exchange</code> to make sure. Assigning an empty object is a trivial price for
safety.
</p>

<div class="org-src-container">

<pre  class="src src-c++">m_result.extra = <span style="color: #008b8b;">blz</span>::exchange<span style="color: #707183;">(</span>m_readBuffer, <span style="color: #7388d6;">{}</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">const</span> <span style="color: #228b22;">OnResponseCallback</span> <span style="color: #a0522d;">cb</span> = <span style="color: #008b8b;">blz</span>::exchange<span style="color: #707183;">(</span>m_responseCallback, <span style="color: #008b8b;">nullptr</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Make your code safe for future small-buffer optimizations.
</p>

</section>
<section id="slide-org6b2a8e9">
<h3 id="org6b2a8e9">Guideline (more general)</h3>
<p>
If you didn't write the move constructor/operator yourself, after a <code>move</code>, you
may assume:
</p>

<ul>
<li>the object is destroyable</li>
<li>the object is (re-)assignable</li>

</ul>

<p>
<i>NOTHING ELSE</i>
</p>

<p>
Note: This is a stronger constraint than what the standard says.
</p>

<aside class="notes">
<p>
[defns.valid] "the object's invariants are met and operations on the object
behave as specified for its type"
</p>

<p>
The standard says you can call any function without preconditions.
</p>

<p>
But I'm not saying anything that, I'm just saying something <i>more</i> constrained,
and safer.
</p>

</aside>

</section>
<section id="slide-orgfc3f7f2">
<h3 id="orgfc3f7f2">Let's look at this again</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #008b8b;">WebSocketHandshakerImpl</span>::<span style="color: #0000ff;">ProcessServerHandshake</span><span style="color: #707183;">(</span><span style="color: #228b22;">HttpMessage</span> <span style="color: #a0522d;">message</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #006400;">// </span><span style="color: #006400;">some stuff...</span>

  <span style="color: #006400;">// </span><span style="color: #006400;">which would be right here? this?</span>
  m_result.headers = <span style="color: #008b8b;">blz</span>::move<span style="color: #7388d6;">(</span>message.headers<span style="color: #7388d6;">)</span>;

  <span style="color: #006400;">// </span><span style="color: #006400;">or this?</span>
  m_result.headers = <span style="color: #008b8b;">blz</span>::move<span style="color: #7388d6;">(</span>message<span style="color: #7388d6;">)</span>.headers;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
The first option is saying a much stronger thing. The result of <code>move</code> is always
an rvalue reference. That's literally all <code>move</code> does: a cast to an rvalue
reference.
</p>

<p>
The second one is using C++ member access rules to infer the rvalue-ness of the
member. That's fine. We still get the rvalue.
</p>

<p>
The first one is saying "this is definitely an rvalue - trust me!".
</p>

<p>
The second is saying "hey, this is an rvalue, unless something else prevents it".
</p>

<p>
So what would "prevent it"?
</p>

</aside>

</section>
<section id="slide-org35d2630">
<h3 id="org35d2630">There may be trouble ahead</h3>
<p>
Let's say we want always want pretty much the same headers for all requests.
</p>

<p>
What if we decided to change this&#x2026;
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">HttpMessage</span>
<span style="color: #707183;">{</span>
  <span style="color: #008b8b;">blz</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">requestLine</span>;
  <span style="color: #228b22;">Headers</span> <span style="color: #a0522d;">headers</span>;
<span style="color: #707183;">}</span>;
</pre>
</div>
<p>
&#x2026;to this?
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">HttpMessage</span>
<span style="color: #707183;">{</span>
  <span style="color: #008b8b;">blz</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">requestLine</span>;
  <span style="color: #228b22;">Headers</span>&amp; <span style="color: #a0522d;">headers</span>;
<span style="color: #707183;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
What happens when we change <code>Header</code> to a reference?
</p>

<p>
The HttpMessage itself can be an rvalue, but what it's referencing isn't.
</p>

</aside>

</section>
<section id="slide-orgab2a0c1">
<h3 id="orgab2a0c1">Guideline</h3>
<p>
Use <code>move(obj).member</code> rather than <code>move(obj.member)</code>
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">always safe, non-reference member is still an rvalue</span>
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">x</span> = move<span style="color: #707183;">(</span>obj<span style="color: #707183;">)</span>.member;

<span style="color: #006400;">// </span><span style="color: #006400;">could erroneously move from an lvalue-ref!</span>
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">x</span> = move<span style="color: #707183;">(</span>obj.member<span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
If we cast obj to an rvalue-ref, its member will also (usually) be an rvalue
ref, no problem. We aren't losing anything and we're gaining safety.
</p>

</aside>

</section>
<section id="slide-org95f8828">
<h3 id="org95f8828"><code>move</code> safety guidelines</h3>
<ul>
<li>after <code>move</code>, destroy or assign <i>only</i></li>
<li>use <code>exchange</code> to move-and-clear</li>
<li>use <code>move(obj).member</code>, not <code>move(obj.member)</code></li>

</ul>

<aside class="notes">
<p>
The last two points here are useful a lot of the time for writing move
constructors. You're going to be working in terms of the subobjects.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgcdd68a8">
<h2 id="orgcdd68a8">2. Copy Elision (RVO)</h2>
<p>
What is the return value optimization?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">string</span> <span style="color: #0000ff;">bar</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">string</span> <span style="color: #a0522d;">a</span><span style="color: #7388d6;">{</span><span style="color: #b22222;">"Hi"</span><span style="color: #7388d6;">}</span>;
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">b</span> = <span style="color: #008b8b;">42</span>;
  <span style="color: #006400;">// </span><span style="color: #006400;">...</span>
  <span style="color: #a020f0;">return</span> a;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">foo</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">string</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">{</span>bar<span style="color: #909183;">()</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
The caller sets aside space in its own stack frame for the result of the
function, and the callee constructs the result directly in that space.
</p>

<p>
bar() has two local variables.
</p>

<p>
when foo() calls bar() it "passes" the address of the stack variable s.
</p>

</aside>

</section>
<section id="slide-orgb9f7a92">
<h3 id="orgb9f7a92">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orgdb67924">
<h3 id="orgdb67924">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org879aefc">
<h3 id="org879aefc">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo3.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org31890fb">
<h3 id="org31890fb">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo4.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orgc628896">
<h3 id="orgc628896">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo5.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org054c193">
<h3 id="org054c193">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org9798653">
<h3 id="org9798653">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orgde9d983">
<h3 id="orgde9d983">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo3.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org3c5a4e9">
<h3 id="org3c5a4e9">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo4.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org76b36f2">
<h3 id="org76b36f2">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo5.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org814e011">
<h3 id="org814e011">When can RVO not apply?</h3>
<p>
RVO Rules: what is returned has to be either:
</p>

<ul>
<li>a temporary (prvalue)</li>
<li>the name of a stack variable</li>

</ul>

</section>
<section id="slide-org6bd353d">
<h3 id="org6bd353d">When can RVO not apply?</h3>
<p>
RVO Ability: sometimes, the callee <i>can't</i> construct the object in-place.
</p>

<ul>
<li>if there is no opportunity to</li>
<li>if it's not of the right type</li>
<li>if the callee doesn't know enough</li>

</ul>

<aside class="notes">
<p>
Function arguments that are passed to you already-constructed can't be RVOed on
return. But you can move them.
</p>

<p>
You have to know at construction time that you're going to be returning that
variable in order to RVO it.
</p>

</aside>

</section>
<section id="slide-org63315e6">
<h3 id="org63315e6">No RVO because no opportunity</h3>
<p>
You can't RVO a variable if you didn't get the chance to construct it in the
first place.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">string</span> <span style="color: #0000ff;">sad_function</span><span style="color: #707183;">(</span><span style="color: #228b22;">string</span> <span style="color: #a0522d;">s</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  s += <span style="color: #b22222;">"No RVO for you!"</span>;
  <span style="color: #a020f0;">return</span> s;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
But the compiler will still move it. (Since C++11)
</p>

<aside class="notes">
<p>
C++11 mandates that if you can't do the RVO, you must try to move and only copy
as a last resort.
</p>

</aside>

</section>
<section id="slide-org144b2f8">
<h3 id="org144b2f8">No RVO because wrong type, 1</h3>
<p>
An rvalue-ref is not the same type.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">string</span> <span style="color: #0000ff;">sad_function</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">string</span> <span style="color: #a0522d;">s</span> = <span style="color: #b22222;">"No RVO for you!"</span>;
  <span style="color: #a020f0;">return</span> move<span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
Don't <code>return move(x)</code> in most cases - you will get a move when you didn't need anything!
</p>

<aside class="notes">
<p>
There are legitimate cases for returning an rvalue reference.
</p>

<p>
One of the few times when <code>return move(x)</code> is proper is when you're returning a
member variable out of a rvalue-ref-qualified member function.
</p>

</aside>

</section>
<section id="slide-orga1b3a66">
<h3 id="orga1b3a66">No RVO because wrong type, 2</h3>
<p>
Factory functions can't RVO.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Base</span> <span style="color: #707183;">{</span> <span style="color: #0000ff;">...</span> <span style="color: #707183;">}</span>;
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Derived</span> : <span style="color: #228b22;">Base</span> <span style="color: #707183;">{</span> <span style="color: #0000ff;">...</span> <span style="color: #707183;">}</span>;

<span style="color: #228b22;">shared_ptr</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">Base</span><span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">factory</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> make_shared<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Derived</span><span style="color: #7388d6;">&gt;()</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
But will still move.
</p>

<aside class="notes">
<p>
This is also true of any types that are inter-convertible.
e.g. returning a pair when the function returns a tuple, or something like that.
</p>

</aside>

</section>
<section id="slide-org2182604">
<h3 id="org2182604">No RVO because not enough info</h3>
<p>
It has to be decidable at construction time.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">string</span> <span style="color: #0000ff;">undecided_function</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">string</span> <span style="color: #a0522d;">happy</span> = <span style="color: #b22222;">"Hooray"</span>;
  <span style="color: #228b22;">string</span> <span style="color: #a0522d;">sad</span> = <span style="color: #b22222;">"Boo hoo"</span>;

  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>getHappiness<span style="color: #909183;">()</span> &gt; <span style="color: #008b8b;">0.5</span><span style="color: #7388d6;">)</span>
    <span style="color: #a020f0;">return</span> happy;
  <span style="color: #a020f0;">else</span>
    <span style="color: #a020f0;">return</span> sad;
<span style="color: #707183;">}</span>

</pre>
</div>
<p>
Again, return value will still be moved.
</p>

</section>
<section id="slide-org0dc40d2">
<h3 id="org0dc40d2">Why is RVO important?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">string</span>, <span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span>;

<span style="color: #228b22;">M</span> <span style="color: #0000ff;">build_map</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
  m.insert<span style="color: #7388d6;">(</span>make_pair<span style="color: #909183;">(</span><span style="color: #b22222;">"Jenny"</span>, <span style="color: #008b8b;">8</span><span style="color: #008b8b; background-color: #eeeeee; font-weight: bold; text-decoration: underline;">675</span><span style="color: #008b8b;">309</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">return</span> m;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
RVO is really important for performance. It's probably the single most important
optimization compilers make. Hence why it's been around for decades, even
without a standard.
</p>

<p>
If we accidentally inhibit RVO, we might also inhibit <code>move</code>. We might get a
copy.
</p>

<p>
<code>move</code> isn't necessarily cheap. Microsoft's node-based containers allocate in
their move constructors because they use sentinel nodes.
</p>

</aside>

</section>
<section id="slide-org4f0a63c">
<h3 id="org4f0a63c">Quiz time</h3>
<p>
Wake up!
</p>

<p>
And tell me if the upcoming code snippets will activate RVO.
</p>

</section>
<section id="slide-org89c4f64">
<h3 id="org89c4f64">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">const</span> <span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-orgdd4cab0">
<h3 id="orgdd4cab0">Will it RVO?</h3>
<p>
Yes.
</p>

<iframe width="1400px" height="600px" src="http://localhost:10240/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,lang:c%2B%2B,source:'%23include+%3Cstdio.h%3E%0A%0Astruct+Foo+%7B%7D%3B%0A%0Astruct+S%0A%7B%0A++S()+%7B+puts(%22Default+construct%5Cn%22)%3B+%7D%0A++S(Foo)+%7B+puts(%22Value+construct%5Cn%22)%3B+%7D%0A++explicit+S(int)+%7B+puts(%22Explicit+value+construct+(1)%5Cn%22)%3B+%7D%0A++explicit+S(int,+int)+%7B+puts(%22Explicit+value+construct+(2)%5Cn%22)%3B%7D%0A++~S()+%7B+puts(%22Destruct%5Cn%22)%3B+%7D%0A++S(const+S%26)+%7B+puts(%22Copy+construct%5Cn%22)%3B+%7D%0A++S(S%26%26)+%7B+puts(%22Move+construct%5Cn%22)%3B+%7D%0A++S%26+operator%3D(const+S%26)+%7B+puts(%22Copy+assign%5Cn%22)%3B+return+*this%3B+%7D%0A++S%26+operator%3D(S%26%26)+%7B+puts(%22Move+assign%5Cn%22)%3B+return+*this%3B+%7D%0A%7D%3B%0A%0Aconst+S+will_it_rvo()%0A%7B%0A++return+S%7B1%7D%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++++S+s+%3D+will_it_rvo()%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:63.0659767141009,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:/usr/bin/clang%2B%2B-6.0,filters:(b:'0',binary:'0',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',trim:'1',undefined:'1'),lang:c%2B%2B,libs:!((name:bc,ver:master),(name:blz,ver:master)),options:'-O3+-std%3Dc%2B%2B17',source:1),l:'5',n:'0',o:'/usr/bin/clang%2B%2B-6.0+(Editor+%231,+Compiler+%231)+C%2B%2B',t:'0')),header:(),k:50,l:'4',m:19.721871049304678,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:1.8575209267199997,wrap:'1'),l:'5',n:'0',o:'%231+with+/usr/bin/clang%2B%2B-6.0',t:'0')),header:(),l:'4',m:80.27812895069533,n:'0',o:'',s:0,t:'0')),k:36.9340232858991,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

<aside class="notes">
<p>
Yes. You're allowed to cv-qualify return types and RVO still works.
</p>

<p>
But don't do this. The compiler ignores const-qualified builtin types anyway.
</p>

</aside>

</section>
<section id="slide-org4f4cf90">
<h3 id="org4f4cf90">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>b<span style="color: #7388d6;">)</span>
    <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">else</span>
    <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-orgf703642">
<h3 id="orgf703642">Will it RVO?</h3>
<p>
Yes.
</p>

<iframe width="1400px" height="600px" src="http://localhost:10240/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,lang:c%2B%2B,source:'%23include+%3Cstdio.h%3E%0A%0Astruct+Foo+%7B%7D%3B%0A%0Astruct+S%0A%7B%0A++S()+%7B+puts(%22Default+construct%5Cn%22)%3B+%7D%0A++S(Foo)+%7B+puts(%22Value+construct%5Cn%22)%3B+%7D%0A++explicit+S(int)+%7B+puts(%22Explicit+value+construct+(1)%5Cn%22)%3B+%7D%0A++explicit+S(int,+int)+%7B+puts(%22Explicit+value+construct+(2)%5Cn%22)%3B%7D%0A++~S()+%7B+puts(%22Destruct%5Cn%22)%3B+%7D%0A++S(const+S%26)+%7B+puts(%22Copy+construct%5Cn%22)%3B+%7D%0A++S(S%26%26)+%7B+puts(%22Move+construct%5Cn%22)%3B+%7D%0A++S%26+operator%3D(const+S%26)+%7B+puts(%22Copy+assign%5Cn%22)%3B+return+*this%3B+%7D%0A++S%26+operator%3D(S%26%26)+%7B+puts(%22Move+assign%5Cn%22)%3B+return+*this%3B+%7D%0A%7D%3B%0A%0Aconst+S+will_it_rvo(bool+b)%0A%7B%0A++if+(b)%0A++++return+S%7B1%7D%3B%0A++else%0A++++return+S%7B0%7D%3B%0A%7D%0A%0Aint+main(int+argc,+char*+argv%5B%5D)%0A%7B%0A++++S+s+%3D+will_it_rvo(argc+%3D%3D+1)%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:63.0659767141009,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:/usr/bin/clang%2B%2B-6.0,filters:(b:'0',binary:'0',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',trim:'1',undefined:'1'),lang:c%2B%2B,libs:!((name:bc,ver:master),(name:blz,ver:master)),options:'-O3+-std%3Dc%2B%2B17',source:1),l:'5',n:'0',o:'/usr/bin/clang%2B%2B-6.0+(Editor+%231,+Compiler+%231)+C%2B%2B',t:'0')),header:(),k:50,l:'4',m:19.721871049304678,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:1.8575209267199997,wrap:'1'),l:'5',n:'0',o:'%231+with+/usr/bin/clang%2B%2B-6.0',t:'0')),header:(),l:'4',m:80.27812895069533,n:'0',o:'',s:0,t:'0')),k:36.9340232858991,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

<aside class="notes">
<p>
Yes. This is URVO, and works pretty reliably even in debug builds.
</p>

</aside>

</section>
<section id="slide-org72304a4">
<h3 id="org72304a4">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span>, <span style="color: #228b22;">S</span> <span style="color: #a0522d;">s</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>b<span style="color: #7388d6;">)</span>
    s = S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">return</span> s;
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-org6181542">
<h3 id="org6181542">Will it RVO?</h3>
<p>
No. (No opportunity.)
</p>

<iframe width="1400px" height="600px" src="http://localhost:10240/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,lang:c%2B%2B,source:'%23include+%3Cstdio.h%3E%0A%0Astruct+Foo+%7B%7D%3B%0A%0Astruct+S%0A%7B%0A++S()+%7B+puts(%22Default+construct%5Cn%22)%3B+%7D%0A++S(Foo)+%7B+puts(%22Value+construct%5Cn%22)%3B+%7D%0A++explicit+S(int)+%7B+puts(%22Explicit+value+construct+(1)%5Cn%22)%3B+%7D%0A++explicit+S(int,+int)+%7B+puts(%22Explicit+value+construct+(2)%5Cn%22)%3B%7D%0A++~S()+%7B+puts(%22Destruct%5Cn%22)%3B+%7D%0A++S(const+S%26)+%7B+puts(%22Copy+construct%5Cn%22)%3B+%7D%0A++S(S%26%26)+%7B+puts(%22Move+construct%5Cn%22)%3B+%7D%0A++S%26+operator%3D(const+S%26)+%7B+puts(%22Copy+assign%5Cn%22)%3B+return+*this%3B+%7D%0A++S%26+operator%3D(S%26%26)+%7B+puts(%22Move+assign%5Cn%22)%3B+return+*this%3B+%7D%0A%7D%3B%0A%0Aconst+S+will_it_rvo(bool+b,+S+s)%0A%7B%0A++if+(b)%0A++++s+%3D+S%7B1%7D%3B%0A++return+s%3B%0A%7D%0A%0Aint+main(int+argc,+char*+argv%5B%5D)%0A%7B%0A++++S+s+%3D+will_it_rvo(argc+%3D%3D+1,+S%7B%7D)%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:63.0659767141009,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:/usr/bin/clang%2B%2B-6.0,filters:(b:'0',binary:'0',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',trim:'1',undefined:'1'),lang:c%2B%2B,libs:!((name:bc,ver:master),(name:blz,ver:master)),options:'-O3+-std%3Dc%2B%2B17',source:1),l:'5',n:'0',o:'/usr/bin/clang%2B%2B-6.0+(Editor+%231,+Compiler+%231)+C%2B%2B',t:'0')),header:(),k:50,l:'4',m:19.721871049304678,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:1.8575209267199997,wrap:'1'),l:'5',n:'0',o:'%231+with+/usr/bin/clang%2B%2B-6.0',t:'0')),header:(),l:'4',m:80.27812895069533,n:'0',o:'',s:0,t:'0')),k:36.9340232858991,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

<aside class="notes">
<p>
No - can't RVO a function parameter. It will move though.
</p>

</aside>

</section>
<section id="slide-orgd712a74">
<h3 id="orgd712a74">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">get_S</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span> <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>; <span style="color: #707183;">}</span>

<span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>b<span style="color: #7388d6;">)</span>
    <span style="color: #a020f0;">return</span> get_S<span style="color: #7388d6;">()</span>;
  <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-org838239b">
<h3 id="org838239b">Will it RVO?</h3>
<p>
Yes. (Can RVO all the way down the callstack.)
</p>

<iframe width="1400px" height="600px" src="http://localhost:10240/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,lang:c%2B%2B,source:'%23include+%3Cstdio.h%3E%0A%0Astruct+Foo+%7B%7D%3B%0A%0Astruct+S%0A%7B%0A++S()+%7B+puts(%22Default+construct%5Cn%22)%3B+%7D%0A++S(Foo)+%7B+puts(%22Value+construct%5Cn%22)%3B+%7D%0A++explicit+S(int)+%7B+puts(%22Explicit+value+construct+(1)%5Cn%22)%3B+%7D%0A++explicit+S(int,+int)+%7B+puts(%22Explicit+value+construct+(2)%5Cn%22)%3B%7D%0A++~S()+%7B+puts(%22Destruct%5Cn%22)%3B+%7D%0A++S(const+S%26)+%7B+puts(%22Copy+construct%5Cn%22)%3B+%7D%0A++S(S%26%26)+%7B+puts(%22Move+construct%5Cn%22)%3B+%7D%0A++S%26+operator%3D(const+S%26)+%7B+puts(%22Copy+assign%5Cn%22)%3B+return+*this%3B+%7D%0A++S%26+operator%3D(S%26%26)+%7B+puts(%22Move+assign%5Cn%22)%3B+return+*this%3B+%7D%0A%7D%3B%0A%0AS+get_S()+%7B+return+S%7B1%7D%3B+%7D%0A%0AS+will_it_rvo(bool+b)%0A%7B%0A++if+(b)%0A++++return+get_S()%3B%0A++return+S%7B0%7D%3B%0A%7D%0A%0Aint+main(int+argc,+char*+argv%5B%5D)%0A%7B%0A++++S+s+%3D+will_it_rvo(argc+%3D%3D+1)%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:63.0659767141009,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:/usr/bin/clang%2B%2B-6.0,filters:(b:'0',binary:'0',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',trim:'1',undefined:'1'),lang:c%2B%2B,libs:!((name:bc,ver:master),(name:blz,ver:master)),options:'-O3+-std%3Dc%2B%2B17',source:1),l:'5',n:'0',o:'/usr/bin/clang%2B%2B-6.0+(Editor+%231,+Compiler+%231)+C%2B%2B',t:'0')),header:(),k:50,l:'4',m:19.721871049304678,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:1.8575209267199997,wrap:'1'),l:'5',n:'0',o:'%231+with+/usr/bin/clang%2B%2B-6.0',t:'0')),header:(),l:'4',m:80.27812895069533,n:'0',o:'',s:0,t:'0')),k:36.9340232858991,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

<aside class="notes">
<p>
Yes. This RVOs.
RVO is allowed to elide multiple copies.
</p>

</aside>

</section>
<section id="slide-orgabb60b5">
<h3 id="orgabb60b5">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>b<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">{</span>
    <span style="color: #228b22;">S</span> <span style="color: #a0522d;">s</span><span style="color: #909183;">{</span><span style="color: #008b8b;">1</span><span style="color: #909183;">}</span>;
    <span style="color: #a020f0;">return</span> s;
  <span style="color: #7388d6;">}</span>
  <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-org8be94ea">
<h3 id="org8be94ea">Will it RVO?</h3>
<p>
Yes (Clang), no (MSVC/GCC).
</p>

<iframe width="1400px" height="600px" src="http://localhost:10240/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,lang:c%2B%2B,source:'%23include+%3Cstdio.h%3E%0A%0Astruct+Foo+%7B%7D%3B%0A%0Astruct+S%0A%7B%0A++S()+%7B+puts(%22Default+construct%5Cn%22)%3B+%7D%0A++S(Foo)+%7B+puts(%22Value+construct%5Cn%22)%3B+%7D%0A++explicit+S(int)+%7B+puts(%22Explicit+value+construct+(1)%5Cn%22)%3B+%7D%0A++explicit+S(int,+int)+%7B+puts(%22Explicit+value+construct+(2)%5Cn%22)%3B%7D%0A++~S()+%7B+puts(%22Destruct%5Cn%22)%3B+%7D%0A++S(const+S%26)+%7B+puts(%22Copy+construct%5Cn%22)%3B+%7D%0A++S(S%26%26)+%7B+puts(%22Move+construct%5Cn%22)%3B+%7D%0A++S%26+operator%3D(const+S%26)+%7B+puts(%22Copy+assign%5Cn%22)%3B+return+*this%3B+%7D%0A++S%26+operator%3D(S%26%26)+%7B+puts(%22Move+assign%5Cn%22)%3B+return+*this%3B+%7D%0A%7D%3B%0A%0AS+will_it_rvo(bool+b)%0A%7B%0A++if+(b)%0A++%7B%0A++++S+s%7B1%7D%3B%0A++++return+s%3B%0A++%7D%0A++return+S%7B0%7D%3B%0A%7D%0A%0Aint+main(int+argc,+char*+argv%5B%5D)%0A%7B%0A++++S+s+%3D+will_it_rvo(argc+%3D%3D+1)%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:63.0659767141009,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:/usr/bin/clang%2B%2B-6.0,filters:(b:'0',binary:'0',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',trim:'1'),lang:c%2B%2B,libs:!((name:bc,ver:master),(name:blz,ver:master)),options:'-O3+-std%3Dc%2B%2B17',source:1),l:'5',n:'0',o:'/usr/bin/clang%2B%2B-6.0+(Editor+%231,+Compiler+%231)+C%2B%2B',t:'0')),header:(),k:50,l:'4',m:19.721871049304678,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:1.8575209267199997,wrap:'1'),l:'5',n:'0',o:'%231+with+/usr/bin/clang%2B%2B-6.0',t:'0')),header:(),l:'4',m:80.27812895069533,n:'0',o:'',s:0,t:'0')),k:36.9340232858991,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

<aside class="notes">
<p>
There's nothing stopping it&#x2026; but only Clang successfully RVO's this.
</p>

</aside>

</section>
<section id="slide-orgc85a51d">
<h3 id="orgc85a51d">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">S</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>b<span style="color: #7388d6;">)</span>
    <span style="color: #a020f0;">return</span> s;
  <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-org5aac12a">
<h3 id="org5aac12a">Will it RVO?</h3>
<p>
No. Possibly in future?
</p>

<iframe width="1400px" height="600px" src="http://localhost:10240/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,lang:c%2B%2B,source:'%23include+%3Cstdio.h%3E%0A%0Astruct+Foo+%7B%7D%3B%0A%0Astruct+S%0A%7B%0A++S()+%7B+puts(%22Default+construct%5Cn%22)%3B+%7D%0A++S(Foo)+%7B+puts(%22Value+construct%5Cn%22)%3B+%7D%0A++explicit+S(int)+%7B+puts(%22Explicit+value+construct+(1)%5Cn%22)%3B+%7D%0A++explicit+S(int,+int)+%7B+puts(%22Explicit+value+construct+(2)%5Cn%22)%3B%7D%0A++~S()+%7B+puts(%22Destruct%5Cn%22)%3B+%7D%0A++S(const+S%26)+%7B+puts(%22Copy+construct%5Cn%22)%3B+%7D%0A++S(S%26%26)+%7B+puts(%22Move+construct%5Cn%22)%3B+%7D%0A++S%26+operator%3D(const+S%26)+%7B+puts(%22Copy+assign%5Cn%22)%3B+return+*this%3B+%7D%0A++S%26+operator%3D(S%26%26)+%7B+puts(%22Move+assign%5Cn%22)%3B+return+*this%3B+%7D%0A%7D%3B%0A%0AS+will_it_rvo(bool+b)%0A%7B%0A++S+s%7B1%7D%3B%0A++if+(b)%0A++++return+s%3B%0A++return+S%7B0%7D%3B%0A%7D%0A%0Aint+main(int+argc,+char*+argv%5B%5D)%0A%7B%0A++++S+s+%3D+will_it_rvo(argc+%3D%3D+1)%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:63.0659767141009,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:/usr/bin/clang%2B%2B-6.0,filters:(b:'0',binary:'0',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',trim:'1'),lang:c%2B%2B,libs:!((name:bc,ver:master),(name:blz,ver:master)),options:'-O3+-std%3Dc%2B%2B17',source:1),l:'5',n:'0',o:'/usr/bin/clang%2B%2B-6.0+(Editor+%231,+Compiler+%231)+C%2B%2B',t:'0')),header:(),k:50,l:'4',m:19.721871049304678,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:1.8575209267199997,wrap:'1'),l:'5',n:'0',o:'%231+with+/usr/bin/clang%2B%2B-6.0',t:'0')),header:(),l:'4',m:80.27812895069533,n:'0',o:'',s:0,t:'0')),k:36.9340232858991,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

<aside class="notes">
<p>
We hoisted the S out of the condition.
</p>

<p>
No RVO here (a sufficiently smart compiler might be able to&#x2026;)
</p>

<p>
It still moves.
</p>

</aside>

</section>
<section id="slide-org8604cbe">
<h3 id="org8604cbe">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">S</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">return</span> b ? s : S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-orgeeb0010">
<h3 id="orgeeb0010">Will it RVO?</h3>
<p>
No. (Against the rules.)
</p>

<iframe width="1400px" height="600px" src="http://localhost:10240/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,lang:c%2B%2B,source:'%23include+%3Cstdio.h%3E%0A%0Astruct+Foo+%7B%7D%3B%0A%0Astruct+S%0A%7B%0A++S()+%7B+puts(%22Default+construct%5Cn%22)%3B+%7D%0A++S(Foo)+%7B+puts(%22Value+construct%5Cn%22)%3B+%7D%0A++explicit+S(int)+%7B+puts(%22Explicit+value+construct+(1)%5Cn%22)%3B+%7D%0A++explicit+S(int,+int)+%7B+puts(%22Explicit+value+construct+(2)%5Cn%22)%3B%7D%0A++~S()+%7B+puts(%22Destruct%5Cn%22)%3B+%7D%0A++S(const+S%26)+%7B+puts(%22Copy+construct%5Cn%22)%3B+%7D%0A++S(S%26%26)+%7B+puts(%22Move+construct%5Cn%22)%3B+%7D%0A++S%26+operator%3D(const+S%26)+%7B+puts(%22Copy+assign%5Cn%22)%3B+return+*this%3B+%7D%0A++S%26+operator%3D(S%26%26)+%7B+puts(%22Move+assign%5Cn%22)%3B+return+*this%3B+%7D%0A%7D%3B%0A%0AS+will_it_rvo(bool+b)%0A%7B%0A++S+s%7B1%7D%3B%0A++return+b+%3F+s+:+S%7B0%7D%3B%0A%7D%0A%0A%0Aint+main(int+argc,+char*+argv%5B%5D)%0A%7B%0A++++S+s+%3D+will_it_rvo(argc+%3D%3D+1)%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:63.0659767141009,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:/usr/bin/clang%2B%2B-6.0,filters:(b:'0',binary:'0',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',trim:'1'),lang:c%2B%2B,libs:!((name:bc,ver:master),(name:blz,ver:master)),options:'-O3+-std%3Dc%2B%2B17',source:1),l:'5',n:'0',o:'/usr/bin/clang%2B%2B-6.0+(Editor+%231,+Compiler+%231)+C%2B%2B',t:'0')),header:(),k:50,l:'4',m:19.721871049304678,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:1.8575209267199997,wrap:'1'),l:'5',n:'0',o:'%231+with+/usr/bin/clang%2B%2B-6.0',t:'0')),header:(),l:'4',m:80.27812895069533,n:'0',o:'',s:0,t:'0')),k:36.9340232858991,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

<aside class="notes">
<p>
No RVO. We're not naming a variable.
Will it still move? No.
</p>

<p>
We're not naming a variable. And it's not a prvalue - the conditional operator
produces an lvalue reference here. We have to copy.
</p>

<p>
This is perhaps a semi-common pattern that defeats RVO!
</p>

</aside>

</section>
<section id="slide-orgbc14438">
<h3 id="orgbc14438">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">get_S</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span> <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>; <span style="color: #707183;">}</span>

<span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> b ? get_S<span style="color: #7388d6;">()</span> : S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-org3013347">
<h3 id="org3013347">Will it RVO?</h3>
<p>
Yes. (Returning temporary.)
</p>

<iframe width="1400px" height="600px" src="http://localhost:10240/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,lang:c%2B%2B,source:'%23include+%3Cstdio.h%3E%0A%0Astruct+Foo+%7B%7D%3B%0A%0Astruct+S%0A%7B%0A++S()+%7B+puts(%22Default+construct%5Cn%22)%3B+%7D%0A++S(Foo)+%7B+puts(%22Value+construct%5Cn%22)%3B+%7D%0A++explicit+S(int)+%7B+puts(%22Explicit+value+construct+(1)%5Cn%22)%3B+%7D%0A++explicit+S(int,+int)+%7B+puts(%22Explicit+value+construct+(2)%5Cn%22)%3B%7D%0A++~S()+%7B+puts(%22Destruct%5Cn%22)%3B+%7D%0A++S(const+S%26)+%7B+puts(%22Copy+construct%5Cn%22)%3B+%7D%0A++S(S%26%26)+%7B+puts(%22Move+construct%5Cn%22)%3B+%7D%0A++S%26+operator%3D(const+S%26)+%7B+puts(%22Copy+assign%5Cn%22)%3B+return+*this%3B+%7D%0A++S%26+operator%3D(S%26%26)+%7B+puts(%22Move+assign%5Cn%22)%3B+return+*this%3B+%7D%0A%7D%3B%0A%0AS+get_S()+%7B+return+S%7B1%7D%3B+%7D%0A%0AS+will_it_rvo(bool+b)%0A%7B%0A++return+b+%3F+get_S()+:+S%7B0%7D%3B%0A%7D%0A%0Aint+main(int+argc,+char*+argv%5B%5D)%0A%7B%0A++++S+s+%3D+will_it_rvo(argc+%3D%3D+1)%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:63.0659767141009,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:/usr/bin/clang%2B%2B-6.0,filters:(b:'0',binary:'0',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',trim:'1'),lang:c%2B%2B,libs:!((name:bc,ver:master),(name:blz,ver:master)),options:'-O3+-std%3Dc%2B%2B17',source:1),l:'5',n:'0',o:'/usr/bin/clang%2B%2B-6.0+(Editor+%231,+Compiler+%231)+C%2B%2B',t:'0')),header:(),k:50,l:'4',m:19.721871049304678,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:1.8575209267199997,wrap:'1'),l:'5',n:'0',o:'%231+with+/usr/bin/clang%2B%2B-6.0',t:'0')),header:(),l:'4',m:80.27812895069533,n:'0',o:'',s:0,t:'0')),k:36.9340232858991,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

<aside class="notes">
<p>
This RVOs. This time the conditional operator produces a prvalue because both of
its operands are prvalues.
</p>

</aside>

</section>
<section id="slide-org211bc05">
<h3 id="org211bc05">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">S</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
  s = S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">2</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">return</span> s;
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-org9de627f">
<h3 id="org9de627f">Will it RVO?</h3>
<p>
Yes.
</p>

<iframe width="1400px" height="600px" src="http://localhost:10240/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,lang:c%2B%2B,source:'%23include+%3Cstdio.h%3E%0A%0Astruct+Foo+%7B%7D%3B%0A%0Astruct+S%0A%7B%0A++S()+%7B+puts(%22Default+construct%5Cn%22)%3B+%7D%0A++S(Foo)+%7B+puts(%22Value+construct%5Cn%22)%3B+%7D%0A++explicit+S(int)+%7B+puts(%22Explicit+value+construct+(1)%5Cn%22)%3B+%7D%0A++explicit+S(int,+int)+%7B+puts(%22Explicit+value+construct+(2)%5Cn%22)%3B%7D%0A++~S()+%7B+puts(%22Destruct%5Cn%22)%3B+%7D%0A++S(const+S%26)+%7B+puts(%22Copy+construct%5Cn%22)%3B+%7D%0A++S(S%26%26)+%7B+puts(%22Move+construct%5Cn%22)%3B+%7D%0A++S%26+operator%3D(const+S%26)+%7B+puts(%22Copy+assign%5Cn%22)%3B+return+*this%3B+%7D%0A++S%26+operator%3D(S%26%26)+%7B+puts(%22Move+assign%5Cn%22)%3B+return+*this%3B+%7D%0A%7D%3B%0A%0AS+will_it_rvo()%0A%7B%0A++S+s%7B1%7D%3B%0A++s+%3D+S%7B2%7D%3B%0A++return+s%3B%0A%7D%0A%0Aint+main(int+argc,+char*+argv%5B%5D)%0A%7B%0A++++S+s+%3D+will_it_rvo()%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:63.0659767141009,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:/usr/bin/clang%2B%2B-6.0,filters:(b:'0',binary:'0',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',trim:'1'),lang:c%2B%2B,libs:!((name:bc,ver:master),(name:blz,ver:master)),options:'-O3+-std%3Dc%2B%2B17',source:1),l:'5',n:'0',o:'/usr/bin/clang%2B%2B-6.0+(Editor+%231,+Compiler+%231)+C%2B%2B',t:'0')),header:(),k:50,l:'4',m:19.721871049304678,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:1.8575209267199997,wrap:'1'),l:'5',n:'0',o:'%231+with+/usr/bin/clang%2B%2B-6.0',t:'0')),header:(),l:'4',m:80.27812895069533,n:'0',o:'',s:0,t:'0')),k:36.9340232858991,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

<aside class="notes">
<p>
Yep. Plain NRVO.
</p>

</aside>

</section>
<section id="slide-org9a6e310">
<h3 id="org9a6e310">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">S</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-org2fe74d5">
<h3 id="org2fe74d5">Will it RVO?</h3>
<p>
Yes. Identifiers are allowed to be parenthesized in the <code>return</code> expression.
</p>

<iframe width="1400px" height="600px" src="http://localhost:10240/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,lang:c%2B%2B,source:'%23include+%3Cstdio.h%3E%0A%0Astruct+Foo+%7B%7D%3B%0A%0Astruct+S%0A%7B%0A++S()+%7B+puts(%22Default+construct%5Cn%22)%3B+%7D%0A++S(Foo)+%7B+puts(%22Value+construct%5Cn%22)%3B+%7D%0A++explicit+S(int)+%7B+puts(%22Explicit+value+construct+(1)%5Cn%22)%3B+%7D%0A++explicit+S(int,+int)+%7B+puts(%22Explicit+value+construct+(2)%5Cn%22)%3B%7D%0A++~S()+%7B+puts(%22Destruct%5Cn%22)%3B+%7D%0A++S(const+S%26)+%7B+puts(%22Copy+construct%5Cn%22)%3B+%7D%0A++S(S%26%26)+%7B+puts(%22Move+construct%5Cn%22)%3B+%7D%0A++S%26+operator%3D(const+S%26)+%7B+puts(%22Copy+assign%5Cn%22)%3B+return+*this%3B+%7D%0A++S%26+operator%3D(S%26%26)+%7B+puts(%22Move+assign%5Cn%22)%3B+return+*this%3B+%7D%0A%7D%3B%0A%0AS+will_it_rvo()%0A%7B%0A++S+s%7B1%7D%3B%0A++return+(s)%3B%0A%7D%0A%0Aint+main(int+argc,+char*+argv%5B%5D)%0A%7B%0A++++S+s+%3D+will_it_rvo()%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:63.0659767141009,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:/usr/bin/clang%2B%2B-6.0,filters:(b:'0',binary:'0',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',trim:'1'),lang:c%2B%2B,libs:!((name:bc,ver:master),(name:blz,ver:master)),options:'-O3+-std%3Dc%2B%2B17',source:1),l:'5',n:'0',o:'/usr/bin/clang%2B%2B-6.0+(Editor+%231,+Compiler+%231)+C%2B%2B',t:'0')),header:(),k:50,l:'4',m:19.721871049304678,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:1.8575209267199997,wrap:'1'),l:'5',n:'0',o:'%231+with+/usr/bin/clang%2B%2B-6.0',t:'0')),header:(),l:'4',m:80.27812895069533,n:'0',o:'',s:0,t:'0')),k:36.9340232858991,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

<aside class="notes">
<p>
The standard explicitly allows this.
</p>

<p>
However&#x2026; there seems to be a bug in GCC where it doesn't RVO this. MSVC does
and Clang does.
</p>

<p>
Technically GCC is still adhering to the standard, because it's not required to
RVO. It does in C++11 mode, just not in C++14 or C++17 mode.
</p>

</aside>

</section>
<section id="slide-org8c1c3ce">
<h3 id="org8c1c3ce">Exhibit C</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #228b22;">long</span> <span style="color: #0000ff;">Time</span><span style="color: #707183;">()</span> <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">override</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">ts</span> = <span style="color: #008b8b;">blz</span>::get<span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">blz</span>::move<span style="color: #909183;">(</span><span style="color: #008b8b;">Base</span>::metrics_-&gt;GetDataPointAndTime<span style="color: #709870;">()</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">return</span> ts;
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
Superfluous (potentially dangerous?) call to <code>move</code>.
</p>

<p>
NRVO is not guaranteed in debug mode. Better:
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #228b22;">long</span> <span style="color: #0000ff;">Time</span><span style="color: #707183;">()</span> <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">override</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">blz</span>::get<span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">Base</span>::metrics_-&gt;GetDataPointAndTime<span style="color: #909183;">()</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Just an integral type here, so no big deal. But if it gets changed, or this
pattern gets copied&#x2026;
</p>

</aside>

</section>
<section id="slide-org49a1a82">
<h3 id="org49a1a82">Guidelines for RVO-friendliness</h3>
<ul>
<li>don't const-qualify returned value types</li>
<li>almost never return <code>move(x)</code></li>
<li>return temporaries where you can</li>
<li>when you return named things, avoid conditions</li>
<li>don't parenthesize return expressions</li>

</ul>

<aside class="notes">
<p>
First point does not affect RVO but is generally useless.
</p>

<p>
Returning <code>move(x)</code> is only for ref-qualified accessors.
</p>

<p>
URVO is easier for the compiler than NRVO. You are likely to get URVO in debug
builds.
</p>

<p>
Beware of the conditional operator.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org92b56ea">
<h2 id="org92b56ea">3. Putting stuff into a <code>vector</code></h2>
<p>
Should you use <code>push_back</code> or should you use <code>emplace_back</code>?
</p>

<p>
How should you use them?
</p>

</section>
<section id="slide-org9ed9250">
<h3 id="org9ed9250"><code>push_back</code> and <code>emplace_back</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">push_back</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">T</span>&amp; <span style="color: #a0522d;">x</span><span style="color: #707183;">)</span>;
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">push_back</span><span style="color: #707183;">(</span><span style="color: #228b22;">T</span>&amp;&amp; <span style="color: #a0522d;">x</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">reference</span> <span style="color: #0000ff;">emplace_back</span><span style="color: #707183;">(</span><span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Until C++17, <code>emplace_back</code> returns <code>void</code>.
</p>

<p>
<code>blz</code>'s emplace<sub>back</sub> returns a reference.
</p>

</aside>

</section>
<section id="slide-orgfed07d6">
<h3 id="orgfed07d6">Example 1</h3>
<p>
What's the difference here?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">string</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #228b22;">string</span> <span style="color: #a0522d;">s</span>;
<span style="color: #006400;">// </span><span style="color: #006400;">...</span>

v.push_back<span style="color: #707183;">(</span>move<span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
v.emplace_back<span style="color: #707183;">(</span>move<span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
<a href="http://b.n/vy">Compiler Explorer</a>
</p>

<aside class="notes">
<p>
There is no difference.
</p>

</aside>

</section>
<section id="slide-orgd47bd36">
<h3 id="orgd47bd36">Example 1.1</h3>
<p>
What's the difference here?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">string</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #228b22;">string</span> <span style="color: #a0522d;">s</span>;
<span style="color: #006400;">// </span><span style="color: #006400;">...</span>

v.push_back<span style="color: #707183;">(</span>move<span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
<span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">last_s</span> = v.emplace_back<span style="color: #707183;">(</span>move<span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
If we want to capture a reference to the thing that was pushed, we can use
<code>emplace_back</code>.
</p>

</aside>

</section>
<section id="slide-org8835874">
<h3 id="org8835874">Example 2</h3>
<p>
What's the difference here?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">string</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span> = <span style="color: #b22222;">"Hello"</span>;
<span style="color: #006400;">// </span><span style="color: #006400;">...</span>

v.push_back<span style="color: #707183;">(</span>s<span style="color: #707183;">)</span>;
v.emplace_back<span style="color: #707183;">(</span>s<span style="color: #707183;">)</span>;
</pre>
</div>

<p>
<a href="http://b.n/vz">Compiler Explorer</a>
</p>

<aside class="notes">
<p>
<code>push_back</code> constructs a temporary then moves it.
</p>

<p>
<code>emplace_back</code> constructs directly in place.
</p>

<p>
Remember, for string, a move is usually as expensive as a copy.
</p>

</aside>

</section>
<section id="slide-org49b1785">
<h3 id="org49b1785">Example 2.1</h3>
<p>
Default in-place construct.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">first default-construct in the vector</span>
<span style="color: #228b22;">S</span>&amp; <span style="color: #a0522d;">s</span> = v.emplace_back<span style="color: #707183;">()</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">now mutate s</span>
<span style="color: #006400;">// </span><span style="color: #006400;">...</span>
</pre>
</div>

<p>
<code>emplace_back</code> takes a parameter pack. Parameter packs can be empty.
</p>

<aside class="notes">
<p>
<code>emplace_back</code> is especially useful for this use case.
</p>

</aside>

</section>
<section id="slide-org0e47f0a">
<h3 id="org0e47f0a">Example 3</h3>
<p>
In-place construct with <code>explicit</code> constructor.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">recall: S has an explicit constructor from int</span>
<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">push_back can't do explicit construction</span>
v.push_back<span style="color: #707183;">(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;  <span style="color: #006400;">// </span><span style="color: #006400;">compiler error!</span>

<span style="color: #006400;">// </span><span style="color: #006400;">explicit construction is no problem for emplace_back</span>
<span style="color: #228b22;">S</span>&amp; <span style="color: #a0522d;">s</span> = v.emplace_back<span style="color: #707183;">(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
<code>emplace_back</code> does perfect forwarding. It can call <code>explicit</code> constructors.
</p>

<aside class="notes">
<p>
<code>emplace_back</code> is especially useful for this use case.
</p>

</aside>

</section>
<section id="slide-orga8ef0de">
<h3 id="orga8ef0de">Example: copy</h3>
<p>
Recall: our <code>S</code> class has a constructor from <code>Foo</code>, and an <code>explicit</code> constructor
from <code>int</code>.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #228b22;">array</span><span style="color: #707183;">&lt;</span>Foo, N<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">a</span> = <span style="color: #707183;">{</span> <span style="color: #0000ff;">...</span> <span style="color: #707183;">}</span>;
v.reserve<span style="color: #707183;">(</span>a.size<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>;

copy<span style="color: #707183;">(</span>a.cbegin<span style="color: #7388d6;">()</span>, a.cend<span style="color: #7388d6;">()</span>, back_inserter<span style="color: #7388d6;">(</span>v<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
What does <code>back_insert_iterator</code> do here?
</p>

<p>
<a href="http://b.n/va">Compiler Explorer</a>
</p>

<aside class="notes">
<p>
For each element, we construct an <code>S</code> (from the <code>Foo</code>) and then we move it into
the <code>vector</code>.
</p>

</aside>

</section>
<section id="slide-org7fdb298">
<h3 id="org7fdb298">Example: copy</h3>
<p>
What if we have an <code>array</code> of <code>int</code>?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #228b22;">array</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, N<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">a</span> = <span style="color: #707183;">{</span> <span style="color: #0000ff;">...</span> <span style="color: #707183;">}</span>;
v.reserve<span style="color: #707183;">(</span>a.size<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>;

copy<span style="color: #707183;">(</span>a.cbegin<span style="color: #7388d6;">()</span>, a.cend<span style="color: #7388d6;">()</span>, back_inserter<span style="color: #7388d6;">(</span>v<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p class="fragment (appear)">
Oops. The compiler is angry at us.
</p>

<aside class="notes">
<p>
<code>back_insert_iterator</code> calls <code>push_back</code> - it can't call our explicit
constructor.
</p>

</aside>

</section>
<section id="slide-org53759fd">
<h3 id="org53759fd">Example: copy?</h3>
<p>
OK, no problem, right?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #228b22;">array</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, N<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">a</span> = <span style="color: #707183;">{</span> <span style="color: #0000ff;">...</span> <span style="color: #707183;">}</span>;
v.reserve<span style="color: #707183;">(</span>a.size<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>;

transform<span style="color: #707183;">(</span>a.cbegin<span style="color: #7388d6;">()</span>, a.cend<span style="color: #7388d6;">()</span>, back_inserter<span style="color: #7388d6;">(</span>v<span style="color: #7388d6;">)</span>,
          <span style="color: #7388d6;">[]</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span> <span style="color: #a020f0;">return</span> S<span style="color: #909183;">{</span>i<span style="color: #909183;">}</span>; <span style="color: #7388d6;">}</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
<a href="http://b.n/vA">Compiler Explorer</a>
</p>

<aside class="notes">
<p>
For each element, we construct an <code>S</code> (from the <code>int</code>) and then we move it into
the <code>vector</code>. No extra cost over the first solution, because the <code>return</code> from the
lambda RVOs.
</p>

<p>
But what we actually want to do is construct in place.
</p>

</aside>

</section>
<section id="slide-orgbf884e1">
<h3 id="orgbf884e1"><code>back_emplacer</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Container</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">back_emplace_iterator</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">back_emplace_iterator</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">Container</span>&amp; <span style="color: #a0522d;">c</span><span style="color: #7388d6;">)</span> : c<span style="color: #7388d6;">(</span>&amp;c<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{}</span>

  <span style="color: #228b22;">back_emplace_iterator</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">++</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{</span> <span style="color: #a020f0;">return</span> *<span style="color: #a020f0;">this</span>; <span style="color: #7388d6;">}</span>
  <span style="color: #228b22;">back_emplace_iterator</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">*</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{</span> <span style="color: #a020f0;">return</span> *<span style="color: #a020f0;">this</span>; <span style="color: #7388d6;">}</span>

  <span style="color: #a020f0;">template</span> <span style="color: #7388d6;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Arg</span><span style="color: #7388d6;">&gt;</span>
  <span style="color: #228b22;">back_emplace_iterator</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">=</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">Arg</span>&amp;&amp; <span style="color: #a0522d;">arg</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
    c-&gt;emplace_back<span style="color: #909183;">(</span>forward<span style="color: #709870;">&lt;</span><span style="color: #228b22;">Arg</span><span style="color: #709870;">&gt;(</span><span style="color: #a0522d;">arg</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>;
    <span style="color: #a020f0;">return</span> *<span style="color: #a020f0;">this</span>;
  <span style="color: #7388d6;">}</span>

<span style="color: #a020f0;">private</span>:
  <span style="color: #228b22;">Container</span>* <span style="color: #a0522d;">c</span>;
<span style="color: #707183;">}</span>;
</pre>
</div>

</section>
<section id="slide-org5c6aa0e">
<h3 id="org5c6aa0e"><code>back_emplacer</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Container</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">back_emplacer</span><span style="color: #707183;">(</span><span style="color: #228b22;">Container</span>&amp; <span style="color: #a0522d;">c</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> back_emplace_iterator<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Container</span><span style="color: #7388d6;">&gt;(</span>c<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-orge97fb4f">
<h3 id="orge97fb4f"><code>back_emplacer</code></h3>
<p>
What if we have an <code>array</code> of <code>int</code>?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #228b22;">array</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, N<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">a</span> = <span style="color: #707183;">{</span> <span style="color: #0000ff;">...</span> <span style="color: #707183;">}</span>;
v.reserve<span style="color: #707183;">(</span>a.size<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>;

copy<span style="color: #707183;">(</span>a.cbegin<span style="color: #7388d6;">()</span>, a.cend<span style="color: #7388d6;">()</span>, back_emplacer<span style="color: #7388d6;">(</span>v<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
<a href="http://b.n/vB">Compiler Explorer</a>
</p>

</section>
<section id="slide-orgf94dd62">
<h3 id="orgf94dd62">Exhibit D</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">blz</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">blz</span>::string_view<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">tokens</span>;
<span style="color: #006400;">// </span><span style="color: #006400;">...</span>
<span style="color: #008b8b;">blz</span>::<span style="color: #228b22;">string_view</span> <span style="color: #a0522d;">token</span> = <span style="color: #006400;">/* </span><span style="color: #006400;">stuff */</span>;
tokens.emplace_back<span style="color: #707183;">(</span><span style="color: #008b8b;">blz</span>::move<span style="color: #7388d6;">(</span>token<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
A few things here:
</p>
<ul>
<li><code>string_view</code> is a pointer + length. recommendation is to pass by value;
<code>move</code> gains nothing anyway.</li>
<li><code>push_back</code> works with rvalues just fine - <code>emplace_back</code> gains nothing here.</li>
<li>if you want to, you should pass <code>/* stuff */</code> directly to <code>emplace_back</code>.</li>

</ul>

</aside>

</section>
<section id="slide-org5c100e4">
<h3 id="org5c100e4">Exhibit E</h3>
<div class="org-src-container">

<pre  class="src src-c++">context-&gt;m_result-&gt;m_headers.emplace_back<span style="color: #707183;">(</span>string<span style="color: #7388d6;">(</span>headerData, numBytes<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
A superfluous move! Better:
</p>

<div class="org-src-container">

<pre  class="src src-c++">context-&gt;m_result-&gt;m_headers.emplace_back<span style="color: #707183;">(</span>headerData, numBytes<span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Don't explicitly call a constructor with <code>emplace_back</code>.
</p>

<aside class="notes">
<p>
And remember, likely a superfluous copy if the string is small-buffer-optimized.
</p>

</aside>

</section>
<section id="slide-orgaca5744">
<h3 id="orgaca5744"><code>vector</code> of <code>pair</code> = <code>map</code></h3>
<p>
Sometimes, we use a  sorted <code>vector</code> of <code>pair</code> as a replacement for <code>map</code>.
</p>

<p>
What do you do if part of your <code>pair</code> has a multi-argument constructor?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Foo</span> <span style="color: #707183;">{</span> <span style="color: #0000ff;">Foo</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span>, <span style="color: #228b22;">string</span>, <span style="color: #228b22;">double</span><span style="color: #7388d6;">)</span>; <span style="color: #707183;">}</span>;

<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">pair</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span>, <span style="color: #228b22;">Foo</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">this is very common!</span>
v.push_back<span style="color: #707183;">(</span>make_pair<span style="color: #7388d6;">(</span><span style="color: #008b8b;">1</span>, Foo<span style="color: #909183;">{</span><span style="color: #008b8b;">42</span>, <span style="color: #b22222;">"hello"</span>, <span style="color: #008b8b;">3.14</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">this is no better</span>
v.emplace_back<span style="color: #707183;">(</span>make_pair<span style="color: #7388d6;">(</span><span style="color: #008b8b;">1</span>, Foo<span style="color: #909183;">{</span><span style="color: #008b8b;">42</span>, <span style="color: #b22222;">"hello"</span>, <span style="color: #008b8b;">3.14</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">how can we do better?</span>
v.emplace_back<span style="color: #707183;">(</span> <span style="color: #006400;">/* </span><span style="color: #006400;">what here? */</span> <span style="color: #707183;">)</span>;
</pre>
</div>

</section>
<section id="slide-org960cbe8">
<h3 id="org960cbe8"><code>piecewise_construct</code> to the rescue!</h3>
<p>
<code>pair</code> has a constructor that will handle your multi-argument constructor.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args1</span>, <span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args2</span><span style="color: #707183;">&gt;</span>
<span style="color: #0000ff;">pair</span><span style="color: #707183;">(</span><span style="color: #228b22;">piecewise_construct_t</span>,
     <span style="color: #228b22;">tuple</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Args1</span><span style="color: #0000ff;">...</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">first_args</span>,
     <span style="color: #228b22;">tuple</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Args2</span><span style="color: #0000ff;">...</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">second_args</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Types</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">tuple</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">Types</span>&amp;&amp;<span style="color: #0000ff;">...</span><span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">forward_as_tuple</span><span style="color: #707183;">(</span><span style="color: #228b22;">Types</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span> <span style="color: #a020f0;">noexcept</span>;
</pre>
</div>

<p>
<code>piecewise_construct_t</code> is a tag type.
</p>

</section>
<section id="slide-orgcc01386">
<h3 id="orgcc01386">Using <code>piecewise_construct</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Foo</span> <span style="color: #707183;">{</span> <span style="color: #0000ff;">Foo</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span>, <span style="color: #228b22;">string</span>, <span style="color: #228b22;">double</span><span style="color: #7388d6;">)</span>; <span style="color: #707183;">}</span>;

<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">pair</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span>, <span style="color: #228b22;">Foo</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">instead of this...</span>
v.push_back<span style="color: #707183;">(</span>make_pair<span style="color: #7388d6;">(</span><span style="color: #008b8b;">1</span>, Foo<span style="color: #909183;">{</span><span style="color: #008b8b;">42</span>, <span style="color: #b22222;">"hello"</span>, <span style="color: #008b8b;">3.14</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">...we can do this</span>
v.emplace_back<span style="color: #707183;">(</span>
  piecewise_construct,
  forward_as_tuple<span style="color: #7388d6;">(</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span>,                   <span style="color: #006400;">// </span><span style="color: #006400;">args to int "constructor"</span>
  forward_as_tuple<span style="color: #7388d6;">(</span><span style="color: #008b8b;">42</span>, <span style="color: #b22222;">"hello"</span>, <span style="color: #008b8b;">3.14</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span><span style="color: #88090B;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">args to Foo constructor</span>
</pre>
</div>
<p>
Perfect forwarding and in-place construction.
<a href="http://b.n/vC">Compiler Explorer</a>
</p>

</section>
<section id="slide-org1a5e58f">
<h3 id="org1a5e58f">Recommendations</h3>
<ul>
<li><code>push_back</code> is perfectly fine for rvalues</li>
<li>use <code>emplace_back</code> only when you need its powers
<ul>
<li>in-place construction (including nullary construction)</li>
<li>a reference to what's added (C++17)</li>

</ul></li>
<li>never pass an explicit temporary to <code>emplace_back</code></li>
<li>try to construct in place when you can</li>
<li>use <code>piecewise_construct</code> / <code>forward_as_tuple</code> to forward args through <code>pair</code></li>

</ul>

</section>
</section>
<section>
<section id="slide-org6820dde">
<h2 id="org6820dde">4. <code>initializer_list</code></h2>
<div class='vertspace2'></div>
<blockquote nil><p>&quot;I fear these stubborn lines lack power to move&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>Love's Labours Lost</em></div></blockquote>

</section>
<section id="slide-orgb242a40">
<h3 id="orgb242a40">What is <code>initializer_list</code>?</h3>
<p>
When you write:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span><span style="color: #707183;">{</span> <span style="color: #008b8b;">1</span>,<span style="color: #008b8b;">2</span>,<span style="color: #008b8b;">3</span> <span style="color: #707183;">}</span>;
</pre>
</div>
<p>
It's as if you wrote:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">a</span><span style="color: #707183;">[]</span> = <span style="color: #707183;">{</span> <span style="color: #008b8b;">1</span>,<span style="color: #008b8b;">2</span>,<span style="color: #008b8b;">3</span> <span style="color: #707183;">}</span>;
<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = initializer_list<span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;(</span>a, a+<span style="color: #008b8b;">3</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Notice: the backing array is <code>const</code>.
</p>

</aside>

</section>
<section id="slide-orgbc31b58">
<h3 id="orgbc31b58"><code>initializer_list</code> has <code>const</code> storage, 1</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #0000ff;">...</span> <span style="color: #a0522d;">Is</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">f</span><span style="color: #707183;">()</span> <span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #228b22;">initializer_list</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;{</span> Is<span style="color: #0000ff;">...</span> <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">foo</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>: <span style="color: #909183;">{</span><span style="color: #008b8b;">1</span>,<span style="color: #008b8b;">2</span>,<span style="color: #008b8b;">3</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span>
    cout &lt;&lt; i &lt;&lt; <span style="color: #b22222;">'</span><span style="color: #b22222; font-weight: bold;">\</span><span style="color: #b22222; font-weight: bold;">n</span><span style="color: #b22222;">'</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">bar</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>: f<span style="color: #909183;">&lt;</span><span style="color: #008b8b;">1</span>,<span style="color: #008b8b;">2</span>,<span style="color: #008b8b;">3</span><span style="color: #909183;">&gt;()</span><span style="color: #7388d6;">)</span>
    cout &lt;&lt; i &lt;&lt; <span style="color: #b22222;">'</span><span style="color: #b22222; font-weight: bold;">\</span><span style="color: #b22222; font-weight: bold;">n</span><span style="color: #b22222;">'</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
This is nasty, because it could work on one compiler and you wouldn't notice it.
</p>

<p>
The compiler probably won't warn for this.
</p>

<p>
<code>initializer_list</code> is a "view" type like <code>string_view</code> and doesn't own its
contents.
</p>

</aside>

</section>
<section id="slide-orgef67d64">
<h3 id="orgef67d64"><code>initializer_list</code> has <code>const</code> storage, 2</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">unique_ptr</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = <span style="color: #707183;">{</span> make_unique<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span>, make_unique<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">2</span><span style="color: #7388d6;">)</span> <span style="color: #707183;">}</span>;
</pre>
</div>
<p>
That also means <code>move</code> can't work.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">const</span> <span style="color: #228b22;">unique_ptr</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">a</span><span style="color: #707183;">[]</span> = <span style="color: #707183;">{</span> make_unique<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span>,
                              make_unique<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">2</span><span style="color: #7388d6;">)</span> <span style="color: #707183;">}</span>;
<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">unique_ptr</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> =
  initializer_list<span style="color: #707183;">&lt;</span><span style="color: #228b22;">unique_ptr</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;(</span>a, a+<span style="color: #008b8b;">3</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
You can't move from an <code>initializer_list</code> - this won't compile.
</p>

</aside>

</section>
<section id="slide-org0b598dc">
<h3 id="org0b598dc">But they're so convenient!</h3>
<p>
I'd much rather write:
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = <span style="color: #707183;">{</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>, S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">2</span><span style="color: #7388d6;">}</span>, S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">3</span><span style="color: #7388d6;">}</span> <span style="color: #707183;">}</span>;
</pre>
</div>
<p>
(3 constructs, 3 copies, 3 destructs)
</p>

<p>
Than:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
v.reserve<span style="color: #707183;">(</span><span style="color: #008b8b;">3</span><span style="color: #707183;">)</span>;
v.emplace_back<span style="color: #707183;">(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
v.emplace_back<span style="color: #707183;">(</span><span style="color: #008b8b;">2</span><span style="color: #707183;">)</span>;
v.emplace_back<span style="color: #707183;">(</span><span style="color: #008b8b;">3</span><span style="color: #707183;">)</span>;
</pre>
</div>
<p>
(3 constructs)
</p>

<aside class="notes">
<p>
The first version is probably OK for builtin primitive types.
</p>

<p>
It's way worse than the second version for types with more than trivial
construction.
</p>

</aside>

</section>
<section id="slide-org55f034c">
<h3 id="org55f034c">We can make it a little better&#x2026;</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = <span style="color: #707183;">{</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>, S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">2</span><span style="color: #7388d6;">}</span>, S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">3</span><span style="color: #7388d6;">}</span> <span style="color: #707183;">}</span>;
</pre>
</div>
<p>
(3 constructs, 3 copies, 3 destructs)
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #a0522d;">a</span><span style="color: #707183;">[</span><span style="color: #008b8b;">3</span><span style="color: #707183;">]</span> = <span style="color: #707183;">{</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>, S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">2</span><span style="color: #7388d6;">}</span>, S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">3</span><span style="color: #7388d6;">}</span> <span style="color: #707183;">}</span>;
<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">S</span><span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">v</span><span style="color: #707183;">(</span><span style="color: #228b22;">make_move_iterator</span><span style="color: #7388d6;">(</span><span style="color: #a0522d;">begin</span><span style="color: #909183;">(</span>a<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>,
            <span style="color: #228b22;">make_move_iterator</span><span style="color: #7388d6;">(</span><span style="color: #a0522d;">end</span><span style="color: #909183;">(</span>a<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>
<p>
(3 constructs, 3 moves, 3 destructs)
</p>

</section>
<section id="slide-org3662431">
<h3 id="org3662431">What we really need&#x2026;</h3>
<p>
Is an in-place constructor for <code>vector</code>. (For everything?)
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">vector</span><span style="color: #707183;">(</span><span style="color: #228b22;">in_place_t</span>, <span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Future (?) proposal by Simon Brand.
</p>

<p>
<a href="https://wg21.tartanllama.xyz/initializer_list">https://wg21.tartanllama.xyz/initializer_list</a>
</p>

</section>
<section id="slide-org1b94b5e">
<h3 id="org1b94b5e">Exhibit F</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">unordered_set</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">string</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">kKeywords</span> = <span style="color: #707183;">{</span>
        <span style="color: #b22222;">"alignas"</span>, <span style="color: #b22222;">"alignof"</span>, <span style="color: #b22222;">"and"</span>, <span style="color: #b22222;">"and_eq"</span>, <span style="color: #b22222;">"asm"</span>, <span style="color: #b22222;">"auto"</span>, <span style="color: #b22222;">"bitand"</span>, <span style="color: #b22222;">"bitor"</span>,
        <span style="color: #b22222;">"bool"</span>, <span style="color: #b22222;">"break"</span>, <span style="color: #b22222;">"case"</span>, <span style="color: #b22222;">"catch"</span>, <span style="color: #b22222;">"char"</span>, <span style="color: #b22222;">"class"</span>, <span style="color: #b22222;">"compl"</span>, <span style="color: #b22222;">"const"</span>,
        <span style="color: #b22222;">"constexpr"</span>, <span style="color: #b22222;">"const_cast"</span>, <span style="color: #b22222;">"continue"</span>, <span style="color: #b22222;">"decltype"</span>, <span style="color: #b22222;">"default"</span>, <span style="color: #b22222;">"delete"</span>, <span style="color: #b22222;">"do"</span>,
        <span style="color: #b22222;">"double"</span>, <span style="color: #b22222;">"dynamic_cast"</span>, <span style="color: #b22222;">"else"</span>, <span style="color: #b22222;">"enum"</span>, <span style="color: #b22222;">"explicit"</span>, <span style="color: #b22222;">"extern"</span>, <span style="color: #b22222;">"false"</span>,
        <span style="color: #b22222;">"float"</span>, <span style="color: #b22222;">"for"</span>, <span style="color: #b22222;">"friend"</span>, <span style="color: #b22222;">"goto"</span>, <span style="color: #b22222;">"if"</span>, <span style="color: #b22222;">"inline"</span>, <span style="color: #b22222;">"int"</span>, <span style="color: #b22222;">"long"</span>, <span style="color: #b22222;">"mutable"</span>,
        <span style="color: #b22222;">"namespace"</span>, <span style="color: #b22222;">"new"</span>, <span style="color: #b22222;">"noexcept"</span>, <span style="color: #b22222;">"not"</span>, <span style="color: #b22222;">"not_eq"</span>, <span style="color: #b22222;">"NULL"</span>, <span style="color: #b22222;">"operator"</span>, <span style="color: #b22222;">"or"</span>,
        <span style="color: #b22222;">"or_eq"</span>, <span style="color: #b22222;">"private"</span>, <span style="color: #b22222;">"protected"</span>, <span style="color: #b22222;">"public"</span>, <span style="color: #b22222;">"register"</span>, <span style="color: #b22222;">"reinterpret_cast"</span>,
        <span style="color: #b22222;">"return"</span>, <span style="color: #b22222;">"short"</span>, <span style="color: #b22222;">"signed"</span>, <span style="color: #b22222;">"sizeof"</span>, <span style="color: #b22222;">"static"</span>, <span style="color: #b22222;">"static_assert"</span>,
        <span style="color: #b22222;">"static_cast"</span>, <span style="color: #b22222;">"struct"</span>, <span style="color: #b22222;">"switch"</span>, <span style="color: #b22222;">"template"</span>, <span style="color: #b22222;">"this"</span>, <span style="color: #b22222;">"thread_local"</span>,
        <span style="color: #b22222;">"throw"</span>, <span style="color: #b22222;">"true"</span>, <span style="color: #b22222;">"try"</span>, <span style="color: #b22222;">"typedef"</span>, <span style="color: #b22222;">"typeid"</span>, <span style="color: #b22222;">"typename"</span>, <span style="color: #b22222;">"union"</span>, <span style="color: #b22222;">"unsigned"</span>,
        <span style="color: #b22222;">"using"</span>, <span style="color: #b22222;">"virtual"</span>, <span style="color: #b22222;">"void"</span>, <span style="color: #b22222;">"volatile"</span>, <span style="color: #b22222;">"wchar_t"</span>, <span style="color: #b22222;">"while"</span>, <span style="color: #b22222;">"xor"</span>, <span style="color: #b22222;">"xor_eq"</span>
<span style="color: #707183;">}</span>;
</pre>
</div>

</section>
<section id="slide-orgcf1a9f1">
<h3 id="orgcf1a9f1">Caveat Constructor</h3>
<p>
<code>string</code> is an interesting case here. We intuit/are taught:
</p>

<blockquote nil><p>Delay construction, allocation, etc. as late as possible.</p></blockquote>

<p>
But that might hurt us with <code>string</code>.
</p>

<p>
<a href="https://www.youtube.com/watch?v=sSlmmZMFsXQ">"Initializer Lists are Broken, Let's Fix Them"</a> &#x2013; Jason Turner, C++Now 2018
</p>

</section>
<section id="slide-orga374fe4">
<h3 id="orga374fe4">Surprising: <code>string</code> vs <code>const char*</code></h3>
<p>
SBO-strings
<a href="http://quick-bench.com/5dPSX8rx-R8_BIUYbYOp6DcqhAc">http://quick-bench.com/5dPSX8rx-R8_BIUYbYOp6DcqhAc</a>
</p>

<p>
Non SBO-strings 1:
<a href="http://quick-bench.com/mr6ZIQ8Jy0ghe1scBcTznYF2s5w">http://quick-bench.com/mr6ZIQ8Jy0ghe1scBcTznYF2s5w</a>
</p>

<p>
Non SBO-strings 2:
<a href="http://quick-bench.com/vzlG11LwZN-uMAKdK8X1XgRuaWs">http://quick-bench.com/vzlG11LwZN-uMAKdK8X1XgRuaWs</a>
</p>

<aside class="notes">
<p>
Two things mess with our mental model for strings. First - the small buffer
optimization. As previously mentioned, it makes copy the same cost as move.
</p>

<p>
Second - we often make strings from string literals. What's the type of a string
literal at declaration? Array of char. What's the type of it when you pass it to
a function? It decays to pointer to char.
</p>

<p>
So, if a string isn't small-buffer optimized, move is cheap. And if we're
constructing it from a string literal, the compiler knows the size. If we let it
decay to a char*, we're going to call strlen at some point.
</p>

</aside>

</section>
<section id="slide-org47ee7ad">
<h3 id="org47ee7ad">Recommendations</h3>
<ul>
<li>use <code>initializer_list</code> only for literal types</li>
<li>consider using <code>array</code> and manually moving</li>
<li>probably don't use <code>initializer_list</code> for anything that'll get run more than
once</li>
<li>wait for an <code>in_place_t</code> constructor on <code>vector</code> ?</li>
<li>watch Jason's talk</li>

</ul>

<aside class="notes">
<p>
I'm not sure what to recommend. Really the first point.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org4228553">
<h2 id="org4228553">5. Putting stuff into a <code>map</code></h2>
<p>
(or other associative container)
</p>

<p>
It's a bit complicated.
</p>

<aside class="notes">
<p>
When I say <code>map</code>, I mean <code>map</code>, <code>unordered_map</code>, <code>multimap</code>, <code>unordered_multimap</code>,
etc, and also the various flavours of <code>set</code>.
</p>

<p>
Note: the <code>value_type</code> of a <code>map</code> is <code>pair&lt;const K, V&gt;</code>. Confusingly, if we want
to refer to just the value in the map and not the key, it's called the
<code>mapped_type</code>.
</p>

</aside>

</section>
<section id="slide-org1d6ae8c">
<h3 id="org1d6ae8c"><code>initializer_list</code> with <code>map</code></h3>
<p>
It's perfectly possible to initialize a map with an <code>initializer_list</code>.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">recall S has an implicit constructor from Foo</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span> <span style="color: #707183;">{</span> <span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span>, Foo<span style="color: #909183;">{}</span><span style="color: #7388d6;">}</span> <span style="color: #707183;">}</span>; <span style="color: #006400;">// </span><span style="color: #006400;">how many constructs/copies/moves?</span>
</pre>
</div>

<p>
Use aggregate initialization with <code>pair</code>.
</p>

<p>
Is this good?
</p>

<aside class="notes">
<p>
Same as the <code>vector</code> init case basically. <code>initializer_list</code> still suffers from
the same problems.
</p>

<p>
You can't use explicit constructors easily here.
</p>

<p>
If you have explicit constructors you might need to explicitly call out the type
 of pair; it's not going to make a lot of difference.
</p>

</aside>

</section>
<section id="slide-org31d9bce">
<h3 id="org31d9bce">Alternative: templatery</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">call an N-ary function on each lot of N args passed in</span>
<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">N</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">F</span>, <span style="color: #a020f0;">typename</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Ts</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">for_each_n_args</span><span style="color: #707183;">(</span><span style="color: #228b22;">F</span>&amp;&amp; <span style="color: #a0522d;">f</span>, <span style="color: #228b22;">Ts</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">ts</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
for_each_n_args<span style="color: #707183;">&lt;</span><span style="color: #008b8b;">2</span><span style="color: #707183;">&gt;(</span>
  <span style="color: #7388d6;">[</span>&amp;<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #a020f0;">auto</span>&amp;&amp; <span style="color: #a0522d;">k</span>, <span style="color: #a020f0;">auto</span>&amp;&amp; <span style="color: #a0522d;">v</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
      m.emplace<span style="color: #909183;">(</span>forward<span style="color: #709870;">&lt;</span><span style="color: #a020f0;">decltype</span><span style="color: #907373;">(</span>k<span style="color: #907373;">)</span><span style="color: #709870;">&gt;(</span>k<span style="color: #709870;">)</span>,
                forward<span style="color: #709870;">&lt;</span><span style="color: #a020f0;">decltype</span><span style="color: #907373;">(</span>v<span style="color: #907373;">)</span><span style="color: #709870;">&gt;(</span>v<span style="color: #709870;">)</span><span style="color: #909183;">)</span>; <span style="color: #7388d6;">}</span>,
  <span style="color: #008b8b;">0</span>, <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">we can call explicit constructor</span>
</pre>
</div>

<p>
If you know the types, you can probably write the lambda in a less ugly way.
</p>

<aside class="notes">
<p>
<code>for_each_n_args</code> is a function template that perfectly-forwards its arguments
in groups of N to the function you give it.
</p>

<p>
It's in the Phoenix code base and it's useful for things like this.
</p>

<p>
Everything here gets constructed in place. No moves or copies.
</p>

<p>
This lambda deals with single-argument constructors for value. But&#x2026;
</p>

</aside>

</section>
<section id="slide-orgbab9dda">
<h3 id="orgbab9dda">Alternative: multi-arg templatery</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">call an N-ary function on each lot of N args passed in</span>
<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">N</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">F</span>, <span style="color: #a020f0;">typename</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Ts</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">for_each_n_args</span><span style="color: #707183;">(</span><span style="color: #228b22;">F</span>&amp;&amp; <span style="color: #a0522d;">f</span>, <span style="color: #228b22;">Ts</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">ts</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
for_each_n_args<span style="color: #707183;">&lt;</span><span style="color: #008b8b;">3</span><span style="color: #707183;">&gt;(</span>
  <span style="color: #7388d6;">[</span>&amp;<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #a020f0;">auto</span>&amp;&amp; <span style="color: #a0522d;">k</span>, <span style="color: #a020f0;">auto</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">v</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
      m.emplace<span style="color: #909183;">(</span>
        piecewise_construct,
        forward_as_tuple<span style="color: #709870;">(</span>forward<span style="color: #907373;">&lt;</span><span style="color: #a020f0;">decltype</span><span style="color: #6276ba;">(</span>k<span style="color: #6276ba;">)</span><span style="color: #907373;">&gt;(</span>k<span style="color: #907373;">)</span><span style="color: #709870;">)</span>,
        forward_as_tuple<span style="color: #709870;">(</span>forward<span style="color: #907373;">&lt;</span><span style="color: #a020f0;">decltype</span><span style="color: #6276ba;">(</span>v<span style="color: #6276ba;">)</span><span style="color: #907373;">&gt;(</span>v<span style="color: #907373;">)</span><span style="color: #0000ff;">...</span><span style="color: #709870;">)</span>; <span style="color: #88090B;">}</span>,
  <span style="color: #008b8b;">0</span>, <span style="color: #008b8b;">1</span>, <span style="color: #008b8b;">2</span><span style="color: #88090B;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">explicit multi-arg value constructor</span>
</pre>
</div>

<p>
Everything constructed in place.
</p>

<p>
<a href="http://b.n/vD">Compiler Explorer</a>
</p>

<aside class="notes">
<p>
Here we are calling S's two-arg constructor.
</p>

<p>
<code>for_each_n_args</code> also works with vector (including vector-of-pair) as an
alternative to <code>initializer_list</code>
</p>

<p>
There are some issues with calling <code>explicit</code> constructors&#x2026; it depends on the
compiler/library. It is supposed to work.
</p>

</aside>

</section>
<section id="slide-org0bdc2c2">
<h3 id="org0bdc2c2">Enough about initializing</h3>
<p>
How about putting things into an existing <code>map</code>?
</p>

</section>
<section id="slide-org4bd8e5a">
<h3 id="org4bd8e5a">The Easy Way: <code>operator[]</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">recall S has an implicit constructor from Foo</span>
<span style="color: #006400;">// </span><span style="color: #006400;">but an explicit constructor from int</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
m<span style="color: #707183;">[</span><span style="color: #008b8b;">0</span><span style="color: #707183;">]</span> = S<span style="color: #707183;">{</span><span style="color: #008b8b;">1</span><span style="color: #707183;">}</span>;
m<span style="color: #707183;">[</span><span style="color: #008b8b;">1</span><span style="color: #707183;">]</span> = Foo<span style="color: #707183;">{}</span>;
</pre>
</div>

<p>
How many constructs/moves/copies?
</p>

<aside class="notes">
<p>
These each have a construct, a default construct, and a move.
</p>

<p>
The advantage of this is that when you know the element is there already, it's
fine. You just get a lookup and an assign.
</p>

<p>
But if the element isn't there, you never get a copy construct or a move
construct here.
</p>

<p>
You always get an assign! Because you always get a default construct if the
element isn't there.
</p>

<p>
In fact this is the only function on map that requires your mapped<sub>type</sub> to have
a default constructor! It's fine to use objects without default constructors in
a map, if you never use this function. And that can be a significant thing.
</p>

</aside>

</section>
<section id="slide-org0c6733d">
<h3 id="org0c6733d">The Other Easy Way: <code>insert</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">recall S has an implicit constructor from Foo</span>
<span style="color: #006400;">// </span><span style="color: #006400;">but an explicit constructor from int</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">pair&lt;iterator,bool&gt; insert(value_type&amp;&amp; value);</span>

<span style="color: #006400;">// </span><span style="color: #006400;">template &lt;class T1, class T2&gt;</span>
<span style="color: #006400;">// </span><span style="color: #006400;">pair&lt;V1,V2&gt; make_pair(T1&amp;&amp; t, T2&amp;&amp; u);</span>

<span style="color: #006400;">// </span><span style="color: #006400;">alternatives:</span>
m.insert<span style="color: #707183;">(</span>make_pair<span style="color: #7388d6;">(</span><span style="color: #008b8b;">0</span>, S<span style="color: #909183;">{</span><span style="color: #008b8b;">1</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
m.insert<span style="color: #707183;">(</span>pair&lt;<span style="color: #228b22;">int</span>, <span style="color: #228b22;">S</span>&amp;&amp;&gt;<span style="color: #7388d6;">(</span><span style="color: #008b8b;">0</span>, S<span style="color: #909183;">{</span><span style="color: #008b8b;">1</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
m.insert<span style="color: #707183;">(</span>make_pair<span style="color: #7388d6;">(</span><span style="color: #008b8b;">0</span>, <span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
How many constructs/moves/copies?
</p>

<p>
<a href="http://b.n/vE">Compiler Explorer</a>
</p>

<aside class="notes">
<p>

</p>

<p>
The first line here creates an S, moves it into pair&lt;int, S&gt;, then moves the
pair into the map.
</p>

<p>
Remember that make<sub>pair</sub> deduces the type of its arguments. And V1 and V2 here
are the decayed types of T1 and T2.
</p>

<p>
The second line forces a pair of type &lt;int, S&amp;&amp;&gt;, so you get one move after the
initial construct.
</p>

<p>
The third line makes a pair&lt;int, int&gt; then uses that pair to construct a pair of
&lt;int, S&gt; in the map. This doesn't currently work with <code>blz</code>. I'll get to why in
a minute.
</p>

</aside>

</section>
<section id="slide-orgde00c5c">
<h3 id="orgde00c5c"><code>emplace</code></h3>
<p>
Enter the <i>wonderful C++11 panacea</i> that is move semantics.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">recall S has an implicit constructor from Foo</span>
<span style="color: #006400;">// </span><span style="color: #006400;">but an explicit constructor from int</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">template &lt;class... Args&gt;</span>
<span style="color: #006400;">// </span><span style="color: #006400;">pair&lt;iterator,bool&gt; emplace(Args&amp;&amp;... args);</span>

<span style="color: #006400;">// </span><span style="color: #006400;">this was 2 moves</span>
<span style="color: #006400;">// </span><span style="color: #006400;">m.insert(make_pair(0, S{1}));</span>

<span style="color: #006400;">// </span><span style="color: #006400;">much better, right?</span>
m.emplace<span style="color: #707183;">(</span>make_pair<span style="color: #7388d6;">(</span><span style="color: #008b8b;">0</span>, S<span style="color: #909183;">{</span><span style="color: #008b8b;">1</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
You guessed it&#x2026;
</p>

<aside class="notes">
<p>
Don't do this. It is <i>exactly</i> the same as <code>insert</code> here. Two moves.
</p>

</aside>

</section>
<section id="slide-org3a13535">
<h3 id="org3a13535"><code>emplace</code>, better usage</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">recall S has an implicit constructor from Foo</span>
<span style="color: #006400;">// </span><span style="color: #006400;">but an explicit constructor from int</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">template &lt;class... Args&gt;</span>
<span style="color: #006400;">// </span><span style="color: #006400;">pair&lt;iterator,bool&gt; emplace(Args&amp;&amp;... args);</span>

m.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">0</span>, <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">no moves, just a construct</span>
</pre>
</div>

<aside class="notes">
<p>
Again, the point of <code>emplace</code> is in-place construction.
</p>

<p>
It doesn't help you over <code>insert</code> if you just pass rvalues. <code>insert</code> works just
fine with rvalues.
</p>

</aside>

</section>
<section id="slide-org0f5d226">
<h3 id="org0f5d226"><code>emplace</code>: <code>blz</code> caveat</h3>
<p>
At the moment, <code>blz::map::emplace</code> cannot invoke <code>explicit</code> constructors.
</p>

<p>
(<code>blz::vector::emplace_back</code> can)
</p>

<aside class="notes">
<p>
This is a gnarly area of the STL: conditionally explicit constructors on <code>pair</code>.
</p>

<p>
There's an issue open on <code>blz</code> about it: if it's important to you, help with the
fix. It's been difficult to achieve cross-platform compiler support properly.
</p>

</aside>

</section>
<section id="slide-org97a6428">
<h3 id="org97a6428"><code>emplace</code> problem</h3>
<p>
What do we do when we want to default-construct the value?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
m.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">0</span><span style="color: #707183;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">default construct S please!</span>
</pre>
</div>

<p class="fragment (appear)">
<i>error 2665: <code>std::pair&lt;const _Kty,_Ty&gt;::pair</code>: none of the 2 overloads could
convert all the argument types</i>
</p>

<aside class="notes">
<p>
Here's a problem: how can we tell <code>emplace</code> to zero-arg construct the value when
we can't syntactically pass "zero arguments" in the place of an argument.
</p>

<p>
We don't want to default-construct an S explicitly here and move it in.
</p>

<p>
Remember the <code>value_type</code> of the <code>map</code> is a <code>pair</code> - that's what <code>emplace</code> is
trying to construct.
</p>

</aside>

</section>
<section id="slide-org06d641f">
<h3 id="org06d641f"><code>emplace</code> with zero-arg constructor</h3>
<p>
Our old friend <code>piecewise_construct</code> can help.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
m.emplace<span style="color: #707183;">(</span>piecewise_construct,
          forward_as_tuple<span style="color: #7388d6;">(</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">)</span>,
          forward_as_tuple<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">default construct S please!</span>
</pre>
</div>

<p>
Tuples are allowed to be empty!
</p>

<p>
Yes, we can also use this for more-than-one-arg constructors.
</p>

<aside class="notes">
<p>
Here's the piecewise constructor on <code>pair</code> again.
</p>

<p>
This also gets around the <code>blz</code> limitation on <code>explicit</code> constructors with
<code>emplace</code>. So there is a way to achieve optimality with <code>blz</code>.
</p>

</aside>

</section>
<section id="slide-org82404c1">
<h3 id="org82404c1">Exhibit G</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">explicit ClientIdRecord(</span>
<span style="color: #006400;">//  </span><span style="color: #006400;">const string&amp; clientId, const ProcessId&amp; clientProcess, const ProcessId&amp; romeoProcess);</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">Storage</span> = <span style="color: #228b22;">unordered_set</span><span style="color: #707183;">&lt;</span>ClientIdRecord<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">Storage</span> <span style="color: #a0522d;">m_storage</span>;
m_storage.emplace<span style="color: #707183;">(</span>inClientId, process, romeoProcess<span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Perfectly fine as far as <code>emplace</code> usage.
</p>

<p>
Then we want to change the <code>unordered_set</code> to an <code>unordered_map</code>.
</p>

<aside class="notes">
<p>
ClientIdRecord has a 3-argument constructor.
</p>

<p>
<code>inClientId</code> is a string
</p>

<p>
One in-place construct. This is fine.
</p>

</aside>

</section>
<section id="slide-orgef1948a">
<h3 id="orgef1948a">Exhibit G</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">explicit ClientIdRecord(</span>
<span style="color: #006400;">//  </span><span style="color: #006400;">const string&amp; clientId, const ProcessId&amp; clientProcess, const ProcessId&amp; romeoProcess);</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">Storage</span> = <span style="color: #228b22;">unordered_map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">string</span>, ClientIdRecord<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">Storage</span> <span style="color: #a0522d;">m_storage</span>;
m_storage.emplace<span style="color: #707183;">(</span>
  make_pair<span style="color: #7388d6;">(</span>inClientId,
            ClientIdRecord<span style="color: #909183;">(</span>inClientId, process, romeoProcess<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Is this optimal?
</p>

<aside class="notes">
<p>
2 extra moves here.
</p>

<p>
How do we do better?
</p>

</aside>

</section>
<section id="slide-org77792cc">
<h3 id="org77792cc">Exhibit G</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">Storage</span> = <span style="color: #228b22;">unordered_map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">string</span>, ClientIdRecord<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">Storage</span> <span style="color: #a0522d;">m_storage</span>;
m_storage.emplace<span style="color: #707183;">(</span>piecewise_construct,
                  forward_as_tuple<span style="color: #7388d6;">(</span>inClientId<span style="color: #7388d6;">)</span>,
                  forward_as_tuple<span style="color: #7388d6;">(</span>inClientId, process, romeoProcess<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Use <code>piecewise_construct</code> again.
</p>

</section>
<section id="slide-org806822f">
<h3 id="org806822f"><code>emplace</code> problem 2</h3>
<p>
What do you do if you want to <code>emplace</code> the result of a function call?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">get_S</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span> <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>; <span style="color: #707183;">}</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
m.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">0</span>, get_S<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
How can we avoid the move?
</p>

<p>
Is it possible to in-place construct here?
</p>

</section>
<section id="slide-orga8c7f21">
<h3 id="orga8c7f21">In-place construct a function call result</h3>
<p>
We can't avoid evaluating the function call before calling <code>emplace</code>.
</p>

<p>
But, we can control when the result of the function call becomes an <code>S</code>.
</p>

</section>
<section id="slide-org3f5a498">
<h3 id="org3f5a498">In-place construct a function call result</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">F</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">with_result_of_t</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">using</span> <span style="color: #228b22;">T</span> = <span style="color: #228b22;">result_of_t</span><span style="color: #7388d6;">&lt;</span>F<span style="color: #909183;">()</span><span style="color: #7388d6;">&gt;</span>;
  <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">with_result_of_t</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">F</span> <span style="color: #a0522d;">f</span><span style="color: #7388d6;">)</span> : f<span style="color: #7388d6;">(</span>move<span style="color: #909183;">(</span>f<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{}</span>
  <span style="color: #a020f0;">operator</span> <span style="color: #228b22;">T</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{</span> <span style="color: #a020f0;">return</span> f<span style="color: #909183;">()</span>; <span style="color: #7388d6;">}</span>

<span style="color: #a020f0;">private</span>:
  <span style="color: #228b22;">F</span> <span style="color: #a0522d;">f</span>;
<span style="color: #707183;">}</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">F</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">inline</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">with_result_of</span><span style="color: #707183;">(</span><span style="color: #228b22;">F</span>&amp;&amp; <span style="color: #a0522d;">f</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> with_result_of_t<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">F</span><span style="color: #7388d6;">&gt;(</span>forward<span style="color: #909183;">&lt;</span><span style="color: #228b22;">F</span><span style="color: #909183;">&gt;(</span>f<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Capture the function and call it only at the point that we want to convert the
result to an <code>S</code>.
</p>

<p>
<code>invoke_result_t</code> is C++17 - before that you can use <code>result_of_t</code>.
</p>

</aside>

</section>
<section id="slide-org1664adf">
<h3 id="org1664adf"><code>emplace</code> problem 2</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">get_S</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span> <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>; <span style="color: #707183;">}</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
m.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">0</span>, with_result_of<span style="color: #7388d6;">(</span><span style="color: #909183;">[]</span> <span style="color: #909183;">{</span> <span style="color: #a020f0;">return</span> get_S<span style="color: #709870;">()</span>; <span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">m.emplace(0, with_result_of(get_S));</span>
</pre>
</div>

<p>
Compilers are really good at optimizing single-use lambdas.
</p>

<p>
<a href="http://b.n/vF">Compiler Explorer</a>
</p>

<aside class="notes">
<p>
You would think the second line here would work just as well. But VC++
doesn't manage to elide the move.
</p>

</aside>

</section>
<section id="slide-org038bf50">
<h3 id="org038bf50">C++17: <code>insert_or_assign</code></h3>
<p>
Of course, <code>insert</code> / <code>emplace</code> and <code>operator[]</code> actually do different things.
</p>

<p>
What do you do if you want to insert, or assign if the element is already there?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">M</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">pair</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">iterator</span>, <span style="color: #228b22;">bool</span><span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">insert_or_assign</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">key_type</span>&amp; <span style="color: #a0522d;">k</span>, <span style="color: #228b22;">M</span>&amp;&amp; <span style="color: #a0522d;">obj</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">M</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">pair</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">iterator</span>, <span style="color: #228b22;">bool</span><span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">insert_or_assign</span><span style="color: #707183;">(</span><span style="color: #228b22;">key_type</span>&amp;&amp; <span style="color: #a0522d;">k</span>, <span style="color: #228b22;">M</span>&amp;&amp; <span style="color: #a0522d;">obj</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Introduced with C++17.
</p>

<aside class="notes">
<p>
<code>insert_or_assign</code> doesn't need default construction (unlike <code>operator[]</code>).
</p>

<p>
<code>insert_or_assign</code> was introduced with C++17. Can be written as a free function,
but difficult/impossible to make as efficient as map can as a member function.
</p>

</aside>

</section>
<section id="slide-org589c966">
<h3 id="org589c966">C++17: <code>insert_or_assign</code></h3>
<p>
Yet another slightly different interface&#x2026;
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
m.insert_or_assign<span style="color: #707183;">(</span><span style="color: #008b8b;">0</span>, Foo<span style="color: #7388d6;">{}</span><span style="color: #707183;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">implicit construction - fine</span>

<span style="color: #006400;">// </span><span style="color: #006400;">m.insert_or_assign(1, 1);  // explicit construction - error!</span>
m.insert_or_assign<span style="color: #707183;">(</span><span style="color: #008b8b;">1</span>, with_result_of<span style="color: #7388d6;">(</span><span style="color: #909183;">[]{</span> <span style="color: #a020f0;">return</span> S<span style="color: #709870;">{</span><span style="color: #008b8b;">1</span><span style="color: #709870;">}</span>; <span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">RVO</span>
</pre>
</div>

<aside class="notes">
<p>
Unfortunately there is no <code>emplace_or_assign</code>. (In the assign case presumably
could not avoid making a temporary to assign). But you can use the same
<code>with_result_of</code> technique with <code>insert_or_assign</code>.
</p>

</aside>

</section>
<section id="slide-orgad6e305">
<h3 id="orgad6e305">Exhibit H</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">K</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">V</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">typename</span> <span style="color: #008b8b;">LRUCache</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">K</span>, <span style="color: #228b22;">V</span><span style="color: #707183;">&gt;</span>::<span style="color: #228b22;">EntryPtr</span> <span style="color: #008b8b;">LRUCache</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">K</span>, <span style="color: #228b22;">V</span><span style="color: #707183;">&gt;</span>::<span style="color: #0000ff;">Insert</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">K</span>&amp; <span style="color: #a0522d;">key</span>, <span style="color: #228b22;">V</span> <span style="color: #a0522d;">value</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #006400;">// </span><span style="color: #006400;">Is the key already present?</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>m_entries.find<span style="color: #909183;">(</span>key<span style="color: #909183;">)</span> != m_entries.end<span style="color: #909183;">()</span><span style="color: #7388d6;">)</span> <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">nullptr</span>;

  <span style="color: #006400;">// </span><span style="color: #006400;">Is the cache full?</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>m_entries.size<span style="color: #909183;">()</span> == m_capacity<span style="color: #7388d6;">)</span> Evict<span style="color: #7388d6;">(</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span>;

  <span style="color: #006400;">// </span><span style="color: #006400;">Insert the new value.</span>
  <span style="color: #228b22;">EntryPtr</span> <span style="color: #a0522d;">e</span> = <span style="color: #008b8b;">blz</span>::make_shared<span style="color: #7388d6;">&lt;</span>Entry<span style="color: #7388d6;">&gt;(</span>key, <span style="color: #008b8b;">blz</span>::move<span style="color: #909183;">(</span>value<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
  Append<span style="color: #7388d6;">(</span>e.get<span style="color: #909183;">()</span><span style="color: #7388d6;">)</span>;
  m_entries<span style="color: #7388d6;">[</span>key<span style="color: #7388d6;">]</span> = e;

  <span style="color: #a020f0;">return</span> e;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Given everything we've learned, let's critique this code.
</p>

<p>
We can see that it's inserting a KV pair into a cache with a least-recently-used
eviction strategy. There is a map that owns a shared<sub>ptr</sub>, and that shared<sub>ptr</sub> is
also weakly-referenced from a deque (see Append call)?
</p>

<ul>
<li>use pass-by-value to simplify handling</li>
<li>use <code>make_shared</code></li>

<li>use <code>operator[]</code> - default construct shared<sub>ptr</sub> + assign</li>
<li>extra shared<sub>ptr</sub> ref</li>

</ul>

</aside>

</section>
<section id="slide-org287b0a4">
<h3 id="org287b0a4">Exhibit H</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">Insert the new value.</span>
<span style="color: #a020f0;">decltype</span><span style="color: #707183;">(</span>m_entries.begin<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">it</span>;
<span style="color: #008b8b;">blz</span>::tie<span style="color: #707183;">(</span>it, <span style="color: #008b8b;">blz</span>::ignore<span style="color: #707183;">)</span> =
  m_entries.emplace<span style="color: #707183;">(</span>key, <span style="color: #008b8b;">blz</span>::make_shared<span style="color: #7388d6;">&lt;</span>Entry<span style="color: #7388d6;">&gt;(</span>key, <span style="color: #008b8b;">blz</span>::move<span style="color: #909183;">(</span>value<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
Append<span style="color: #707183;">(</span>it-&gt;second.get<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">return</span> it-&gt;second;
</pre>
</div>

<aside class="notes">
<ul>
<li>m<sub>entries</sub> can still be any associative container (no loss of generality)</li>
<li>save 2 shared<sub>ptr</sub> reference updates (plus check on assign of the default-constructed one)</li>

</ul>

<p>
We could use with<sub>result</sub><sub>of</sub> here to construct the shared<sub>ptr</sub> directly in place.
</p>

</aside>

</section>
<section id="slide-org85ab547">
<h3 id="org85ab547">Recommendations</h3>
<p>
Yes, C++ is complicated.
</p>

<ul>
<li>Initialization: consider <code>for_each_n_args</code></li>
<li>You can use <code>insert</code> with <code>make_pair</code> and implicit construction
<ul>
<li>But don't use call-site explicit construction</li>

</ul></li>
<li>Use <code>emplace</code> but beware of explicit construction</li>
<li>Use <code>piecewise_construct</code> for other than single-arg construction</li>
<li>Try to avoid <code>operator[]</code></li>
<li>Adopt <code>insert_or_assign</code> when it's available</li>
<li>Consider <code>with_result_of</code></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgd8a1f13">
<h2 id="orgd8a1f13">6. Putting stuff into other things</h2>
<p>
Like <code>optional</code>, <code>variant</code>, <code>any</code>.
</p>

</section>
<section id="slide-orgf042995">
<h3 id="orgf042995"><code>optional</code> and friends</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">optional</span><span style="color: #707183;">(</span><span style="color: #228b22;">in_place_t</span>, <span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span>, <span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">variant</span><span style="color: #707183;">(</span><span style="color: #228b22;">in_place_type_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #7388d6;">&gt;</span>, <span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span>;
<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">I</span>, <span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">variant</span><span style="color: #707183;">(</span><span style="color: #228b22;">in_place_index_t</span><span style="color: #7388d6;">&lt;</span>I<span style="color: #7388d6;">&gt;</span>, <span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">ValueType</span>, <span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">any</span><span style="color: #707183;">(</span><span style="color: #228b22;">in_place_type_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">ValueType</span><span style="color: #7388d6;">&gt;</span>, <span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
All these new vocabulary types have constructors that take <code>in_place</code> tag
arguments. They work similarly to <code>piecewise_construct</code> but they're only
constructing one thing.
</p>

</aside>

</section>
<section id="slide-orgb9734c7">
<h3 id="orgb9734c7"><code>optional</code> construction</h3>
<p>
implicit constructor
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span> = Foo<span style="color: #707183;">{}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (naive method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span> = S<span style="color: #707183;">{</span><span style="color: #008b8b;">1</span><span style="color: #707183;">}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (in-place method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span><span style="color: #707183;">(</span>in_place, <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
In the first case, it's fine: just one in-place construct.
</p>

<p>
In the second case, we have an <code>explicit</code> constructor. So if we use this style,
we get a construct and a move.
</p>

<p>
The third case is the way to go for in-place construction. It can also be used
with an implicit constructor of course.
</p>

</aside>

</section>
<section id="slide-orgd5c8e52">
<h3 id="orgd5c8e52"><code>optional</code> assignment</h3>
<p>
implicit constructor
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span>;
opt = Foo<span style="color: #707183;">{}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (naive method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span>;
opt = S<span style="color: #707183;">{</span><span style="color: #008b8b;">1</span><span style="color: #707183;">}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (in-place method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span>;
opt.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Similar story here.
</p>

</aside>

</section>
<section id="slide-org366ca30">
<h3 id="org366ca30"><code>optional</code> recommendations</h3>
<ul>
<li>use the <code>in_place_t</code> constructor</li>
<li>use <code>=</code> for assignment, but avoid <code>explicit</code> construction</li>
<li>use <code>emplace</code> for assignment</li>

</ul>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span><span style="color: #707183;">(</span>in_place, <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
opt = Foo<span style="color: #707183;">{}</span>;
opt.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">2</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
You'll never go wrong with these.
</p>

</aside>

</section>
<section id="slide-org424d279">
<h3 id="org424d279"><code>variant</code> construction</h3>
<p>
implicit constructor
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = Foo<span style="color: #707183;">{}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (naive method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = S<span style="color: #707183;">{</span><span style="color: #008b8b;">1</span><span style="color: #707183;">}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (oops method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = <span style="color: #008b8b;">1</span>;
</pre>
</div>

<aside class="notes">
<p>
Similar story as <code>optional</code>.
</p>

<p>
But there is the potential for a bug with the <code>explicit</code> constructor. What makes
this somewhat likely is that it might be the case that someone makes a
constructor explicit later on.
</p>

</aside>

</section>
<section id="slide-org6911a49">
<h3 id="org6911a49"><code>variant</code> construction</h3>
<p>
Recommendation: use either of these two constructions.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">v</span><span style="color: #707183;">(</span><span style="color: #228b22;">in_place_type</span><span style="color: #7388d6;">&lt;</span>S<span style="color: #7388d6;">&gt;</span>, <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">v</span><span style="color: #707183;">(</span><span style="color: #228b22;">in_place_index</span><span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">&gt;</span>, <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
I would generally prefer the first except in cases where the same type occurs in
multiple places in the <code>variant</code>, which is relatively rarer.
</p>

</aside>

</section>
<section id="slide-orgac37f3d">
<h3 id="orgac37f3d"><code>variant</code> assignment</h3>
<p>
Similar story to construction.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;

v = Foo<span style="color: #707183;">{}</span>; <span style="color: #006400;">// </span><span style="color: #006400;">fine</span>
v = S<span style="color: #707183;">{</span><span style="color: #008b8b;">1</span><span style="color: #707183;">}</span>;  <span style="color: #006400;">// </span><span style="color: #006400;">constructs a temporary</span>
v = <span style="color: #008b8b;">1</span>;     <span style="color: #006400;">// </span><span style="color: #006400;">oops</span>
</pre>
</div>

</section>
<section id="slide-org35fc46f">
<h3 id="org35fc46f"><code>variant</code> danger!</h3>
<p>
Implicitly-typed <code>variant</code> construction/assignment can be dangerous.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">bool</span>, <span style="color: #228b22;">string</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = <span style="color: #b22222;">"Hello"</span>;
cout &lt;&lt; <span style="color: #b22222;">"index is "</span> &lt;&lt; v.index<span style="color: #707183;">()</span> &lt;&lt; <span style="color: #b22222;">'</span><span style="color: #b22222; font-weight: bold;">\</span><span style="color: #b22222; font-weight: bold;">n</span><span style="color: #b22222;">'</span>;
</pre>
</div>

<p>
What does this output?
</p>

<p>
<a href="https://godbolt.org/g/Ybkubf">Compiler Explorer</a>
</p>

<aside class="notes">
<p>
Avoid implicit type conversions. They're dangerous. The first possible one will apply.
</p>

</aside>

</section>
<section id="slide-org7ad72cd">
<h3 id="org7ad72cd">Safe, efficient <code>variant</code> assignment</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #006400;">// </span><span style="color: #006400;">template &lt;class T, class... Args&gt;</span>
<span style="color: #006400;">// </span><span style="color: #006400;">T&amp; emplace(Args&amp;&amp;... args);</span>
v.emplace<span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;  <span style="color: #006400;">// </span><span style="color: #006400;">S{1}</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #006400;">// </span><span style="color: #006400;">template &lt;size_t I, class... Args&gt;</span>
<span style="color: #006400;">// </span><span style="color: #006400;">variant_alternative_t&lt;I, variant&gt;&amp; emplace(Args&amp;&amp;... args);</span>
v.emplace<span style="color: #707183;">&lt;</span><span style="color: #008b8b;">1</span><span style="color: #707183;">&gt;(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;  <span style="color: #006400;">// </span><span style="color: #006400;">S{1}</span>
</pre>
</div>

</section>
<section id="slide-org1524c43">
<h3 id="org1524c43"><code>variant</code> recommendations</h3>
<ul>
<li>always be explicit about types</li>
<li>use <code>in_place_type</code> or <code>in_place_index</code> constructors</li>
<li>use <code>emplace&lt;T&gt;</code> or <code>emplace&lt;I&gt;</code></li>
<li>avoid <code>operator=</code> (except actual <code>variant</code>-to-<code>variant</code>)</li>

</ul>

<aside class="notes">
<p>
Obviously <code>operator=</code> is used implicitly by the compiler.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgb1f4237">
<h2 id="orgb1f4237">7. Final Guidelines and Recommendations</h2>
<p>
Think about copies and moves.
</p>

<p>
Moves aren't free, and may not be cheap.
</p>

<p>
Usually, in-place construction is preferable. And it is nearly always possible.
</p>

<p>
Know how RVO works, and check that the compiler is doing it when you think it is.
</p>

<p>
Beware <code>initializer_list</code>.
</p>

<p>
Feel free to ping me with any questions, any time.
</p>
</section>
</section>
</div>
</div>
<script src="../reveal.js/lib/js/head.min.js"></script>
<script src="../reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
overview: true,
width: 1600,
height: 900,
margin: 0.10,
minScale: 0.50,
maxScale: 2.50,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
