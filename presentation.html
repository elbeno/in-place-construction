<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Everyday Efficiency: In-place Construction</title>
<meta name="author" content="Ben Deane"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="../reveal.js/css/theme/blood.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h2>Everyday Efficiency:</h2><h2>In-place Construction</h2><div class='vertspace2'></div><blockquote nil><p>&quot;Make no collection of it: let him show<br>His skill is in the construction.&quot;</p><div></div><div class='author'>-- William Shakespeare, <em>Cymbeline</em></div></blockquote><div class='vertspace3'></div><h3>Ben Deane / <a href=\"http://twitter.com/ben_deane\">@ben_deane</a></h3><h4>September 19 2018</h4>
</section>
<script type="text/javascript" src="./rison.js"></script>
<script type="text/javascript" src="./presentation.js"></script>

<section>
<section id="slide-org181a57d">
<h2 id="org181a57d">Get Ready</h2>
<ol>
<li>What happens when we <code>move</code> something?</li>
<li>Copy elision (RVO)</li>
<li>Putting stuff into a <code>vector</code></li>
<li><code>initializer_list</code></li>
<li>Putting stuff into a <code>map</code></li>
<li>Putting stuff into other things</li>
<li>Final thoughts</li>

</ol>

<aside class="notes">
<p>
There will be a lot of code snippets in this talk.
</p>

<p>
I will be asking a lot of questions.
</p>

<p>
I'm assuming everyone is using C++14, although most things we talk about will
require no more than C++11. I'll mention a couple of C++17 features.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org2f6035b">
<h2 id="org2f6035b">Disclaimer</h2>
<p>
I'm going to critique some code in this talk.
</p>

<p>
If it's your code, please don't feel slighted.
</p>

<p>
I assure you that I write and have written plenty of suboptimal code.
</p>

<p>
Let's make code better together!
</p>

</section>
</section>
<section>
<section id="slide-orge8175db">
<h2 id="orge8175db">Preliminaries</h2>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #94BFF3;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #D01A4E;">cstdio</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">Arg</span> <span style="color: #2aa198;">{}</span>;

<span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">S</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #2aa198;">S</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Default construct"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>
  <span style="color: #2aa198;">S</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">Arg</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Value construct"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>
  <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">S</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Explicit value construct (1)"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>
  <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">S</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span>, <span style="color: #268bd2;">int</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Explicit value construct (2)"</span><span style="color: #94BFF3;">)</span>;<span style="color: #b58900;">}</span>
  ~<span style="color: #2aa198;">S</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Destruct"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>
  <span style="color: #2aa198;">S</span><span style="color: #b58900;">(</span><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">S</span>&amp;<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Copy construct"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>
  <span style="color: #2aa198;">S</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">S</span>&amp;&amp;<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Move construct"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>
  <span style="color: #268bd2;">S</span>&amp; <span style="color: #b58900; font-weight: bold;">operator</span><span style="color: #2aa198;">=</span><span style="color: #b58900;">(</span><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">S</span>&amp;<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Copy assign"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900; font-weight: bold;">return</span> *<span style="color: #b58900; font-weight: bold;">this</span>; <span style="color: #b58900;">}</span>
  <span style="color: #268bd2;">S</span>&amp; <span style="color: #b58900; font-weight: bold;">operator</span><span style="color: #2aa198;">=</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">S</span>&amp;&amp;<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Move assign"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900; font-weight: bold;">return</span> *<span style="color: #b58900; font-weight: bold;">this</span>; <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;

<span style="color: #268bd2;">int</span> <span style="color: #2aa198;">main</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<aside class="notes">
<p>
You're going to see a lot of this later in the talk, when we examine how various
snippets of code behave.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgbeef678">
<h2 id="orgbeef678">1. What happens when we <code>move</code> something?</h2>
<div class='vertspace2'></div>
<blockquote nil><p>&quot;Mov'd! In good time! Let him that mov'd you hither<br>remove you hence.&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>The Taming of the Shrew</em></div></blockquote>

</section>
<section id="slide-org618fc04">
<h3 id="org618fc04">A moved-from <code>vector</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v1</span> = <span style="color: #2aa198;">{</span><span style="color: #859900;">1</span>, <span style="color: #859900;">2</span>, <span style="color: #859900;">3</span>, <span style="color: #859900;">4</span>, <span style="color: #859900;">5</span><span style="color: #2aa198;">}</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v2</span> = <span style="color: #859900;">std</span>::move<span style="color: #2aa198;">(</span>v1<span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
What's in <code>v1</code> after the move?
</p>

<aside class="notes">
<p>
The standard says "valid but unspecified". We know that we're allowed to destroy
it, because for things to be otherwise would be a nonsense. <code>v1</code> <span class="underline">will</span> be
destroyed like any other C++ object when it goes out of scope.
</p>

<p>
Here's where we deviate from the standard. How is <code>vector</code> implemented,
basically? (pointer-to-buffer, size, capacity). On destruction, what must it do?
</p>

</aside>

</section>
<section id="slide-orged8fbc5">
<h3 id="orged8fbc5">A moved-from <code>vector</code></h3>
<p>
It must be destroyable.
</p>

<p>
What is sufficient? What is likely?
</p>
<ul>
<li>begin pointer is null?</li>
<li>size is zero?</li>
<li>capacity is zero?</li>

</ul>

</section>
<section id="slide-orgbeddaa6">
<h3 id="orgbeddaa6">Exhibit A</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">void</span> <span style="color: #859900;">WebSocketHandshakerImpl</span>::<span style="color: #2aa198;">ProcessServerHandshake</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">HttpMessage</span> <span style="color: #cb4b16;">message</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #5f127b;">// </span><span style="color: #5f127b;">some stuff...</span>

  m_result.extra = <span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>m_readBuffer<span style="color: #b58900;">)</span>;
  m_result.headers = <span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>message.headers<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
This code assumes that it's safe to do whatever comes later to a moved-from <code>vector</code>.
</p>

</section>
<section id="slide-orgee8ca31">
<h3 id="orgee8ca31">Now consider:</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s1</span> = <span style="color: #D01A4E;">"Greetings, planet"</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s2</span> = <span style="color: #859900;">std</span>::move<span style="color: #2aa198;">(</span>s1<span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
What's the moved-from state of <code>s1</code>?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s3</span> = <span style="color: #D01A4E;">"Hello, world"</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s4</span> = <span style="color: #859900;">std</span>::move<span style="color: #2aa198;">(</span>s3<span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
What's the moved-from state of <code>s3</code>?
</p>

<aside class="notes">
<p>
What is the state of s1 in the second case? Same as the vector case basically.
</p>

<p>
But the first example is small-string optimized. What happens when you move from
a small string? You have to copy.
</p>

<p>
What is the state of s1 in the first case? It happens that all major
implementations will set the size to zero on a move, even when in the small
string buffer. So it's actually ever so slightly <i>slower</i> than a copy.
</p>

<p>
If you're lucky, the optimizer can help you out and spot dead stores&#x2026;
</p>

<p>
Bloomberg's STL does not clear a moved-from SSO string.
</p>

</aside>

</section>
<section id="slide-orge7dfbc8">
<h3 id="orge7dfbc8">Observation</h3>
<p>
Moving from a <code>string</code> usually <i>isn't any faster</i> than copying from it.
</p>

<p>
(If you doubt this, ask yourself why the small string optimization exists in the
first place.)
</p>

<p>
Moves <i>only</i> matter for objects on the heap.
</p>

<p>
<a href="http://quick-bench.com/7zo0OLXgCyR3v_KwZKNIe5Z5Z64">http://quick-bench.com/7zo0OLXgCyR3v_KwZKNIe5Z5Z64</a>
</p>

<aside class="notes">
<p>
And as noted, it may be technically slower.
</p>

</aside>

</section>
<section id="slide-org6a038fb">
<h3 id="org6a038fb">Exhibit B</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">void</span> <span style="color: #859900;">Context</span>::<span style="color: #2aa198;">Trigger</span><span style="color: #2aa198;">(</span><span style="color: #5f127b;">/* </span><span style="color: #5f127b;">some args */</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #5f127b;">// </span><span style="color: #5f127b;">Make sure that it will trigger only once.</span>
  <span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">OnResponseCallback</span> <span style="color: #cb4b16;">cb</span> = <span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>m_responseCallback<span style="color: #b58900;">)</span>;

  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>cb<span style="color: #b58900;">)</span>
  <span style="color: #b58900;">{</span>
    cb<span style="color: #94BFF3;">(</span>errorCode, errorReason, payload, size, opaque<span style="color: #94BFF3;">)</span>;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
<p>
Is this comment telling the truth?
</p>

<aside class="notes">
<p>
Playing with fire. The comment is misleading. We're relying on implementation.
</p>

<p>
Function has a small buffer optimization just like string. There's no reason for
function to be null after a move.
</p>

<p>
Think back to the vector case now: what happens if the container is replaced
with a small-buffer optimizable container?
</p>

</aside>

</section>
<section id="slide-org28157fd">
<h3 id="org28157fd">Guideline (specific)</h3>
<p>
Don't assume things are empty after a <code>move</code>.
</p>

<p>
Use <code>exchange</code> to make sure. Assigning an empty object is a trivial price for
safety.
</p>

<div class="org-src-container">

<pre  class="src src-c++">m_result.extra = <span style="color: #859900;">std</span>::exchange<span style="color: #2aa198;">(</span>m_readBuffer, <span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">OnResponseCallback</span> <span style="color: #cb4b16;">cb</span> = <span style="color: #859900;">std</span>::exchange<span style="color: #2aa198;">(</span>m_responseCallback, <span style="color: #859900;">nullptr</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
Make your code safe for future small-buffer optimizations.
</p>

</section>
<section id="slide-org5ad6689">
<h3 id="org5ad6689">Guideline (more general)</h3>
<p>
If you didn't write the move constructor/operator yourself, after a <code>move</code>, you
may assume:
</p>

<ul>
<li>the object is destroyable</li>
<li>the object is (re-)assignable</li>

</ul>

<p>
<i>NOTHING ELSE</i>
</p>

<p>
Note: This is a stronger constraint than what the standard says.
</p>

<aside class="notes">
<p>
[defns.valid] "the object's invariants are met and operations on the object
behave as specified for its type"
</p>

<p>
The standard says you can call any function without preconditions.
</p>

<p>
But I'm not saying anything that, I'm just saying something <i>more</i> constrained,
and safer.
</p>

</aside>

</section>
<section id="slide-org7ba7d95">
<h3 id="org7ba7d95">Let's look at this again</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">void</span> <span style="color: #859900;">WebSocketHandshakerImpl</span>::<span style="color: #2aa198;">ProcessServerHandshake</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">HttpMessage</span> <span style="color: #cb4b16;">message</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #5f127b;">// </span><span style="color: #5f127b;">some stuff...</span>

  <span style="color: #5f127b;">// </span><span style="color: #5f127b;">which would be right here? this?</span>
  m_result.headers = <span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>message.headers<span style="color: #b58900;">)</span>;

  <span style="color: #5f127b;">// </span><span style="color: #5f127b;">or this?</span>
  m_result.headers = <span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>message<span style="color: #b58900;">)</span>.headers;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<aside class="notes">
<p>
The first option is saying a much stronger thing. The result of <code>move</code> is always
an rvalue reference. That's literally all <code>move</code> does: a cast to an rvalue
reference.
</p>

<p>
The second one is using C++ member access rules to infer the rvalue-ness of the
member. That's fine. We still get the rvalue.
</p>

<p>
The first one is saying "this is definitely an rvalue - trust me!".
</p>

<p>
The second is saying "hey, this is an rvalue, unless something else prevents it".
</p>

<p>
So what would "prevent it"?
</p>

</aside>

</section>
<section id="slide-orgad63744">
<h3 id="orgad63744">There may be trouble ahead</h3>
<p>
Let's say we want always want pretty much the same headers for all requests.
</p>

<p>
What if we decided to change this&#x2026;
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">HttpMessage</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">requestLine</span>;
  <span style="color: #268bd2;">Headers</span> <span style="color: #cb4b16;">headers</span>;
<span style="color: #2aa198;">}</span>;
</pre>
</div>
<p>
&#x2026;to this?
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">HttpMessage</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">requestLine</span>;
  <span style="color: #268bd2;">Headers</span>&amp; <span style="color: #cb4b16;">headers</span>;
<span style="color: #2aa198;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
What happens when we change <code>Header</code> to a reference?
</p>

<p>
The HttpMessage itself can be an rvalue, but what it's referencing isn't.
</p>

</aside>

</section>
<section id="slide-orgba9be44">
<h3 id="orgba9be44">Guideline</h3>
<p>
Use <code>std::move(obj).member</code> rather than <code>std::move(obj.member)</code>
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #5f127b;">// </span><span style="color: #5f127b;">always safe, non-reference member is still an rvalue</span>
<span style="color: #b58900; font-weight: bold;">auto</span> <span style="color: #cb4b16;">x</span> = <span style="color: #859900;">std</span>::move<span style="color: #2aa198;">(</span>obj<span style="color: #2aa198;">)</span>.member;

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">could erroneously move from an lvalue-ref!</span>
<span style="color: #b58900; font-weight: bold;">auto</span> <span style="color: #cb4b16;">x</span> = <span style="color: #859900;">std</span>::move<span style="color: #2aa198;">(</span>obj.member<span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
If we cast obj to an rvalue-ref, its member will also (usually) be an rvalue
ref, no problem. We aren't losing anything and we're gaining safety.
</p>

</aside>

</section>
<section id="slide-orgab0b5f9">
<h3 id="orgab0b5f9"><code>move</code> safety guidelines</h3>
<ul>
<li>after <code>std::move</code>, destroy or assign <i>only</i></li>
<li>use <code>std::exchange</code> to move-and-clear</li>
<li>use <code>std::move(obj).member</code>, not <code>std::move(obj.member)</code></li>

</ul>

<aside class="notes">
<p>
The last two points here are useful a lot of the time for writing move
constructors. You're going to be working in terms of the subobjects.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org9d6cc20">
<h2 id="org9d6cc20">2. Copy Elision</h2>
<div class='vertspace2'></div>
<blockquote nil><p>&quot;If you will, lead these graces to the grave<br>And leave the world no copy.&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>Twelfth Night, or What You Will</em></div></blockquote>

</section>
<section id="slide-orgc4ac4b0">
<h3 id="orgc4ac4b0">Copy Elision, aka RVO</h3>
<p>
What is the return value optimization?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">string</span> <span style="color: #2aa198;">bar</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">a</span><span style="color: #b58900;">{</span><span style="color: #D01A4E;">"Hi"</span><span style="color: #b58900;">}</span>;
  <span style="color: #268bd2;">int</span> <span style="color: #cb4b16;">b</span> = <span style="color: #859900;">42</span>;
  <span style="color: #5f127b;">// </span><span style="color: #5f127b;">...</span>
  <span style="color: #b58900; font-weight: bold;">return</span> a;
<span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">void</span> <span style="color: #2aa198;">foo</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s</span><span style="color: #b58900;">{</span>bar<span style="color: #94BFF3;">()</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<aside class="notes">
<p>
The caller sets aside space in its own stack frame for the result of the
function, and the callee constructs the result directly in that space.
</p>

<p>
bar() has two local variables.
</p>

<p>
when foo() calls bar() it "passes" the address of the stack variable s.
</p>

</aside>

</section>
<section id="slide-org9d460fa">
<h3 id="org9d460fa">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org3d08eea">
<h3 id="org3d08eea">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org8da3a3d">
<h3 id="org8da3a3d">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo3.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orgf28d97e">
<h3 id="orgf28d97e">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo4.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orgde3c350">
<h3 id="orgde3c350">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo5.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org209b9b0">
<h3 id="org209b9b0">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org4924133">
<h3 id="org4924133">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org2bf344b">
<h3 id="org2bf344b">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo3.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org1424cb5">
<h3 id="org1424cb5">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo4.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org2146103">
<h3 id="org2146103">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo5.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orga2fb603">
<h3 id="orga2fb603">When can RVO not apply?</h3>
<p>
RVO Rules: what is returned has to be either:
</p>

<ul>
<li>a temporary (prvalue)</li>
<li>the name of a stack variable</li>

</ul>

</section>
<section id="slide-org9f66757">
<h3 id="org9f66757">When can RVO not apply?</h3>
<p>
RVO Ability: sometimes, the callee <i>can't</i> construct the object in-place.
</p>

<ul>
<li>if there is no opportunity to</li>
<li>if it's not of the right type</li>
<li>if the callee doesn't know enough</li>

</ul>

<aside class="notes">
<p>
Function arguments that are passed to you already-constructed can't be RVOed on
return. But you can move them.
</p>

<p>
You have to know at construction time that you're going to be returning that
variable in order to RVO it.
</p>

</aside>

</section>
<section id="slide-org432efc1">
<h3 id="org432efc1">No RVO because no opportunity</h3>
<p>
You can't RVO a variable if you didn't get the chance to construct it in the
first place.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #2aa198;">sad_function</span><span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  s += <span style="color: #D01A4E;">"No RVO for you!"</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> s;
<span style="color: #2aa198;">}</span>
</pre>
</div>
<p>
But the compiler will still move it. (Since C++11)
</p>

<aside class="notes">
<p>
C++11 mandates that if you can't do the RVO, you must try to move and only copy
as a last resort.
</p>

</aside>

</section>
<section id="slide-org72e6b41">
<h3 id="org72e6b41">No RVO because wrong type, 1</h3>
<p>
An rvalue-ref is not the same type.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #2aa198;">sad_function</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s</span> = <span style="color: #D01A4E;">"No RVO for you!"</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> <span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
<p>
Don't <code>return std::move(x)</code> in most cases - you will get a move when you didn't need anything!
</p>

<aside class="notes">
<p>
There are legitimate cases for returning an rvalue reference.
</p>

<p>
One of the few times when <code>return std::move(x)</code> is proper is when you're returning a
member variable out of a rvalue-ref-qualified member function.
</p>

</aside>

</section>
<section id="slide-org6fc26cd">
<h3 id="org6fc26cd">No RVO because wrong type, 2</h3>
<p>
Factory functions can't RVO.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">Base</span> <span style="color: #2aa198;">{</span> <span style="color: #2aa198;">...</span> <span style="color: #2aa198;">}</span>;
<span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">Derived</span> : <span style="color: #268bd2;">Base</span> <span style="color: #2aa198;">{</span> <span style="color: #2aa198;">...</span> <span style="color: #2aa198;">}</span>;

<span style="color: #859900;">std</span>::<span style="color: #268bd2;">shared_ptr</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">Base</span><span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">factory</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> <span style="color: #859900;">std</span>::make_shared<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">Derived</span><span style="color: #b58900;">&gt;()</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
<p>
But will still move.
</p>

<aside class="notes">
<p>
This is also true of any types that are inter-convertible.
e.g. returning a pair when the function returns a tuple, or something like that.
</p>

</aside>

</section>
<section id="slide-orgb1b8f66">
<h3 id="orgb1b8f66">No RVO because not enough info</h3>
<p>
It has to be decidable at construction time.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #2aa198;">undecided_function</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">happy</span> = <span style="color: #D01A4E;">"Hooray"</span>;
  <span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">sad</span> = <span style="color: #D01A4E;">"Boo hoo"</span>;

  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>getHappiness<span style="color: #94BFF3;">()</span> &gt; <span style="color: #859900;">0.5</span><span style="color: #b58900;">)</span>
    <span style="color: #b58900; font-weight: bold;">return</span> happy;
  <span style="color: #b58900; font-weight: bold;">else</span>
    <span style="color: #b58900; font-weight: bold;">return</span> sad;
<span style="color: #2aa198;">}</span>

</pre>
</div>
<p>
Again, return value will still be moved.
</p>

</section>
<section id="slide-orgc59c796">
<h3 id="orgc59c796">Why is RVO important?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string, <span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span>;

<span style="color: #268bd2;">M</span> <span style="color: #2aa198;">build_map</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
  m.insert<span style="color: #b58900;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Jenny"</span>, <span style="color: #859900;">8675309</span><span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> m;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<aside class="notes">
<p>
RVO is really important for performance. It's probably the single most important
optimization compilers make. Hence why it's been around for decades, even
without a standard.
</p>

<p>
If we accidentally inhibit RVO, we might also inhibit <code>move</code>. We might get a
copy.
</p>

<p>
<code>move</code> isn't necessarily cheap. Microsoft's node-based containers allocate in
their move constructors because they use sentinel nodes.
</p>

</aside>

</section>
<section id="slide-org0a4eb9d">
<h3 id="org0a4eb9d">Quiz time</h3>
<p>
Wake up!
</p>

<p>
And tell me if the upcoming code snippets will activate RVO.
</p>

</section>
<section id="slide-orga61a82c">
<h3 id="orga61a82c">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes.
</p>

<aside class="notes">
<p>
Yes. You're allowed to cv-qualify return types and RVO still works.
</p>

<p>
But don't do this. The compiler ignores const-qualified builtin types anyway.
</p>

</aside>

</section>
<section id="slide-orgc2864c9">
<h3 id="orgc2864c9">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span>
    <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
  <span style="color: #b58900; font-weight: bold;">else</span>
    <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes. Even in debug builds.
</p>

<aside class="notes">
<p>
Yes. This is URVO, and works pretty reliably even in debug builds.
</p>

</aside>

</section>
<section id="slide-orgc74251c">
<h3 id="orgc74251c">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span>, <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span>
    s = S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> s;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
No (no opportunity).
</p>

<aside class="notes">
<p>
No - can't RVO a function parameter. It will move though.
</p>

</aside>

</section>
<section id="slide-org7de600d">
<h3 id="org7de600d">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">get_S</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>; <span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span>
    <span style="color: #b58900; font-weight: bold;">return</span> get_S<span style="color: #b58900;">()</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes (can elide multiple copies).
</p>

<aside class="notes">
<p>
Yes. This RVOs.
RVO is allowed to elide multiple copies down the callstack.
</p>

</aside>

</section>
<section id="slide-org3db2d72">
<h3 id="org3db2d72">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span>
  <span style="color: #b58900;">{</span>
    <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span><span style="color: #94BFF3;">{</span><span style="color: #859900;">1</span><span style="color: #94BFF3;">}</span>;
    <span style="color: #b58900; font-weight: bold;">return</span> s;
  <span style="color: #b58900;">}</span>
  <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes (Clang), no (MSVC/GCC).
</p>

<aside class="notes">
<p>
There's nothing stopping it&#x2026; but only Clang successfully RVO's this.
</p>

</aside>

</section>
<section id="slide-orga49ea1e">
<h3 id="orga49ea1e">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span><span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span>
    <span style="color: #b58900; font-weight: bold;">return</span> s;
  <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
No. Possibly in future?
</p>

<aside class="notes">
<p>
We hoisted the S out of the condition.
</p>

<p>
No RVO here (a sufficiently smart compiler might be able to&#x2026;)
</p>

<p>
It still moves.
</p>

</aside>

</section>
<section id="slide-orgbb43313">
<h3 id="orgbb43313">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span><span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> b ? s : S<span style="color: #b58900;">{</span><span style="color: #859900;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
No. (Against the rules.)
</p>

<aside class="notes">
<p>
No RVO. We're not naming a variable.
Will it still move? No.
</p>

<p>
We're not naming a variable. And it's not a prvalue - the conditional operator
produces an lvalue reference here. We have to copy.
</p>

<p>
This is perhaps a semi-common pattern that defeats RVO!
</p>

</aside>

</section>
<section id="slide-orge83c9f8">
<h3 id="orge83c9f8">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">get_S</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>; <span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> b ? get_S<span style="color: #b58900;">()</span> : S<span style="color: #b58900;">{</span><span style="color: #859900;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes. (Returning temporary.)
</p>

<aside class="notes">
<p>
This RVOs. This time the conditional operator produces a prvalue because both of
its operands are prvalues.
</p>

</aside>

</section>
<section id="slide-org371ef32">
<h3 id="org371ef32">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span><span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
  s = S<span style="color: #b58900;">{</span><span style="color: #859900;">2</span><span style="color: #b58900;">}</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> s;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes.
</p>

<aside class="notes">
<p>
Yep. Plain NRVO.
</p>

</aside>

</section>
<section id="slide-org2fcff51">
<h3 id="org2fcff51">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span><span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> <span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes.
</p>
<p class="fragment (appear)">
<a href="http://eel.is/c++draft/class.copy.elision#3.1" class="fragment (appear)">class.copy.elision &sect; 3.1</a>
</p>

<aside class="notes">
<p>
The standard explicitly allows this &#x2013; (possibly parenthesized) <i>id-expression</i>.
</p>

<p>
However&#x2026; there seems to be a bug in GCC where it doesn't RVO this. MSVC does
and Clang does.
</p>

<p>
Technically GCC is still adhering to the standard, because it's not required to
RVO. It does in C++11 mode, just not in C++14 or C++17 mode.
</p>

</aside>

</section>
<section id="slide-orgaafe2af">
<h3 id="orgaafe2af">Exhibit C</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">unsigned</span> <span style="color: #268bd2;">long</span> <span style="color: #268bd2;">long</span> <span style="color: #2aa198;">Time</span><span style="color: #2aa198;">()</span> <span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #b58900; font-weight: bold;">override</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">auto</span> <span style="color: #cb4b16;">ts</span> = <span style="color: #859900;">std</span>::get<span style="color: #b58900;">&lt;</span><span style="color: #859900;">1</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">std</span>::move<span style="color: #94BFF3;">(</span><span style="color: #859900;">Base</span>::metrics_-&gt;GetDataPointAndTime<span style="color: #dc322f;">()</span><span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> ts;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
Superfluous (potentially dangerous?) call to <code>std::move</code>.
</p>

<p>
NRVO is not guaranteed in debug mode. Better:
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">unsigned</span> <span style="color: #268bd2;">long</span> <span style="color: #268bd2;">long</span> <span style="color: #2aa198;">Time</span><span style="color: #2aa198;">()</span> <span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #b58900; font-weight: bold;">override</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> <span style="color: #859900;">std</span>::get<span style="color: #b58900;">&lt;</span><span style="color: #859900;">1</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">Base</span>::metrics_-&gt;GetDataPointAndTime<span style="color: #94BFF3;">()</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Just an integral type here, so no big deal. But if it gets changed, or this
pattern gets copied&#x2026;
</p>

</aside>

</section>
<section id="slide-org594ea0f">
<h3 id="org594ea0f">Guidelines for RVO-friendliness</h3>
<ul>
<li>don't const-qualify returned value types</li>
<li>almost never return <code>std::move(x)</code></li>
<li>return temporaries where you can</li>
<li>when you return named things, avoid conditions</li>
<li>don't parenthesize return expressions</li>

</ul>

<aside class="notes">
<p>
First point does not affect RVO but is generally useless.
</p>

<p>
Returning <code>std::move(x)</code> is only for ref-qualified accessors.
</p>

<p>
URVO is easier for the compiler than NRVO. You are likely to get URVO in debug
builds.
</p>

<p>
Beware of the conditional operator.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org44833c7">
<h2 id="org44833c7">3. Putting stuff into a <code>vector</code></h2>
<p>
Should you use <code>push_back</code> or should you use <code>emplace_back</code>?
</p>

<p>
How should you use them?
</p>

<div class='vertspace2'></div>
<blockquote nil><p>&quot;Didst thou not say, when I did push thee back --<br>Which was when I perceived thee -- that thou camest<br>From good descending?&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>Pericles</em></div></blockquote>

</section>
<section id="slide-org6725aad">
<h3 id="org6725aad"><code>push_back</code> and <code>emplace_back</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">void</span> <span style="color: #2aa198;">push_back</span><span style="color: #2aa198;">(</span><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">T</span>&amp; <span style="color: #cb4b16;">x</span><span style="color: #2aa198;">)</span>;
<span style="color: #268bd2;">void</span> <span style="color: #2aa198;">push_back</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">T</span>&amp;&amp; <span style="color: #cb4b16;">x</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">reference</span> <span style="color: #2aa198;">emplace_back</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">Args</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Until C++17, <code>emplace_back</code> returns <code>void</code>.
</p>

</aside>

</section>
<section id="slide-orgcfd4526">
<h3 id="orgcfd4526">Example 1</h3>
<p>
What's the difference here?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s</span>;
<span style="color: #5f127b;">// </span><span style="color: #5f127b;">...</span>

v.push_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
There is no difference.
</p>

</aside>

</section>
<section id="slide-orgb2e2329">
<h3 id="orgb2e2329">Example 1.1</h3>
<p>
What's the difference here?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s</span>;

v.push_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span>&amp; <span style="color: #cb4b16;">last_s</span> = v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
If we want to capture a reference to the thing that was pushed, we can use
<code>emplace_back</code>.
</p>

</aside>

</section>
<section id="slide-org8315ee9">
<h3 id="org8315ee9">Example 2</h3>
<p>
What's the difference here?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">char</span>* <span style="color: #cb4b16;">s</span> = <span style="color: #D01A4E;">"Hello"</span>;

v.push_back<span style="color: #2aa198;">(</span>s<span style="color: #2aa198;">)</span>;
v.emplace_back<span style="color: #2aa198;">(</span>s<span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
<code>push_back</code> constructs a temporary then moves it.
</p>

<p>
<code>emplace_back</code> constructs directly in place.
</p>

<p>
Remember, for string, a move is usually as expensive as a copy.
</p>

</aside>

</section>
<section id="slide-org41ddc35">
<h3 id="org41ddc35">Example 2.1</h3>
<p>
Default in-place construct.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">first default-construct in the vector</span>
<span style="color: #268bd2;">S</span>&amp; <span style="color: #cb4b16;">s</span> = v.emplace_back<span style="color: #2aa198;">()</span>;

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">now mutate s</span>
<span style="color: #5f127b;">// </span><span style="color: #5f127b;">...</span>
</pre>
</div>

<p>
<code>emplace_back</code> takes a parameter pack. Parameter packs can be empty.
</p>

<aside class="notes">
<p>
<code>emplace_back</code> is especially useful for this use case.
</p>

</aside>

</section>
<section id="slide-org7401507">
<h3 id="org7401507">Example 3</h3>
<p>
In-place construct with <code>explicit</code> constructor.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #5f127b;">// </span><span style="color: #5f127b;">recall: S has an explicit constructor from int</span>
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">push_back can't do explicit construction</span>
v.push_back<span style="color: #2aa198;">(</span><span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;  <span style="color: #5f127b;">// </span><span style="color: #5f127b;">compiler error!</span>

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">explicit construction is no problem for emplace_back</span>
<span style="color: #268bd2;">S</span>&amp; <span style="color: #cb4b16;">s</span> = v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
<code>emplace_back</code> does perfect forwarding. It can call <code>explicit</code> constructors.
</p>

<aside class="notes">
<p>
<code>emplace_back</code> is especially useful for this use case.
</p>

</aside>

</section>
<section id="slide-orgc1b5570">
<h3 id="orgc1b5570">Example: copy</h3>
<p>
Recall: our <code>S</code> class has a constructor from <code>Foo</code>, and an <code>explicit</code> constructor
from <code>int</code>.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">array</span><span style="color: #2aa198;">&lt;</span>Foo, <span style="color: #859900;">3</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">a</span> = <span style="color: #2aa198;">{</span> Foo<span style="color: #b58900;">{}</span>, Foo<span style="color: #b58900;">{}</span>, Foo<span style="color: #b58900;">{}</span> <span style="color: #2aa198;">}</span>;
v.reserve<span style="color: #2aa198;">(</span>a.size<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900;">std</span>::copy<span style="color: #2aa198;">(</span>a.cbegin<span style="color: #b58900;">()</span>, a.cend<span style="color: #b58900;">()</span>, <span style="color: #859900;">std</span>::back_inserter<span style="color: #b58900;">(</span>v<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
What does <code>back_insert_iterator</code> do here?
</p>

<aside class="notes">
<p>
For each element, we construct an <code>S</code> (from the <code>Foo</code>) and then we move it into
the <code>vector</code>.
</p>

</aside>

</section>
<section id="slide-org11e4031">
<h3 id="org11e4031">Example: copy</h3>
<p>
What if we have an <code>array</code> of <code>int</code>?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">array</span> <span style="color: #cb4b16;">a</span> = <span style="color: #2aa198;">{</span> <span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span>,<span style="color: #859900;">4</span>,<span style="color: #859900;">5</span> <span style="color: #2aa198;">}</span>;
v.reserve<span style="color: #2aa198;">(</span>a.size<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900;">std</span>::copy<span style="color: #2aa198;">(</span>a.cbegin<span style="color: #b58900;">()</span>, a.cend<span style="color: #b58900;">()</span>, <span style="color: #859900;">std</span>::back_inserter<span style="color: #b58900;">(</span>v<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p class="fragment (appear)">
Oops. The compiler is angry at us.
</p>

<aside class="notes">
<p>
<code>back_insert_iterator</code> calls <code>push_back</code> - it can't call our explicit
constructor.
</p>

</aside>

</section>
<section id="slide-org5b4002d">
<h3 id="org5b4002d">Example: copy?</h3>
<p>
OK, no problem, right?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">array</span> <span style="color: #cb4b16;">a</span> = <span style="color: #2aa198;">{</span> <span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span>,<span style="color: #859900;">4</span>,<span style="color: #859900;">5</span> <span style="color: #2aa198;">}</span>;
v.reserve<span style="color: #2aa198;">(</span>a.size<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900;">std</span>::transform<span style="color: #2aa198;">(</span>a.cbegin<span style="color: #b58900;">()</span>, a.cend<span style="color: #b58900;">()</span>, <span style="color: #859900;">std</span>::back_inserter<span style="color: #b58900;">(</span>v<span style="color: #b58900;">)</span>,
               <span style="color: #b58900;">[]</span> <span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span> <span style="color: #cb4b16;">i</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #94BFF3;">{</span>i<span style="color: #94BFF3;">}</span>; <span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
For each element, we construct an <code>S</code> (from the <code>int</code>) and then we move it into
the <code>vector</code>. No extra cost over the first solution, because the <code>return</code> from the
lambda RVOs.
</p>

<p>
But what we actually want to do is construct in place.
</p>

</aside>

</section>
<section id="slide-org6f0e055">
<h3 id="org6f0e055"><code>back_emplacer</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">Container</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">back_emplace_iterator</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">back_emplace_iterator</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">Container</span>&amp; <span style="color: #cb4b16;">c</span><span style="color: #b58900;">)</span> : c<span style="color: #b58900;">(</span>&amp;c<span style="color: #b58900;">)</span> <span style="color: #b58900;">{}</span>

  <span style="color: #268bd2;">back_emplace_iterator</span>&amp; <span style="color: #b58900; font-weight: bold;">operator</span><span style="color: #2aa198;">++</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> *<span style="color: #b58900; font-weight: bold;">this</span>; <span style="color: #b58900;">}</span>
  <span style="color: #268bd2;">back_emplace_iterator</span>&amp; <span style="color: #b58900; font-weight: bold;">operator</span><span style="color: #2aa198;">*</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> *<span style="color: #b58900; font-weight: bold;">this</span>; <span style="color: #b58900;">}</span>

  <span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #b58900;">&lt;</span><span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">Arg</span><span style="color: #b58900;">&gt;</span>
  <span style="color: #268bd2;">back_emplace_iterator</span>&amp; <span style="color: #b58900; font-weight: bold;">operator</span><span style="color: #2aa198;">=</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">Arg</span>&amp;&amp; <span style="color: #cb4b16;">arg</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    c-&gt;emplace_back<span style="color: #94BFF3;">(</span><span style="color: #859900;">std</span>::forward<span style="color: #dc322f;">&lt;</span><span style="color: #268bd2;">Arg</span><span style="color: #dc322f;">&gt;(</span><span style="color: #cb4b16;">arg</span><span style="color: #dc322f;">)</span><span style="color: #94BFF3;">)</span>;
    <span style="color: #b58900; font-weight: bold;">return</span> *<span style="color: #b58900; font-weight: bold;">this</span>;
  <span style="color: #b58900;">}</span>

<span style="color: #b58900; font-weight: bold;">private</span>:
  <span style="color: #268bd2;">Container</span>* <span style="color: #cb4b16;">c</span>;
<span style="color: #2aa198;">}</span>;
</pre>
</div>

</section>
<section id="slide-org4467013">
<h3 id="org4467013"><code>back_emplacer</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #5f127b;">// </span><span style="color: #5f127b;">pre-CTAD maker function</span>

<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">Container</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">auto</span> <span style="color: #2aa198;">back_emplacer</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">Container</span>&amp; <span style="color: #cb4b16;">c</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> back_emplace_iterator<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">Container</span><span style="color: #b58900;">&gt;(</span>c<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

</section>
<section id="slide-orgc869671">
<h3 id="orgc869671"><code>back_emplacer</code></h3>
<p>
What if we have an <code>array</code> of <code>int</code>?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">array</span> <span style="color: #cb4b16;">a</span> = <span style="color: #2aa198;">{</span> <span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span>,<span style="color: #859900;">4</span>,<span style="color: #859900;">5</span> <span style="color: #2aa198;">}</span>;
v.reserve<span style="color: #2aa198;">(</span>a.size<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900;">std</span>::copy<span style="color: #2aa198;">(</span>a.cbegin<span style="color: #b58900;">()</span>, a.cend<span style="color: #b58900;">()</span>, back_emplacer<span style="color: #b58900;">(</span>v<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

</section>
<section id="slide-org147f6fa">
<h3 id="org147f6fa">Exhibit D</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string_view<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">tokens</span>;
<span style="color: #5f127b;">// </span><span style="color: #5f127b;">...</span>
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">string_view</span> <span style="color: #cb4b16;">token</span> = <span style="color: #5f127b;">/* </span><span style="color: #5f127b;">stuff */</span>;
tokens.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>token<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
A few things here:
</p>
<ul>
<li><code>string_view</code> is a pointer + length. recommendation is to pass by value;
<code>move</code> gains nothing anyway.</li>
<li><code>push_back</code> works with rvalues just fine - <code>emplace_back</code> gains nothing here.</li>
<li>if you want to, you should pass <code>/* stuff */</code> directly to <code>emplace_back</code>.</li>

</ul>

</aside>

</section>
<section id="slide-org8b805d7">
<h3 id="org8b805d7">Exhibit E</h3>
<div class="org-src-container">

<pre  class="src src-c++">context-&gt;m_result-&gt;m_headers.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::string<span style="color: #b58900;">(</span>headerData, numBytes<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
A superfluous move! Better:
</p>

<div class="org-src-container">

<pre  class="src src-c++">context-&gt;m_result-&gt;m_headers.emplace_back<span style="color: #2aa198;">(</span>headerData, numBytes<span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
Don't explicitly call a constructor with <code>emplace_back</code>.
</p>

<aside class="notes">
<p>
And remember, likely a superfluous copy if the string is small-buffer-optimized.
</p>

</aside>

</section>
<section id="slide-orge65743c">
<h3 id="orge65743c"><code>vector</code> of <code>pair</code> = <code>map</code></h3>
<p>
Sometimes, we use a  sorted <code>vector</code> of <code>pair</code> as a replacement for <code>map</code>.
</p>

<p>
What do you do if part of your <code>pair</code> has a multi-argument constructor?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">Foo</span> <span style="color: #2aa198;">{</span> <span style="color: #2aa198;">Foo</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span>, <span style="color: #859900;">std</span>::string, <span style="color: #268bd2;">double</span><span style="color: #b58900;">)</span>; <span style="color: #2aa198;">}</span>;

<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">pair</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span>, <span style="color: #268bd2;">Foo</span><span style="color: #b58900;">&gt;</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">this is very common!</span>
v.push_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span><span style="color: #859900;">1</span>, Foo<span style="color: #94BFF3;">{</span><span style="color: #859900;">42</span>, <span style="color: #D01A4E;">"hello"</span>, <span style="color: #859900;">3.14</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">this is no better</span>
v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span><span style="color: #859900;">1</span>, Foo<span style="color: #94BFF3;">{</span><span style="color: #859900;">42</span>, <span style="color: #D01A4E;">"hello"</span>, <span style="color: #859900;">3.14</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">how can we do better?</span>
v.emplace_back<span style="color: #2aa198;">(</span> <span style="color: #5f127b;">/* </span><span style="color: #5f127b;">what here? */</span> <span style="color: #2aa198;">)</span>;
</pre>
</div>

</section>
<section id="slide-org1f1400c">
<h3 id="org1f1400c"><code>piecewise_construct</code> to the rescue!</h3>
<p>
<code>pair</code> has a constructor that will handle your multi-argument constructor.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args1</span>, <span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args2</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #2aa198;">pair</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">piecewise_construct_t</span>,
     <span style="color: #268bd2;">tuple</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">Args1</span><span style="color: #2aa198;">...</span><span style="color: #b58900;">&gt;</span> <span style="color: #cb4b16;">first_args</span>,
     <span style="color: #268bd2;">tuple</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">Args2</span><span style="color: #2aa198;">...</span><span style="color: #b58900;">&gt;</span> <span style="color: #cb4b16;">second_args</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Types</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">constexpr</span> <span style="color: #268bd2;">tuple</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">Types</span>&amp;&amp;<span style="color: #2aa198;">...</span><span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">forward_as_tuple</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">Types</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span> <span style="color: #b58900; font-weight: bold;">noexcept</span>;
</pre>
</div>

<p>
<code>piecewise_construct_t</code> is a tag type.
</p>

</section>
<section id="slide-org5cfcbff">
<h3 id="org5cfcbff">Using <code>piecewise_construct</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">Foo</span> <span style="color: #2aa198;">{</span> <span style="color: #2aa198;">Foo</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span>, <span style="color: #859900;">std</span>::string, <span style="color: #268bd2;">double</span><span style="color: #b58900;">)</span>; <span style="color: #2aa198;">}</span>;

<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">pair</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span>, <span style="color: #268bd2;">Foo</span><span style="color: #b58900;">&gt;</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">instead of this...</span>
v.push_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span><span style="color: #859900;">1</span>, Foo<span style="color: #94BFF3;">{</span><span style="color: #859900;">42</span>, <span style="color: #D01A4E;">"hello"</span>, <span style="color: #859900;">3.14</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">...we can do this</span>
v.emplace_back<span style="color: #2aa198;">(</span>
  <span style="color: #859900;">std</span>::piecewise_construct,
  <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">(</span><span style="color: #859900;">1</span><span style="color: #b58900;">)</span>,                   <span style="color: #5f127b;">// </span><span style="color: #5f127b;">args to int "constructor"</span>
  <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">(</span><span style="color: #859900;">42</span>, <span style="color: #D01A4E;">"hello"</span>, <span style="color: #859900;">3.14</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span><span style="color: #88090B;">)</span>; <span style="color: #5f127b;">// </span><span style="color: #5f127b;">args to Foo constructor</span>
</pre>
</div>
<p>
Perfect forwarding and in-place construction.
</p>

</section>
<section id="slide-org72e0273">
<h3 id="org72e0273">Recommendations</h3>
<ul>
<li><code>push_back</code> is perfectly fine for rvalues</li>
<li>use <code>emplace_back</code> only when you need its powers
<ul>
<li>in-place construction (including nullary construction)</li>
<li>a reference to what's added (C++17)</li>

</ul></li>
<li>never pass an explicit temporary to <code>emplace_back</code></li>
<li>try to construct in place when you can</li>
<li>use <code>piecewise_construct</code> / <code>forward_as_tuple</code> to forward args through <code>pair</code></li>

</ul>

</section>
</section>
<section>
<section id="slide-org633f2c3">
<h2 id="org633f2c3">4. <code>initializer_list</code></h2>
<div class='vertspace2'></div>
<blockquote nil><p>&quot;I fear these stubborn lines lack power to move.&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>Love's Labours Lost</em></div></blockquote>

</section>
<section id="slide-orgd08ec1c">
<h3 id="orgd08ec1c">What is <code>initializer_list</code>?</h3>
<p>
When you write:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span><span style="color: #2aa198;">{</span> <span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span> <span style="color: #2aa198;">}</span>;
</pre>
</div>
<p>
It's as if you wrote:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">int</span> <span style="color: #cb4b16;">a</span><span style="color: #2aa198;">[]</span> = <span style="color: #2aa198;">{</span> <span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span> <span style="color: #2aa198;">}</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = <span style="color: #859900;">std</span>::initializer_list<span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;(</span>a, a+<span style="color: #859900;">3</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Notice: the backing array is <code>const</code>.
</p>

</aside>

</section>
<section id="slide-org0c9d1fc">
<h3 id="org0c9d1fc"><code>initializer_list</code> has <code>const</code> storage, 1</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">Is</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">auto</span> <span style="color: #2aa198;">f</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> <span style="color: #859900;">std</span>::<span style="color: #268bd2;">initializer_list</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;{</span> Is<span style="color: #2aa198;">...</span> <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">void</span> <span style="color: #2aa198;">foo</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span> <span style="color: #cb4b16;">i</span>: <span style="color: #94BFF3;">{</span><span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span>
    cout &lt;&lt; i &lt;&lt; <span style="color: #D01A4E;">'</span><span style="color: #5f127b; font-weight: bold;">\</span><span style="color: #b58900; font-weight: bold;">n</span><span style="color: #D01A4E;">'</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">void</span> <span style="color: #2aa198;">bar</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span> <span style="color: #cb4b16;">i</span>: f<span style="color: #94BFF3;">&lt;</span><span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span><span style="color: #94BFF3;">&gt;()</span><span style="color: #b58900;">)</span>
    cout &lt;&lt; i &lt;&lt; <span style="color: #D01A4E;">'</span><span style="color: #5f127b; font-weight: bold;">\</span><span style="color: #b58900; font-weight: bold;">n</span><span style="color: #D01A4E;">'</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<aside class="notes">
<p>
This is nasty, because it could work on one compiler and you wouldn't notice it.
</p>

<p>
The compiler probably won't warn for this.
</p>

<p>
<code>initializer_list</code> is a "view" type like <code>string_view</code> and doesn't own its
contents.
</p>

</aside>

</section>
<section id="slide-orgbeb16aa">
<h3 id="orgbeb16aa"><code>initializer_list</code> has <code>const</code> storage, 2</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">unique_ptr</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = <span style="color: #2aa198;">{</span> make_unique<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">1</span><span style="color: #b58900;">)</span>, make_unique<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">2</span><span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>;
</pre>
</div>
<p>
That also means <code>move</code> can't work.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #859900;">std</span>::<span style="color: #268bd2;">unique_ptr</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">a</span><span style="color: #2aa198;">[]</span> = <span style="color: #2aa198;">{</span> <span style="color: #859900;">std</span>::make_unique<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">1</span><span style="color: #b58900;">)</span>,
                                   <span style="color: #859900;">std</span>::make_unique<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">2</span><span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">unique_ptr</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> =
  <span style="color: #859900;">std</span>::initializer_list<span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">unique_ptr</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;</span><span style="color: #2aa198;">&gt;(</span>a, a+<span style="color: #859900;">3</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
You can't move from an <code>initializer_list</code> - this won't compile.
</p>

</aside>

</section>
<section id="slide-org756eac9">
<h3 id="org756eac9">But they're so convenient!</h3>
<p>
I'd much rather write:
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = <span style="color: #2aa198;">{</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>, S<span style="color: #b58900;">{</span><span style="color: #859900;">2</span><span style="color: #b58900;">}</span>, S<span style="color: #b58900;">{</span><span style="color: #859900;">3</span><span style="color: #b58900;">}</span> <span style="color: #2aa198;">}</span>;
</pre>
</div>
<p>
(3 constructs, 3 copies, 3 destructs)
</p>

<p>
Than:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
v.reserve<span style="color: #2aa198;">(</span><span style="color: #859900;">3</span><span style="color: #2aa198;">)</span>;
v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">2</span><span style="color: #2aa198;">)</span>;
v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">3</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
<p>
(3 constructs)
</p>

<aside class="notes">
<p>
The first version is probably OK for builtin primitive types.
</p>

<p>
It's way worse than the second version for types with more than trivial
construction.
</p>

</aside>

</section>
<section id="slide-org71ce4f0">
<h3 id="org71ce4f0">We can make it a little better&#x2026;</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = <span style="color: #2aa198;">{</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>, S<span style="color: #b58900;">{</span><span style="color: #859900;">2</span><span style="color: #b58900;">}</span>, S<span style="color: #b58900;">{</span><span style="color: #859900;">3</span><span style="color: #b58900;">}</span> <span style="color: #2aa198;">}</span>;
</pre>
</div>
<p>
(3 constructs, 3 copies, 3 destructs)
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">a</span><span style="color: #2aa198;">[</span><span style="color: #859900;">3</span><span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">{</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>, S<span style="color: #b58900;">{</span><span style="color: #859900;">2</span><span style="color: #b58900;">}</span>, S<span style="color: #b58900;">{</span><span style="color: #859900;">3</span><span style="color: #b58900;">}</span> <span style="color: #2aa198;">}</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">S</span><span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">v</span><span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">make_move_iterator</span><span style="color: #b58900;">(</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">begin</span><span style="color: #94BFF3;">(</span><span style="color: #cb4b16;">a</span><span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span>,
                 <span style="color: #859900;">std</span>::<span style="color: #268bd2;">make_move_iterator</span><span style="color: #b58900;">(</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">end</span><span style="color: #94BFF3;">(</span><span style="color: #cb4b16;">a</span><span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
<p>
(3 constructs, 3 moves, 3 destructs)
</p>

</section>
<section id="slide-org477c928">
<h3 id="org477c928">What we really need&#x2026;</h3>
<p>
Is an in-place constructor for <code>vector</code>. (For everything?)
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">vector</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">in_place_t</span>, <span style="color: #268bd2;">Args</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
Future (?) proposal by Simon Brand.
</p>

<p>
<a href="https://wg21.tartanllama.xyz/initializer_list">https://wg21.tartanllama.xyz/initializer_list</a>
</p>

</section>
<section id="slide-org668628b">
<h3 id="org668628b">Exhibit F</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">unordered_set</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">kKeywords</span> = <span style="color: #2aa198;">{</span>
        <span style="color: #D01A4E;">"alignas"</span>, <span style="color: #D01A4E;">"alignof"</span>, <span style="color: #D01A4E;">"and"</span>, <span style="color: #D01A4E;">"and_eq"</span>, <span style="color: #D01A4E;">"asm"</span>, <span style="color: #D01A4E;">"auto"</span>, <span style="color: #D01A4E;">"bitand"</span>, <span style="color: #D01A4E;">"bitor"</span>,
        <span style="color: #D01A4E;">"bool"</span>, <span style="color: #D01A4E;">"break"</span>, <span style="color: #D01A4E;">"case"</span>, <span style="color: #D01A4E;">"catch"</span>, <span style="color: #D01A4E;">"char"</span>, <span style="color: #D01A4E;">"class"</span>, <span style="color: #D01A4E;">"compl"</span>, <span style="color: #D01A4E;">"const"</span>,
        <span style="color: #D01A4E;">"constexpr"</span>, <span style="color: #D01A4E;">"const_cast"</span>, <span style="color: #D01A4E;">"continue"</span>, <span style="color: #D01A4E;">"decltype"</span>, <span style="color: #D01A4E;">"default"</span>, <span style="color: #D01A4E;">"delete"</span>, <span style="color: #333333; background-color: #000000;">"do"</span><span style="color: #333333; background-color: #000000;">,</span>
        <span style="color: #D01A4E;">"double"</span>, <span style="color: #D01A4E;">"dynamic_cast"</span>, <span style="color: #D01A4E;">"else"</span>, <span style="color: #D01A4E;">"enum"</span>, <span style="color: #D01A4E;">"explicit"</span>, <span style="color: #D01A4E;">"extern"</span>, <span style="color: #D01A4E;">"false"</span>,
        <span style="color: #D01A4E;">"float"</span>, <span style="color: #D01A4E;">"for"</span>, <span style="color: #D01A4E;">"friend"</span>, <span style="color: #D01A4E;">"goto"</span>, <span style="color: #D01A4E;">"if"</span>, <span style="color: #D01A4E;">"inline"</span>, <span style="color: #D01A4E;">"int"</span>, <span style="color: #D01A4E;">"long"</span>, <span style="color: #D01A4E;">"mutabl</span><span style="color: #333333; background-color: #000000;">e"</span><span style="color: #333333; background-color: #000000;">,</span>
        <span style="color: #D01A4E;">"namespace"</span>, <span style="color: #D01A4E;">"new"</span>, <span style="color: #D01A4E;">"noexcept"</span>, <span style="color: #D01A4E;">"not"</span>, <span style="color: #D01A4E;">"not_eq"</span>, <span style="color: #D01A4E;">"NULL"</span>, <span style="color: #D01A4E;">"operator"</span>, <span style="color: #D01A4E;">"or</span><span style="color: #333333; background-color: #000000;">"</span><span style="color: #333333; background-color: #000000;">,</span>
        <span style="color: #D01A4E;">"or_eq"</span>, <span style="color: #D01A4E;">"private"</span>, <span style="color: #D01A4E;">"protected"</span>, <span style="color: #D01A4E;">"public"</span>, <span style="color: #D01A4E;">"register"</span>, <span style="color: #D01A4E;">"reinterpret_cast</span><span style="color: #333333; background-color: #000000;">"</span><span style="color: #333333; background-color: #000000;">,</span>
        <span style="color: #D01A4E;">"return"</span>, <span style="color: #D01A4E;">"short"</span>, <span style="color: #D01A4E;">"signed"</span>, <span style="color: #D01A4E;">"sizeof"</span>, <span style="color: #D01A4E;">"static"</span>, <span style="color: #D01A4E;">"static_assert"</span>,
        <span style="color: #D01A4E;">"static_cast"</span>, <span style="color: #D01A4E;">"struct"</span>, <span style="color: #D01A4E;">"switch"</span>, <span style="color: #D01A4E;">"template"</span>, <span style="color: #D01A4E;">"this"</span>, <span style="color: #D01A4E;">"thread_local"</span>,
        <span style="color: #D01A4E;">"throw"</span>, <span style="color: #D01A4E;">"true"</span>, <span style="color: #D01A4E;">"try"</span>, <span style="color: #D01A4E;">"typedef"</span>, <span style="color: #D01A4E;">"typeid"</span>, <span style="color: #D01A4E;">"typename"</span>, <span style="color: #D01A4E;">"union"</span>, <span style="color: #D01A4E;">"unsig</span><span style="color: #333333; background-color: #000000;">ned"</span><span style="color: #333333; background-color: #000000;">,</span>
        <span style="color: #D01A4E;">"using"</span>, <span style="color: #D01A4E;">"virtual"</span>, <span style="color: #D01A4E;">"void"</span>, <span style="color: #D01A4E;">"volatile"</span>, <span style="color: #D01A4E;">"wchar_t"</span>, <span style="color: #D01A4E;">"while"</span>, <span style="color: #D01A4E;">"xor"</span>, <span style="color: #D01A4E;">"xor_</span><span style="color: #333333; background-color: #000000;">eq"</span>
<span style="color: #2aa198;">}</span>;
</pre>
</div>

</section>
<section id="slide-orgb229508">
<h3 id="orgb229508">Caveat Constructor</h3>
<p>
<code>std::string</code> is an interesting case here. We intuit/are taught:
</p>

<blockquote nil><p>Delay construction, allocation, etc. as late as possible.</p></blockquote>

<p>
But that might hurt us with <code>std::string</code>.
</p>

<p>
<a href="https://www.youtube.com/watch?v=sSlmmZMFsXQ">"Initializer Lists are Broken, Let's Fix Them"</a> &#x2013; Jason Turner, C++Now 2018
</p>

</section>
<section id="slide-orgea64e46">
<h3 id="orgea64e46">Surprising: <code>string</code> vs <code>const char*</code></h3>
<p>
SBO-strings
<a href="http://quick-bench.com/5dPSX8rx-R8_BIUYbYOp6DcqhAc">http://quick-bench.com/5dPSX8rx-R8_BIUYbYOp6DcqhAc</a>
</p>

<p>
Non SBO-strings 1:
<a href="http://quick-bench.com/mr6ZIQ8Jy0ghe1scBcTznYF2s5w">http://quick-bench.com/mr6ZIQ8Jy0ghe1scBcTznYF2s5w</a>
</p>

<p>
Non SBO-strings 2:
<a href="http://quick-bench.com/vzlG11LwZN-uMAKdK8X1XgRuaWs">http://quick-bench.com/vzlG11LwZN-uMAKdK8X1XgRuaWs</a>
</p>

<aside class="notes">
<p>
Two things mess with our mental model for strings. First - the small buffer
optimization. As previously mentioned, it makes copy the same cost as move.
</p>

<p>
Second - we often make strings from string literals. What's the type of a string
literal at declaration? Array of char. What's the type of it when you pass it to
a function? It decays to pointer to char.
</p>

<p>
So, if a string isn't small-buffer optimized, move is cheap. And if we're
constructing it from a string literal, the compiler knows the size. If we let it
decay to a char*, we're going to call strlen at some point.
</p>

</aside>

</section>
<section id="slide-org84facfd">
<h3 id="org84facfd">Recommendations</h3>
<ul>
<li>use <code>initializer_list</code> only for literal types</li>
<li>consider using <code>array</code> and manually moving</li>
<li>probably don't use <code>initializer_list</code> for anything that'll get run more than
once</li>
<li>wait for an <code>in_place_t</code> constructor on <code>vector</code> ?</li>
<li>watch Jason's talk</li>
<li>wait for P1249 (<code>std::forward</code> from <code>std::initializer_list</code>)?</li>

</ul>

<aside class="notes">
<p>
I'm not sure what to recommend. Really the first point.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org63820fc">
<h2 id="org63820fc">5. Putting stuff into a <code>map</code></h2>
<p>
(or other associative container)
</p>

<p>
It's a bit complicated.
</p>

<div class='vertspace2'></div>
<blockquote nil><p>&quot;A plague upon it! I have forgot the map.&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>Henry IV, Part I</em></div></blockquote>

<aside class="notes">
<p>
When I say <code>map</code>, I mean <code>map</code>, <code>unordered_map</code>, <code>multimap</code>, <code>unordered_multimap</code>,
etc, and also the various flavours of <code>set</code>.
</p>

<p>
Note: the <code>value_type</code> of a <code>map</code> is <code>pair&lt;const K, V&gt;</code>. Confusingly, if we want
to refer to just the value in the map and not the key, it's called the
<code>mapped_type</code>.
</p>

</aside>

</section>
<section id="slide-org1e08ac4">
<h3 id="org1e08ac4"><code>initializer_list</code> with <code>map</code></h3>
<p>
It's perfectly possible to initialize a map with an <code>initializer_list</code>.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #5f127b;">// </span><span style="color: #5f127b;">recall S has an implicit constructor from Foo</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span> <span style="color: #2aa198;">{</span> <span style="color: #b58900;">{</span><span style="color: #859900;">0</span>, Foo<span style="color: #94BFF3;">{}</span><span style="color: #b58900;">}</span> <span style="color: #2aa198;">}</span>; <span style="color: #5f127b;">// </span><span style="color: #5f127b;">how many constructs/copies/moves?</span>
</pre>
</div>

<p>
Use aggregate initialization with <code>pair</code>.
</p>

<p>
Is this good?
</p>

<aside class="notes">
<p>
Same as the <code>vector</code> init case basically. <code>initializer_list</code> still suffers from
the same problems.
</p>

<p>
You can't use explicit constructors easily here.
</p>

<p>
If you have explicit constructors you might need to explicitly call out the type
 of pair; it's not going to make a lot of difference.
</p>

</aside>

</section>
<section id="slide-org2dcdb89">
<h3 id="org2dcdb89">Alternative: templatery</h3>
<p>
<a href="https://gist.github.com/elbeno/609e929ef6898f09e96a#file-for_each_args-cpp-L55">https://gist.github.com/elbeno/609e929ef6898f09e96a#file-for_each_args-cpp-L55</a>
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #5f127b;">// </span><span style="color: #5f127b;">call an N-ary function on each lot of N args passed in</span>
<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">size_t</span> <span style="color: #cb4b16;">N</span>, <span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">F</span>, <span style="color: #b58900; font-weight: bold;">typename</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Ts</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">void</span> <span style="color: #2aa198;">for_each_n_args</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">F</span>&amp;&amp; <span style="color: #cb4b16;">f</span>, <span style="color: #268bd2;">Ts</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">ts</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
for_each_n_args<span style="color: #2aa198;">&lt;</span><span style="color: #859900;">2</span><span style="color: #2aa198;">&gt;(</span>
  <span style="color: #b58900;">[</span>&amp;<span style="color: #b58900;">]</span> <span style="color: #b58900;">(</span><span style="color: #b58900; font-weight: bold;">auto</span>&amp;&amp; <span style="color: #cb4b16;">k</span>, <span style="color: #b58900; font-weight: bold;">auto</span>&amp;&amp; <span style="color: #cb4b16;">v</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
      m.emplace<span style="color: #94BFF3;">(</span>forward<span style="color: #dc322f;">&lt;</span><span style="color: #b58900; font-weight: bold;">decltype</span><span style="color: #859900;">(</span>k<span style="color: #859900;">)</span><span style="color: #dc322f;">&gt;(</span>k<span style="color: #dc322f;">)</span>,
                forward<span style="color: #dc322f;">&lt;</span><span style="color: #b58900; font-weight: bold;">decltype</span><span style="color: #859900;">(</span>v<span style="color: #859900;">)</span><span style="color: #dc322f;">&gt;(</span>v<span style="color: #dc322f;">)</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>,
  <span style="color: #859900;">0</span>, <span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>; <span style="color: #5f127b;">// </span><span style="color: #5f127b;">we can call explicit constructor</span>
</pre>
</div>

<p>
If you know the types, you can probably write the lambda in a less ugly way.
</p>

<aside class="notes">
<p>
<code>for_each_n_args</code> is a function template that perfectly-forwards its arguments
in groups of N to the function you give it.
</p>

<p>
Everything here gets constructed in place. No moves or copies.
</p>

<p>
This lambda deals with single-argument constructors for value. But&#x2026;
</p>

</aside>

</section>
<section id="slide-orgca6735f">
<h3 id="orgca6735f">Alternative: multi-arg templatery</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
for_each_n_args<span style="color: #2aa198;">&lt;</span><span style="color: #859900;">3</span><span style="color: #2aa198;">&gt;(</span>
  <span style="color: #b58900;">[</span>&amp;<span style="color: #b58900;">]</span> <span style="color: #b58900;">(</span><span style="color: #b58900; font-weight: bold;">auto</span>&amp;&amp; <span style="color: #cb4b16;">k</span>, <span style="color: #b58900; font-weight: bold;">auto</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">v</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
      m.emplace<span style="color: #94BFF3;">(</span>
        <span style="color: #859900;">std</span>::piecewise_construct,
        <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #dc322f;">(</span><span style="color: #859900;">std</span>::forward<span style="color: #859900;">&lt;</span><span style="color: #b58900; font-weight: bold;">decltype</span><span style="color: #268bd2;">(</span>k<span style="color: #268bd2;">)</span><span style="color: #859900;">&gt;(</span>k<span style="color: #859900;">)</span><span style="color: #dc322f;">)</span>,
        <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #dc322f;">(</span><span style="color: #859900;">std</span>::forward<span style="color: #859900;">&lt;</span><span style="color: #b58900; font-weight: bold;">decltype</span><span style="color: #268bd2;">(</span>v<span style="color: #268bd2;">)</span><span style="color: #859900;">&gt;(</span>v<span style="color: #859900;">)</span><span style="color: #2aa198;">...</span><span style="color: #dc322f;">)</span>; <span style="color: #88090B;">}</span>,
  <span style="color: #859900;">0</span>, <span style="color: #859900;">1</span>, <span style="color: #859900;">2</span><span style="color: #88090B;">)</span>; <span style="color: #5f127b;">// </span><span style="color: #5f127b;">explicit multi-arg value constructor</span>
</pre>
</div>

<p>
Everything constructed in place.
</p>

<aside class="notes">
<p>
Here we are calling S's two-arg constructor.
</p>

<p>
<code>for_each_n_args</code> also works with vector (including vector-of-pair) as an
alternative to <code>initializer_list</code>
</p>

<p>
There are some issues with calling <code>explicit</code> constructors&#x2026; it depends on the
compiler/library. It is supposed to work.
</p>

</aside>

</section>
<section id="slide-orge4ff7b3">
<h3 id="orge4ff7b3">Enough about initializing</h3>
<p>
How about putting things into an existing <code>map</code>?
</p>

</section>
<section id="slide-org5e021d2">
<h3 id="org5e021d2">The Easy Way: <code>operator[]</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #5f127b;">// </span><span style="color: #5f127b;">recall S has an implicit constructor from Foo</span>
<span style="color: #5f127b;">// </span><span style="color: #5f127b;">but an explicit constructor from int</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m<span style="color: #2aa198;">[</span><span style="color: #859900;">0</span><span style="color: #2aa198;">]</span> = S<span style="color: #2aa198;">{</span><span style="color: #859900;">1</span><span style="color: #2aa198;">}</span>;
m<span style="color: #2aa198;">[</span><span style="color: #859900;">1</span><span style="color: #2aa198;">]</span> = Foo<span style="color: #2aa198;">{}</span>;
</pre>
</div>

<p>
How many constructs/moves/copies?
</p>

<aside class="notes">
<p>
These each have a construct, a default construct, and a move.
</p>

<p>
The advantage of this is that when you know the element is there already, it's
fine. You just get a lookup and an assign.
</p>

<p>
But if the element isn't there, you never get a copy construct or a move
construct here.
</p>

<p>
You always get an assign! Because you always get a default construct if the
element isn't there.
</p>

<p>
In fact this is the only function on map that requires your mapped_type to have
a default constructor! It's fine to use objects without default constructors in
a map, if you never use this function. And that can be a significant thing.
</p>

</aside>

</section>
<section id="slide-org81be1b1">
<h3 id="org81be1b1">The Other Easy Way: <code>insert</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #5f127b;">// </span><span style="color: #5f127b;">recall S has an implicit constructor from Foo</span>
<span style="color: #5f127b;">// </span><span style="color: #5f127b;">but an explicit constructor from int</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">pair&lt;iterator,bool&gt; insert(value_type&amp;&amp; value);</span>

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">template &lt;class T1, class T2&gt;</span>
<span style="color: #5f127b;">// </span><span style="color: #5f127b;">pair&lt;V1,V2&gt; make_pair(T1&amp;&amp; t, T2&amp;&amp; u);</span>

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">alternatives:</span>
m.insert<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span><span style="color: #859900;">0</span>, S<span style="color: #94BFF3;">{</span><span style="color: #859900;">1</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
m.insert<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::pair<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span>, <span style="color: #268bd2;">S</span>&amp;&amp;<span style="color: #b58900;">&gt;(</span><span style="color: #859900;">0</span>, S<span style="color: #94BFF3;">{</span><span style="color: #859900;">1</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
m.insert<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span><span style="color: #859900;">0</span>, <span style="color: #859900;">1</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
How many constructs/moves/copies?
</p>

<aside class="notes">
<p>

</p>

<p>
The first line here creates an S, moves it into pair&lt;int, S&gt;, then moves the
pair into the map.
</p>

<p>
Remember that make_pair deduces the type of its arguments. And V1 and V2 here
are the decayed types of T1 and T2.
</p>

<p>
The second line forces a pair of type &lt;int, S&amp;&amp;&gt;, so you get one move after the
initial construct.
</p>

<p>
The third line makes a pair&lt;int, int&gt; then uses that pair to construct a pair of
&lt;int, S&gt; in the map.
</p>

</aside>

</section>
<section id="slide-orgb1785f3">
<h3 id="orgb1785f3"><code>emplace</code></h3>
<p>
Enter the <i>wonderful C++11 panacea</i> that is move semantics.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #5f127b;">// </span><span style="color: #5f127b;">recall S has an implicit constructor from Foo</span>
<span style="color: #5f127b;">// </span><span style="color: #5f127b;">but an explicit constructor from int</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">template &lt;class... Args&gt;</span>
<span style="color: #5f127b;">// </span><span style="color: #5f127b;">pair&lt;iterator,bool&gt; emplace(Args&amp;&amp;... args);</span>

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">this was 2 moves</span>
<span style="color: #5f127b;">// </span><span style="color: #5f127b;">m.insert(make_pair(0, S{1}));</span>

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">much better, right?</span>
m.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span><span style="color: #859900;">0</span>, S<span style="color: #94BFF3;">{</span><span style="color: #859900;">1</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
You guessed it&#x2026;
</p>

<aside class="notes">
<p>
Don't do this. It is <i>exactly</i> the same as <code>insert</code> here. Two moves.
</p>

</aside>

</section>
<section id="slide-org70a7c99">
<h3 id="org70a7c99"><code>emplace</code>, better usage</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #5f127b;">// </span><span style="color: #5f127b;">recall S has an implicit constructor from Foo</span>
<span style="color: #5f127b;">// </span><span style="color: #5f127b;">but an explicit constructor from int</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">template &lt;class... Args&gt;</span>
<span style="color: #5f127b;">// </span><span style="color: #5f127b;">pair&lt;iterator,bool&gt; emplace(Args&amp;&amp;... args);</span>

m.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">0</span>, <span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>; <span style="color: #5f127b;">// </span><span style="color: #5f127b;">no moves, just a construct</span>
</pre>
</div>

<aside class="notes">
<p>
Again, the point of <code>emplace</code> is in-place construction.
</p>

<p>
It doesn't help you over <code>insert</code> if you just pass rvalues. <code>insert</code> works just
fine with rvalues.
</p>

</aside>

</section>
<section id="slide-org952143c">
<h3 id="org952143c"><code>emplace</code> problem</h3>
<p>
What do we do when we want to default-construct the value?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">0</span><span style="color: #2aa198;">)</span>; <span style="color: #5f127b;">// </span><span style="color: #5f127b;">default construct S please!</span>
</pre>
</div>

<p class="fragment (appear)">
<i>error 2665: <code>std::pair&lt;const _Kty,_Ty&gt;::pair</code>: none of the 2 overloads could
convert all the argument types</i>
</p>

<aside class="notes">
<p>
Here's a problem: how can we tell <code>emplace</code> to zero-arg construct the value when
we can't syntactically pass "zero arguments" in the place of an argument.
</p>

<p>
We don't want to default-construct an S explicitly here and move it in.
</p>

</aside>


</section>
<section id="slide-org3ccfa3e">
<h3 id="org3ccfa3e"><code>emplace</code> problem</h3>
<p>
What do we do when we want to default-construct the value?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m<span style="color: #2aa198;">[</span><span style="color: #859900;">0</span><span style="color: #2aa198;">]</span>; <span style="color: #5f127b;">// </span><span style="color: #5f127b;">default construct S please!</span>
</pre>
</div>

<p class="fragment (appear)">
_
</p>

<aside class="notes">
<p>
We could use <code>operator[]</code> but that would be weird.
</p>

<p>
I don't like expression statements and I would probably write <code>operator[]</code> with
nodiscard.
</p>

<p>
Remember the <code>value_type</code> of the <code>map</code> is a <code>pair</code> - that's what <code>emplace</code> is
trying to construct.
</p>

</aside>

</section>
<section id="slide-orgfb1579a">
<h3 id="orgfb1579a"><code>emplace</code> with zero-arg constructor</h3>
<p>
Our old friend <code>piecewise_construct</code> can help.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::piecewise_construct,
          <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">(</span><span style="color: #859900;">0</span><span style="color: #b58900;">)</span>,
          <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>; <span style="color: #5f127b;">// </span><span style="color: #5f127b;">default construct S please!</span>
</pre>
</div>

<p>
Tuples are allowed to be empty!
</p>

<p>
Yes, we can also use this for more-than-one-arg constructors.
</p>

<aside class="notes">
<p>
Here's the piecewise constructor on <code>pair</code> again.
</p>

</aside>

</section>
<section id="slide-orgb5576ec">
<h3 id="orgb5576ec">Exhibit G</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #5f127b;">// </span><span style="color: #5f127b;">explicit ClientIdRecord(</span>
<span style="color: #5f127b;">//  </span><span style="color: #5f127b;">const string&amp; clientId, const ProcessId&amp; clientProc, const ProcessId&amp; server</span><span style="color: #333333; background-color: #000000;">Proc);</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">Storage</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">unordered_set</span><span style="color: #2aa198;">&lt;</span>ClientIdRecord<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">Storage</span> <span style="color: #cb4b16;">m_storage</span>;
m_storage.emplace<span style="color: #2aa198;">(</span>inClientId, clientProc, serverProc<span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
Perfectly fine as far as <code>emplace</code> usage.
</p>

<p>
Then we want to change the <code>unordered_set</code> to an <code>unordered_map</code>.
</p>

<aside class="notes">
<p>
ClientIdRecord has a 3-argument constructor.
</p>

<p>
<code>inClientId</code> is a string.
</p>

<p>
One in-place construct. This is fine.
</p>

</aside>

</section>
<section id="slide-org333770a">
<h3 id="org333770a">Exhibit G</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #5f127b;">// </span><span style="color: #5f127b;">explicit ClientIdRecord(</span>
<span style="color: #5f127b;">//  </span><span style="color: #5f127b;">const string&amp; clientId, const ProcessId&amp; clientProc, const ProcessId&amp; server</span><span style="color: #333333; background-color: #000000;">Proc);</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">Storage</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">unordered_map</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string, ClientIdRecord<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">Storage</span> <span style="color: #cb4b16;">m_storage</span>;
m_storage.emplace<span style="color: #2aa198;">(</span>
  <span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span>inClientId,
                 ClientIdRecord<span style="color: #94BFF3;">(</span>inClientId, clientProc, serverProc<span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
Is this optimal?
</p>

<aside class="notes">
<p>
2 extra moves here.
</p>

<p>
How do we do better?
</p>

</aside>

</section>
<section id="slide-orgcb62471">
<h3 id="orgcb62471">Exhibit G</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">Storage</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">unordered_map</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string, ClientIdRecord<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">Storage</span> <span style="color: #cb4b16;">m_storage</span>;
m_storage.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::piecewise_construct,
                  <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">(</span>inClientId<span style="color: #b58900;">)</span>,
                  <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">(</span>inClientId, clientProc, serverProc<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
Use <code>piecewise_construct</code> again.
</p>

</section>
<section id="slide-org971221d">
<h3 id="org971221d"><code>emplace</code> problem 2</h3>
<p>
What do you do if you want to <code>emplace</code> the result of a function call?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">get_S</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>; <span style="color: #2aa198;">}</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">0</span>, get_S<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
How can we avoid the move?
</p>

<p>
Is it possible to in-place construct here?
</p>

</section>
<section id="slide-orga995f6f">
<h3 id="orga995f6f">In-place construct a function call result</h3>
<p>
We can't avoid evaluating the function call before calling <code>emplace</code>.
</p>

<p>
But, we can control when the result of the function call becomes an <code>S</code>.
</p>

</section>
<section id="slide-org8aa59b4">
<h3 id="org8aa59b4">In-place construct a function call result</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">F</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">with_result_of_t</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">T</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">result_of_t</span><span style="color: #b58900;">&lt;</span>F<span style="color: #94BFF3;">()</span><span style="color: #b58900;">&gt;</span>;
  <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">with_result_of_t</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">F</span> <span style="color: #cb4b16;">f</span><span style="color: #b58900;">)</span> : f<span style="color: #b58900;">(</span><span style="color: #859900;">std</span>::move<span style="color: #94BFF3;">(</span>f<span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{}</span>
  <span style="color: #b58900; font-weight: bold;">operator</span> <span style="color: #268bd2;">T</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> f<span style="color: #94BFF3;">()</span>; <span style="color: #b58900;">}</span>

<span style="color: #b58900; font-weight: bold;">private</span>:
  <span style="color: #268bd2;">F</span> <span style="color: #cb4b16;">f</span>;
<span style="color: #2aa198;">}</span>;

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">prior to CTAD</span>
<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">F</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">inline</span> <span style="color: #b58900; font-weight: bold;">auto</span> <span style="color: #2aa198;">with_result_of</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">F</span>&amp;&amp; <span style="color: #cb4b16;">f</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> with_result_of_t<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">F</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">std</span>::forward<span style="color: #94BFF3;">&lt;</span><span style="color: #268bd2;">F</span><span style="color: #94BFF3;">&gt;(</span>f<span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Capture the function and call it only at the point that we want to convert the
result to an <code>S</code>.
</p>

<p>
<code>invoke_result_t</code> is C++17 - before that you can use <code>result_of_t</code>.
</p>

</aside>

</section>
<section id="slide-org41b7c6b">
<h3 id="org41b7c6b"><code>emplace</code> problem 2</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">get_S</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>; <span style="color: #2aa198;">}</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, <span style="color: #268bd2;">S</span><span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">0</span>, with_result_of<span style="color: #b58900;">(</span><span style="color: #94BFF3;">[]</span> <span style="color: #94BFF3;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> get_S<span style="color: #dc322f;">()</span>; <span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">m.emplace(0, with_result_of(get_S));</span>
</pre>
</div>

<p>
Compilers are really good at optimizing single-use lambdas.
</p>

<aside class="notes">
<p>
You would think the second line here would work just as well. But VC++
doesn't manage to elide the move.
</p>

</aside>

</section>
<section id="slide-org2ea957d">
<h3 id="org2ea957d">C++17: <code>insert_or_assign</code></h3>
<p>
Of course, <code>insert</code> / <code>emplace</code> and <code>operator[]</code> actually do different things.
</p>

<p>
What do you do if you want to insert, or assign if the element is already there?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span> <span style="color: #268bd2;">M</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">pair</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">iterator</span>, <span style="color: #268bd2;">bool</span><span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">insert_or_assign</span><span style="color: #2aa198;">(</span><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">key_type</span>&amp; <span style="color: #cb4b16;">k</span>, <span style="color: #268bd2;">M</span>&amp;&amp; <span style="color: #cb4b16;">obj</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span> <span style="color: #268bd2;">M</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">pair</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">iterator</span>, <span style="color: #268bd2;">bool</span><span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">insert_or_assign</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">key_type</span>&amp;&amp; <span style="color: #cb4b16;">k</span>, <span style="color: #268bd2;">M</span>&amp;&amp; <span style="color: #cb4b16;">obj</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
Introduced with C++17.
</p>

<aside class="notes">
<p>
<code>insert_or_assign</code> doesn't need default construction (unlike <code>operator[]</code>).
</p>

<p>
<code>insert_or_assign</code> was introduced with C++17. Can be written as a free function,
but difficult/impossible to make as efficient as map can as a member function.
</p>

</aside>

</section>
<section id="slide-orgd7a5bbb">
<h3 id="orgd7a5bbb">C++17: <code>insert_or_assign</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m.insert_or_assign<span style="color: #2aa198;">(</span><span style="color: #859900;">0</span>, Foo<span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span>; <span style="color: #5f127b;">// </span><span style="color: #5f127b;">implicit construction - fine</span>

<span style="color: #5f127b;">// </span><span style="color: #5f127b;">m.insert_or_assign(1, 1);  // explicit construction - error!</span>
m.insert_or_assign<span style="color: #2aa198;">(</span><span style="color: #859900;">1</span>, with_result_of<span style="color: #b58900;">(</span><span style="color: #94BFF3;">[]{</span> <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #dc322f;">{</span><span style="color: #859900;">1</span><span style="color: #dc322f;">}</span>; <span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>; <span style="color: #5f127b;">// </span><span style="color: #5f127b;">RVO</span>
</pre>
</div>

<aside class="notes">
<p>
Unfortunately there is no <code>emplace_or_assign</code>. (In the assign case presumably
could not avoid making a temporary to assign). But you can use the same
<code>with_result_of</code> technique with <code>insert_or_assign</code>.
</p>

</aside>

</section>
<section id="slide-org4fa7b48">
<h3 id="org4fa7b48">In case you're not keeping count&#x2026;</h3>
<p>
We now have at least 3 different interface styles for putting things in a
<code>map</code>&#x2026;
</p>

<ul>
<li><code>insert</code> takes a <code>value_type</code> (aka <code>pair</code>)</li>
<li><code>emplace</code> takes a parameter pack</li>
<li><code>insert_or_assign</code> takes a key and a value</li>

</ul>

<aside class="notes">
<p>
This is unfortunate.
</p>

</aside>

</section>
<section id="slide-orge52e71f">
<h3 id="orge52e71f">And potentially a 4th!</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;

<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m2</span><span style="color: #2aa198;">{</span><span style="color: #b58900;">{</span><span style="color: #859900;">1</span>, Foo<span style="color: #94BFF3;">{}</span><span style="color: #b58900;">}</span><span style="color: #2aa198;">}</span>; <span style="color: #5f127b;">// </span><span style="color: #5f127b;">pretend initialization becomes efficient &amp; simple</span>

m.insert<span style="color: #2aa198;">(</span>m2.extract<span style="color: #b58900;">(</span><span style="color: #859900;">1</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Yet another way! If at some future time, initialization becomes simpler than the
various ways to insert, this "idiom" could catch on&#x2026;
</p>

</aside>

</section>
<section id="slide-org42681a4">
<h3 id="org42681a4">Exhibit H</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">K</span>, <span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">V</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #859900;">LRUCache</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">K</span>, <span style="color: #268bd2;">V</span><span style="color: #2aa198;">&gt;</span>::<span style="color: #268bd2;">EntryPtr</span> <span style="color: #859900;">LRUCache</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">K</span>, <span style="color: #268bd2;">V</span><span style="color: #2aa198;">&gt;</span>::<span style="color: #2aa198;">Insert</span><span style="color: #2aa198;">(</span><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">K</span>&amp; <span style="color: #cb4b16;">key</span>, <span style="color: #268bd2;">V</span> <span style="color: #cb4b16;">value</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #5f127b;">// </span><span style="color: #5f127b;">Is the key already present?</span>
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>m_entries.find<span style="color: #94BFF3;">(</span>key<span style="color: #94BFF3;">)</span> != m_entries.end<span style="color: #94BFF3;">()</span><span style="color: #b58900;">)</span> <span style="color: #b58900; font-weight: bold;">return</span> <span style="color: #859900;">nullptr</span>;

  <span style="color: #5f127b;">// </span><span style="color: #5f127b;">Is the cache full?</span>
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>m_entries.size<span style="color: #94BFF3;">()</span> == m_capacity<span style="color: #b58900;">)</span> Evict<span style="color: #b58900;">(</span><span style="color: #859900;">1</span><span style="color: #b58900;">)</span>;

  <span style="color: #5f127b;">// </span><span style="color: #5f127b;">Insert the new value.</span>
  <span style="color: #268bd2;">EntryPtr</span> <span style="color: #cb4b16;">e</span> = <span style="color: #859900;">std</span>::make_shared<span style="color: #b58900;">&lt;</span>Entry<span style="color: #b58900;">&gt;(</span>key, <span style="color: #859900;">std</span>::move<span style="color: #94BFF3;">(</span>value<span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span>;
  Append<span style="color: #b58900;">(</span>e.get<span style="color: #94BFF3;">()</span><span style="color: #b58900;">)</span>;
  m_entries<span style="color: #b58900;">[</span>key<span style="color: #b58900;">]</span> = e;

  <span style="color: #b58900; font-weight: bold;">return</span> e;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Given everything we've learned, let's critique this code.
</p>

<p>
We can see that it's inserting a KV pair into a cache with a least-recently-used
eviction strategy. There is a map that owns a shared_ptr, and that shared_ptr is
also weakly-referenced from a deque (see Append call)?
</p>

<ul>
<li>use pass-by-value to simplify handling</li>
<li>use <code>make_shared</code></li>

<li>use <code>operator[]</code> - default construct shared_ptr + assign</li>
<li>extra shared_ptr ref</li>

</ul>

</aside>

</section>
<section id="slide-org4639bcd">
<h3 id="org4639bcd">Exhibit H</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #5f127b;">// </span><span style="color: #5f127b;">Insert the new value.</span>
<span style="color: #b58900; font-weight: bold;">auto</span> <span style="color: #2aa198;">[</span>it, _<span style="color: #2aa198;">]</span> =
  m_entries.emplace<span style="color: #2aa198;">(</span>key, with_result_of<span style="color: #b58900;">(</span><span style="color: #94BFF3;">[</span>&amp;<span style="color: #94BFF3;">]</span> <span style="color: #94BFF3;">{</span>
    <span style="color: #b58900; font-weight: bold;">return</span> <span style="color: #859900;">std</span>::make_shared<span style="color: #dc322f;">&lt;</span>Entry<span style="color: #dc322f;">&gt;(</span>key, <span style="color: #859900;">std</span>::move<span style="color: #859900;">(</span>value<span style="color: #859900;">)</span><span style="color: #dc322f;">)</span>; <span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span>;
Append<span style="color: #b58900;">(</span>it-&gt;second.get<span style="color: #94BFF3;">()</span><span style="color: #b58900;">)</span>;
<span style="color: #b58900; font-weight: bold;">return</span> it-&gt;second;
</pre>
</div>

<aside class="notes">
<ul>
<li>m_entries can still be any associative container (no loss of generality)</li>
<li>save 2 shared_ptr reference updates (plus check on assign of the default-constructed one)</li>

</ul>

<p>
We use with_result_of here to construct the shared_ptr directly in place.
</p>

</aside>

</section>
<section id="slide-org74e222e">
<h3 id="org74e222e">Recommendations</h3>
<p>
Yes, C++ is complicated.
</p>

<ul>
<li>Initialization: consider <code>for_each_n_args</code></li>
<li>You can use <code>insert</code> with <code>make_pair</code> and implicit construction
<ul>
<li>But don't use call-site explicit construction</li>

</ul></li>
<li>Use <code>emplace</code> but beware of explicit construction</li>
<li>Use <code>piecewise_construct</code> for other than single-arg construction</li>
<li>Try to avoid <code>operator[]</code></li>
<li>Adopt <code>insert_or_assign</code> when it's available</li>
<li>Consider <code>with_result_of</code></li>

</ul>

</section>
</section>
<section>
<section id="slide-org720bfe3">
<h2 id="org720bfe3">6. Putting stuff into other things</h2>
<p>
Like <code>optional</code>, <code>variant</code>, <code>any</code>.
</p>

<div class='vertspace2'></div>
<blockquote nil><p>&quot;There's more depends on this than on the value.&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>The Merchant of Venice</em></div></blockquote>

</section>
<section id="slide-org0c724db">
<h3 id="org0c724db"><code>optional</code> and friends</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">constexpr</span> <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">optional</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">in_place_t</span>, <span style="color: #268bd2;">Args</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span> <span style="color: #268bd2;">T</span>, <span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">constexpr</span> <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">variant</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">in_place_type_t</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">T</span><span style="color: #b58900;">&gt;</span>, <span style="color: #268bd2;">Args</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">size_t</span> <span style="color: #cb4b16;">I</span>, <span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">constexpr</span> <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">variant</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">in_place_index_t</span><span style="color: #b58900;">&lt;</span>I<span style="color: #b58900;">&gt;</span>, <span style="color: #268bd2;">Args</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span> <span style="color: #268bd2;">ValueType</span>, <span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">any</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">in_place_type_t</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">ValueType</span><span style="color: #b58900;">&gt;</span>, <span style="color: #268bd2;">Args</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
All these new vocabulary types have constructors that take <code>in_place</code> tag
arguments. They work similarly to <code>piecewise_construct</code> but they're only
constructing one thing.
</p>

</aside>

</section>
<section id="slide-org5c974ca">
<h3 id="org5c974ca"><code>optional</code> construction</h3>
<p>
implicit constructor
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span> = Foo<span style="color: #2aa198;">{}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (naive method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span> = S<span style="color: #2aa198;">{</span><span style="color: #859900;">1</span><span style="color: #2aa198;">}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (in-place method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span><span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::in_place, <span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
In the first case, it's fine: just one in-place construct.
</p>

<p>
In the second case, we have an <code>explicit</code> constructor. So if we use this style,
we get a construct and a move.
</p>

<p>
The third case is the way to go for in-place construction. It can also be used
with an implicit constructor of course.
</p>

</aside>

</section>
<section id="slide-orge139628">
<h3 id="orge139628"><code>optional</code> assignment</h3>
<p>
implicit constructor
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span>;
opt = Foo<span style="color: #2aa198;">{}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (naive method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span>;
opt = S<span style="color: #2aa198;">{</span><span style="color: #859900;">1</span><span style="color: #2aa198;">}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (in-place method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span>;
opt.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Similar story here.
</p>

</aside>

</section>
<section id="slide-orgaee6333">
<h3 id="orgaee6333"><code>optional</code> recommendations</h3>
<ul>
<li>use the <code>in_place_t</code> constructor</li>
<li>avoid <code>explicit</code> construction</li>
<li>use <code>emplace</code> for assignment</li>

</ul>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span><span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::in_place, <span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
opt.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">2</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
You'll never go wrong with these.
</p>

<p>
Again we could use the with_result_of to in-place construct the result of a
function call.
</p>

</aside>

</section>
<section id="slide-org630b6e8">
<h3 id="org630b6e8"><code>variant</code> construction</h3>
<p>
implicit constructor
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = Foo<span style="color: #2aa198;">{}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (naive method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = S<span style="color: #2aa198;">{</span><span style="color: #859900;">1</span><span style="color: #2aa198;">}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (oops method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = <span style="color: #859900;">1</span>;
</pre>
</div>

<aside class="notes">
<p>
Similar story as <code>optional</code>.
</p>

<p>
But there is the potential for a bug with the <code>explicit</code> constructor. What makes
this somewhat likely is that it might be the case that someone makes a
constructor explicit later on.
</p>

</aside>

</section>
<section id="slide-orgf56e8fb">
<h3 id="orgf56e8fb"><code>variant</code> construction</h3>
<p>
Recommendation: use either of these two constructions.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">v</span><span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">in_place_type</span><span style="color: #b58900;">&lt;</span>S<span style="color: #b58900;">&gt;</span>, <span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">v</span><span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">in_place_index</span><span style="color: #b58900;">&lt;</span><span style="color: #859900;">1</span><span style="color: #b58900;">&gt;</span>, <span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
I would generally prefer the first except in cases where the same type occurs in
multiple places in the <code>variant</code>, which is relatively rarer.
</p>

</aside>

</section>
<section id="slide-org7d14008">
<h3 id="org7d14008"><code>variant</code> assignment</h3>
<p>
Similar story to construction.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;

v = Foo<span style="color: #2aa198;">{}</span>; <span style="color: #5f127b;">// </span><span style="color: #5f127b;">fine</span>
v = S<span style="color: #2aa198;">{</span><span style="color: #859900;">1</span><span style="color: #2aa198;">}</span>;  <span style="color: #5f127b;">// </span><span style="color: #5f127b;">constructs a temporary</span>
v = <span style="color: #859900;">1</span>;     <span style="color: #5f127b;">// </span><span style="color: #5f127b;">oops</span>
</pre>
</div>

</section>
<section id="slide-org3a27d84">
<h3 id="org3a27d84"><code>variant</code> danger!</h3>
<p>
Implicitly-typed <code>variant</code> construction/assignment can be dangerous.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">int</span> <span style="color: #2aa198;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">bool</span>, <span style="color: #859900;">std</span>::string<span style="color: #b58900;">&gt;</span> <span style="color: #cb4b16;">v</span> = <span style="color: #D01A4E;">"Hello"</span>;
  <span style="color: #859900;">std</span>::cout &lt;&lt; <span style="color: #D01A4E;">"index is "</span> &lt;&lt; v.index<span style="color: #b58900;">()</span> &lt;&lt; <span style="color: #D01A4E;">'</span><span style="color: #5f127b; font-weight: bold;">\</span><span style="color: #b58900; font-weight: bold;">n</span><span style="color: #D01A4E;">'</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
What does this output?
</p>

<aside class="notes">
<p>
Avoid implicit type conversions. They're dangerous. The first possible one will apply.
</p>

</aside>

</section>
<section id="slide-org57ff111">
<h3 id="org57ff111">Safe, efficient <code>variant</code> assignment</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #5f127b;">// </span><span style="color: #5f127b;">template &lt;class T, class... Args&gt;</span>
<span style="color: #5f127b;">// </span><span style="color: #5f127b;">T&amp; emplace(Args&amp;&amp;... args);</span>
v.emplace<span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;(</span><span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;  <span style="color: #5f127b;">// </span><span style="color: #5f127b;">S{1}</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #5f127b;">// </span><span style="color: #5f127b;">template &lt;size_t I, class... Args&gt;</span>
<span style="color: #5f127b;">// </span><span style="color: #5f127b;">variant_alternative_t&lt;I, variant&gt;&amp; emplace(Args&amp;&amp;... args);</span>
v.emplace<span style="color: #2aa198;">&lt;</span><span style="color: #859900;">1</span><span style="color: #2aa198;">&gt;(</span><span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;  <span style="color: #5f127b;">// </span><span style="color: #5f127b;">S{1}</span>
</pre>
</div>

</section>
<section id="slide-org363c6c0">
<h3 id="org363c6c0"><code>variant</code> recommendations</h3>
<ul>
<li>always be explicit about types</li>
<li>use <code>in_place_type</code> or <code>in_place_index</code> constructors</li>
<li>use <code>emplace&lt;T&gt;</code> or <code>emplace&lt;I&gt;</code></li>
<li>avoid <code>operator=</code> (except actual <code>variant</code>-to-<code>variant</code>)</li>

</ul>

<aside class="notes">
<p>
Obviously <code>operator=</code> is used implicitly by the compiler.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgbd7b450">
<h2 id="orgbd7b450">7. Final Guidelines and Recommendations</h2>
<div class='vertspace2'></div>
<blockquote nil><p>&quot;Share the advice betwixt you; if both gain all,<br>The gift doth stretch itself as 'tis receiv'd,<br>And is enough for both.&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>All's Well That Ends Well</em></div></blockquote>

</section>
<section id="slide-org6d26350">
<h3 id="org6d26350">Recommendations</h3>
<p>
Think about copies and moves.
</p>

<p>
Moves aren't free, and may not be cheap.
</p>

<p>
Usually, in-place construction is preferable. And it is nearly always possible.
</p>

<p>
Know how RVO works, and check that the compiler is doing it when you think it is.
</p>

<p>
Beware <code>initializer_list</code>.
</p>

<p>
Feel free to ping me with any questions, any time.
</p>
</section>
</section>
</div>
</div>
<script src="../reveal.js/lib/js/head.min.js"></script>
<script src="../reveal.js/js/reveal.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,

overview: true,
width: 1600,
height: 900,
margin: 0.10,
minScale: 0.50,
maxScale: 2.50,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'none', // see README of reveal.js for options
transitionSpeed: 'default',

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]

});
</script>
</body>
</html>
