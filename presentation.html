<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Everyday Efficiency: In-place Construction</title>
<meta name="author" content="Ben Deane"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="../reveal.js/css/theme/blood.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h2>Everyday Efficiency:</h2><h2>In-place Construction</h2><h3>Back to Basics?</h3><div class='vertspace2'></div><blockquote nil><p>&quot;Make no collection of it: let him show<br>His skill is in the construction.&quot;</p><div></div><div class='author'>-- William Shakespeare, <em>Cymbeline</em></div></blockquote><div class='vertspace3'></div><h3>Ben Deane / <a href=\"http://twitter.com/ben_deane\">@ben_deane</a></h3><h4>September 19 2018</h4>
</section>
<script type="text/javascript" src="./rison.js"></script>
<script type="text/javascript" src="./presentation.js"></script>

<section>
<section id="slide-org5d2237a">
<h2 id="org5d2237a">Get Ready</h2>
<div class='vertspace2'></div>

<ol>
<li>What happens when we <code>move</code> something?</li>
<li>Copy elision (RVO)</li>
<li>Putting stuff into a <code>vector</code></li>
<li><code>initializer_list</code></li>
<li>Putting stuff into a <code>map</code></li>
<li>Putting stuff into other things</li>
<li>Final thoughts</li>

</ol>

<aside class="notes">
<p>
I developed this talk in response to code I saw in real-life codebases. The code
was often written by people who knew C++ and were trying to take advantage of
modern features like move semantics and perfect forwarding, but were doing so in
a way that was sometimes ineffective and sometimes looked like "magical
thinking". Basically they were trying to do the efficient thing, but so often
failing to. So I made this talk to try to help.
</p>

<p>
Who here is using C++20? 17? 14? 11? pre-11?
</p>

<p>
There is something here for everyone, even if you're still on a compiler without
move semantics.
</p>

<p>
For each slide with code, there will be a star in the corner indicating which
version of C++ it applies to.
</p>

<p>
I will be asking a lot of questions.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org13e6762">
<h2 id="org13e6762">Preliminaries</h2>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #94BFF3;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #D01A4E;">cstdio</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">Arg</span> <span style="color: #2aa198;">{}</span>;

<span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">S</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #2aa198;">S</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Default construct"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>
  <span style="color: #2aa198;">S</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">Arg</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Value construct"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>
  <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">S</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Explicit value construct (1)"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>
  <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">S</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span>, <span style="color: #268bd2;">int</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Explicit value construct (2)"</span><span style="color: #94BFF3;">)</span>;<span style="color: #b58900;">}</span>
  ~<span style="color: #2aa198;">S</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Destruct"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>
  <span style="color: #2aa198;">S</span><span style="color: #b58900;">(</span><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">S</span>&amp;<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Copy construct"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>
  <span style="color: #2aa198;">S</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">S</span>&amp;&amp;<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Move construct"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>
  <span style="color: #268bd2;">S</span>&amp; <span style="color: #b58900; font-weight: bold;">operator</span><span style="color: #2aa198;">=</span><span style="color: #b58900;">(</span><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">S</span>&amp;<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Copy assign"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900; font-weight: bold;">return</span> *<span style="color: #b58900; font-weight: bold;">this</span>; <span style="color: #b58900;">}</span>
  <span style="color: #268bd2;">S</span>&amp; <span style="color: #b58900; font-weight: bold;">operator</span><span style="color: #2aa198;">=</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">S</span>&amp;&amp;<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Move assign"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900; font-weight: bold;">return</span> *<span style="color: #b58900; font-weight: bold;">this</span>; <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;

<span style="color: #268bd2;">int</span> <span style="color: #2aa198;">main</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<aside class="notes">
<p>
You're going to see a lot of this later in the talk, when we examine how various
snippets of code behave.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org2707f2a">
<h2 id="org2707f2a">1. What happens when we <code>move</code> something?</h2>
<div class='vertspace2'></div>
<blockquote nil><p>&quot;Mov'd! In good time! Let him that mov'd you hither<br>remove you hence.&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>The Taming of the Shrew</em></div></blockquote>
<div class='vertspace2'></div>
<p>
Are moves cheap or not?
</p>

</section>
<section id="slide-org5a76db4">
<h3 id="org5a76db4">A moved-from <code>vector</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v1</span> = <span style="color: #2aa198;">{</span><span style="color: #859900;">1</span>, <span style="color: #859900;">2</span>, <span style="color: #859900;">3</span>, <span style="color: #859900;">4</span>, <span style="color: #859900;">5</span><span style="color: #2aa198;">}</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v2</span> = <span style="color: #859900;">std</span>::move<span style="color: #2aa198;">(</span>v1<span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
What's in <code>v1</code> after the <code>move</code>?
</p>

<aside class="notes">
<p>
The standard says "valid but unspecified". We know that we're allowed to destroy
it, because for things to be otherwise would be a nonsense. <code>v1</code> <span class="underline">will</span> be
destroyed like any other C++ object when it goes out of scope.
</p>

<p>
Here's where we deviate from the standard. How is <code>vector</code> implemented,
basically? (pointer-to-buffer, size, capacity). On destruction, what must it do?
</p>

</aside>

</section>
<section id="slide-orgd2abd03">
<h3 id="orgd2abd03">A moved-from <code>vector</code></h3>
<p>
It <i>must</i> be destroyable.
</p>

<p>
What is sufficient? What is likely?
</p>
<ul>
<li>begin pointer is null?</li>
<li>size is zero?</li>
<li>capacity is zero?</li>

</ul>

<aside class="notes">
<p>
I don't advocate guessing what the standard library implementation is doing, or
relying on implementation, but it's worth thinking about these types of
questions to inform outselves.
</p>

</aside>

</section>
<section id="slide-org7269115">
<h3 id="org7269115">Exhibit A</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">void</span> <span style="color: #859900;">WebClient</span>::<span style="color: #2aa198;">ProcessServerResponse</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">HttpMessage</span> <span style="color: #cb4b16;">message</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">some stuff...</span>

  m_result.body = <span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>m_bodyBuffer<span style="color: #b58900;">)</span>;
  m_result.headers = <span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>message<span style="color: #b58900;">)</span>.headers;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
This code assumes that it's safe to do whatever comes later to a moved-from <code>vector</code>.
</p>

<aside class="notes">
<p>
<code>m_readBuffer</code> here is a member variable that's used to accumulate the text of
the server response.
</p>

<p>
This variable gets reused on a later response. This code is assuming that it's
safe to reuse after move. In this case, it is, because the way it's used is by
appending elements.
</p>

</aside>

</section>
<section id="slide-org8d70b48">
<h3 id="org8d70b48">Now consider:</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s1</span> = <span style="color: #D01A4E;">"Greetings, planet"</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s2</span> = <span style="color: #859900;">std</span>::move<span style="color: #2aa198;">(</span>s1<span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
What's the moved-from state of <code>s1</code>?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s3</span> = <span style="color: #D01A4E;">"Hello, world"</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s4</span> = <span style="color: #859900;">std</span>::move<span style="color: #2aa198;">(</span>s3<span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
What's the moved-from state of <code>s3</code>?
</p>

<aside class="notes">
<p>
What is the state of s1 after the move? Same as the vector case basically.
</p>

<p>
But the first example is small-string optimized. What happens when you move from
a small string? You have to copy.
</p>

<p>
What is the state of s1 in the first case? It happens that all major
implementations will set the size to zero on a move, even when in the small
string buffer. So it's actually ever so slightly <i>slower</i> than a copy.
</p>

<p>
If you're lucky, the optimizer can help you out and spot dead stores&#x2026;
</p>

<p>
Bloomberg's STL does not clear a moved-from SSO string.
</p>

</aside>

</section>
<section id="slide-orgc9b12a2">
<h3 id="orgc9b12a2">Observation</h3>
<div class='vertspace2'></div>
<p>
Moving from a <code>string</code> <i>usually isn't any faster</i> than copying from it.
</p>

<div class='vertspace2'></div>
<p>
(If you doubt this, ask yourself why the small string optimization exists in the
first place.)
</p>

<p>
Moves <i>only</i> matter for objects on the heap.
</p>

<p>
<a href="http://quick-bench.com/eb54Wv8Bmvr08frpgtqFOIxQqa4">http://quick-bench.com/eb54Wv8Bmvr08frpgtqFOIxQqa4</a>
</p>

<aside class="notes">
<p>
And as noted, it may be technically slower.
</p>

</aside>

</section>
<section id="slide-orge1a6f13">
<h3 id="orge1a6f13">Exhibit B</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">void</span> <span style="color: #859900;">Context</span>::<span style="color: #2aa198;">Trigger</span><span style="color: #2aa198;">(</span><span style="color: #ff00ff;">/* </span><span style="color: #ff00ff;">some args */</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">ResponseCallback</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">function</span><span style="color: #b58900;">&lt;</span><span style="color: #ff00ff;">/* </span><span style="color: #ff00ff;">some signature */</span><span style="color: #b58900;">&gt;</span>;

  <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">Make sure that it will trigger only once.</span>
  <span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">ResponseCallback</span> <span style="color: #cb4b16;">callback</span> = <span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>m_responseCallback<span style="color: #b58900;">)</span>;
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>callback<span style="color: #b58900;">)</span>
  <span style="color: #b58900;">{</span>
    callback<span style="color: #94BFF3;">(</span><span style="color: #ff00ff;">/* </span><span style="color: #ff00ff;">args */</span><span style="color: #94BFF3;">)</span>;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
<p>
Is this comment telling the truth?
</p>

<aside class="notes">
<p>
Playing with fire. The comment is misleading. We're relying on implementation.
</p>

<p>
Function has a small buffer optimization just like string. There's no reason for
function to be null after a move.
</p>

<p>
Think back to the vector case now: what happens if the container is replaced
with a small-buffer optimizable container?
</p>

</aside>

</section>
<section id="slide-org8a85911">
<h3 id="org8a85911">Guideline</h3>
<p>
Don't assume "containers" are empty after a <code>move</code>.
</p>

<p>
If you need to be sure, use <code>exchange</code>.
</p>

<div class="org-src-container">

<pre  class="src src-c++">m_result.extra = <span style="color: #859900;">std</span>::exchange<span style="color: #2aa198;">(</span>m_readBuffer, <span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">ResponseCallback</span> <span style="color: #cb4b16;">cb</span> = <span style="color: #859900;">std</span>::exchange<span style="color: #2aa198;">(</span>m_responseCallback, <span style="color: #859900;">nullptr</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
This makes your code safe for future small-buffer optimizations.
</p>

<aside class="notes">
<p>
<code>std::exchange</code> is an underappreciated function. It's C++14 but if you're only
on C++11 you can easily provide your own version.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orged89c44">
<h2 id="orged89c44">2. Copy Elision</h2>
<div class='vertspace2'></div>
<blockquote nil><p>&quot;If you will, lead these graces to the grave<br>And leave the world no copy.&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>Twelfth Night, or What You Will</em></div></blockquote>


</section>
<section id="slide-orgef2a7d1">
<h3 id="orgef2a7d1">Copy Elision, aka RVO</h3>
<div class='vertspace2'></div>
<p>
Q. What is the Return Value Optimization?
</p>
<div class='vertspace2'></div>
<p>
A. Perhaps the most important optimization the compiler does.
</p>
<div class='vertspace2'></div>
<p>
[<a href="http://eel.is/c++draft/class.copy.elision">class.copy.elision</a>]
</p>

<aside class="notes">
<p>
When we talk about in-place construction, the return value optimization is a
good starting point.
</p>

<p>
This is such an important optimization that all competitive compilers have done
it for decades. And it's right on the border of optimizations your compiler will
do for you whether or not you ask for it.
</p>

<p>
If you look for it in the standard, it's called class.copy.elision. But that's
not the whole story, because that deals with so-called NAMED RVO. There is also
elision of temporaries or UNNAMED RVO which is often much more reliable.
</p>

</aside>

</section>
<section id="slide-org56ee97c">
<h3 id="org56ee97c">RVO in pictures</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo_singleslide.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<aside class="notes">
<p>
When a function is called, the caller passes an extra argument: the address of
the return value, which is in the caller's stack frame. So that when the callee
returns, it can copy the returned value to that address.
</p>

<p>
The return value optimization is where the callee can construct the result
directly in the space reserved in the caller's stack frame. There is no need for
the callee to have space in its stack frame, or incur the copy on return.
</p>

</aside>

</section>
<section id="slide-org24675b3">
<h3 id="org24675b3">When can RVO not apply?</h3>
<p>
RVO Rules: what is returned has to be either:
</p>

<ul>
<li>a temporary (prvalue) - guaranteed in C++17</li>
<li>the name of a stack variable</li>

</ul>

<aside class="notes">
<p>
So when it comes to thinking about whether or not RVO can happen, we have to
think about two distinct things:
</p>

<ul>
<li>is it allowed by the standard?</li>
<li>is it possible?</li>

</ul>

<p>
The standard rules are pretty simple. Either URVO or NRVO.
</p>

</aside>

</section>
<section id="slide-org86f8fda">
<h3 id="org86f8fda">When can RVO not apply?</h3>
<p>
RVO Ability: sometimes, the callee <i>can't</i> construct the object in-place.
</p>

<ul>
<li>if there is no opportunity to</li>
<li>if it's not of the right type</li>
<li>if the callee doesn't know enough</li>

</ul>

<aside class="notes">
<p>
More interesting is to think about when it's possible.
</p>

<p>
Function arguments - that are passed to you already-constructed - can't be RVOed
on return. But you can move them.
</p>

<p>
You have to know at construction time that you're going to be returning that
variable in order to RVO it.
</p>

</aside>

</section>
<section id="slide-org4ccb545">
<h3 id="org4ccb545">No RVO because no opportunity</h3>
<p>
You can't RVO a variable if you didn't get the chance to construct it in the
first place.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #2aa198;">sad_function</span><span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  s += <span style="color: #D01A4E;">"No RVO for you!"</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> s;
<span style="color: #2aa198;">}</span>
</pre>
</div>
<p>
But the compiler will still move it. (Since C++11)
</p>

<aside class="notes">
<p>
C++11 mandates that if you can't do the RVO, you must try to move and only copy
as a last resort.
</p>

</aside>

</section>
<section id="slide-org6466d37">
<h3 id="org6466d37">No RVO because wrong type</h3>
<p>
An rvalue-ref is not the same type.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #2aa198;">sad_function</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s</span> = <span style="color: #D01A4E;">"No RVO for you!"</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> <span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
Don't <code>return std::move(x)</code> in most cases - you will get a move when you didn't
need anything!
</p>

<aside class="notes">
<p>
There are legitimate cases for returning an rvalue reference. e.g. value
wrappers with ref-qualified get functions.
</p>

<p>
But there are whole other talks on this.
</p>

</aside>

</section>
<section id="slide-orge328622">
<h3 id="orge328622">No RVO because not enough info</h3>
<p>
It has to be decidable at construction time.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #2aa198;">undecided_function</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">happy</span> = <span style="color: #D01A4E;">"Hooray"</span>;
  <span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">sad</span> = <span style="color: #D01A4E;">"Boo hoo"</span>;

  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>getHappiness<span style="color: #94BFF3;">()</span> &gt; <span style="color: #859900;">0.5</span><span style="color: #b58900;">)</span>
    <span style="color: #b58900; font-weight: bold;">return</span> happy;
  <span style="color: #b58900; font-weight: bold;">else</span>
    <span style="color: #b58900; font-weight: bold;">return</span> sad;
<span style="color: #2aa198;">}</span>

</pre>
</div>
<p>
Again, return value will still be moved.
</p>

</section>
<section id="slide-org2dd2856">
<h3 id="org2dd2856">Why is RVO so important?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">PhoneBook</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string, <span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span>;

<span style="color: #268bd2;">PhoneBook</span> <span style="color: #2aa198;">build_phonebook</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">PhoneBook</span> <span style="color: #cb4b16;">pb</span>;
  pb.insert<span style="color: #b58900;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Jenny"</span>, <span style="color: #859900;">8675309</span><span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> pb;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
Because <i>moves aren't necessarily cheap</i>.
</p>

<aside class="notes">
<p>
Because move isn't necessarily cheap.
</p>

<p>
Imagine you have this code, and you don't have RVO (which you do here).
</p>

<p>
Imagine this is using Microsoft's STL.
</p>

</aside>

</section>
<section id="slide-orgfb1317d">
<h3 id="orgfb1317d">Why is RVO so important?</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><img src="./map_move.png" alt="map_move.png" />
</p>
</div>

<aside class="notes">
<p>
This is an explanation from Billy O'Neal about why <code>std::map</code> has <code>noexcept</code>
move assignment, but move constructor is <i>not</i> <code>noexcept</code>.
</p>

<p>
Microsoft's current ABI uses stable sentinel nodes. This means a move construct
of a node-based container must allocate. A move assign need not.
</p>

<p>
Practically the number one rule of performance is: you don't want to incur more
allocations that you need to.
</p>

<p>
So even when objects are on the heap, moves might not be cheap.
</p>

</aside>

</section>
<section id="slide-org8bc1a87">
<h3 id="org8bc1a87">Quiz time</h3>
<p>
Wake up!
</p>

<p>
And tell me if the upcoming code snippets will activate RVO.
</p>

</section>
<section id="slide-org92aade7">
<h3 id="org92aade7">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes.
</p>

<aside class="notes">
<p>
Yes. You're allowed to cv-qualify return types and RVO still works.
</p>

<p>
But don't do this. The compiler ignores const-qualified builtin types anyway.
</p>

</aside>

</section>
<section id="slide-org9cfd2e9">
<h3 id="org9cfd2e9">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span>
    <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
  <span style="color: #b58900; font-weight: bold;">else</span>
    <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes. Even in debug builds.
</p>

<aside class="notes">
<p>
Yes. This is URVO, and works pretty reliably even in debug builds.
</p>

</aside>

</section>
<section id="slide-org41fc55a">
<h3 id="org41fc55a">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span>, <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span>
    s = S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> s;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
No (no opportunity).
</p>

<aside class="notes">
<p>
No - can't RVO a function parameter. It will move though.
</p>

</aside>

</section>
<section id="slide-orga303187">
<h3 id="orga303187">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">get_S</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>; <span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span>
    <span style="color: #b58900; font-weight: bold;">return</span> get_S<span style="color: #b58900;">()</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes (can elide multiple copies).
</p>

<aside class="notes">
<p>
Yes. This RVOs.
RVO is allowed to elide multiple copies down the callstack.
</p>

</aside>

</section>
<section id="slide-org266daae">
<h3 id="org266daae">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span>
  <span style="color: #b58900;">{</span>
    <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span><span style="color: #94BFF3;">{</span><span style="color: #859900;">1</span><span style="color: #94BFF3;">}</span>;
    <span style="color: #b58900; font-weight: bold;">return</span> s;
  <span style="color: #b58900;">}</span>
  <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes (Clang), no (MSVC/GCC).
</p>

<aside class="notes">
<p>
There's nothing stopping it&#x2026; but only Clang successfully RVO's this.
</p>

</aside>

</section>
<section id="slide-orge05c048">
<h3 id="orge05c048">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span><span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span>
    <span style="color: #b58900; font-weight: bold;">return</span> s;
  <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
No. Possibly in future?
</p>

<aside class="notes">
<p>
We hoisted the S out of the condition.
</p>

<p>
No RVO here (a sufficiently smart compiler might be able to&#x2026;)
</p>

<p>
It still moves.
</p>

</aside>

</section>
<section id="slide-org8a7a33a">
<h3 id="org8a7a33a">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span><span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> b ? s : S<span style="color: #b58900;">{</span><span style="color: #859900;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
No. (Against the rules - not "the name of a stack variable".)
</p>

<aside class="notes">
<p>
No RVO. We're not naming a variable.
Will it still move? No.
</p>

<p>
We're not naming a variable. And it's not a prvalue - the conditional operator
produces an lvalue reference here. We have to copy.
</p>

<p>
This is perhaps a semi-common pattern that defeats RVO!
</p>

</aside>

</section>
<section id="slide-org987aa33">
<h3 id="org987aa33">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">get_S</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>; <span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> b ? get_S<span style="color: #b58900;">()</span> : S<span style="color: #b58900;">{</span><span style="color: #859900;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes. (Returning temporary.)
</p>

<aside class="notes">
<p>
This RVOs. This time the conditional operator produces a prvalue because both of
its operands are prvalues.
</p>

</aside>

</section>
<section id="slide-org6118018">
<h3 id="org6118018">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span><span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
  s = S<span style="color: #b58900;">{</span><span style="color: #859900;">2</span><span style="color: #b58900;">}</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> s;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes.
</p>

<aside class="notes">
<p>
Yep. Plain NRVO.
</p>

</aside>

</section>
<section id="slide-orgf1c49fa">
<h3 id="orgf1c49fa">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span><span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> <span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes (Clang/MSVC), no (GCC).
</p>
<p class="fragment (appear)">
<a href="http://eel.is/c++draft/class.copy.elision#3.1" class="fragment (appear)">class.copy.elision &sect; 3.1</a>
</p>

<aside class="notes">
<p>
The standard explicitly allows this &#x2013; (possibly parenthesized) <i>id-expression</i>.
</p>

<p>
However&#x2026; there seems to be a bug in GCC where it doesn't RVO this. MSVC does
and Clang does.
</p>

<p>
Technically GCC is still adhering to the standard, because it's not required to
RVO. It does in C++11 mode, just not in later modes.
</p>

</aside>

</section>
<section id="slide-org233bcf5">
<h3 id="org233bcf5">Finally, what's the return value?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">P</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">constexpr</span> <span style="color: #2aa198;">P</span><span style="color: #b58900;">()</span> : x<span style="color: #b58900;">{</span><span style="color: #859900;">0</span><span style="color: #b58900;">}</span> <span style="color: #b58900;">{}</span>
  <span style="color: #b58900; font-weight: bold;">constexpr</span> <span style="color: #2aa198;">P</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">P</span>&amp;&amp;<span style="color: #b58900;">)</span> : x<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span> <span style="color: #b58900;">{}</span>
  <span style="color: #268bd2;">int</span> <span style="color: #cb4b16;">x</span>;
<span style="color: #2aa198;">}</span>;

<span style="color: #b58900; font-weight: bold;">constexpr</span> <span style="color: #b58900; font-weight: bold;">auto</span> <span style="color: #2aa198;">will_this_rvo</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">P</span> <span style="color: #cb4b16;">p</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> p;
<span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">int</span> <span style="color: #2aa198;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #b58900; font-weight: bold;">auto</span> p = will_this_rvo<span style="color: #b58900;">()</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> p.x;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<aside class="notes">
<p>
<code>constexpr</code> prevents named RVO&#x2026; but compilers differ.
</p>

<p>
GCC will not RVO this even if <code>p</code> is not <code>const</code>. (Is this a bug?)
</p>

<p>
Clang RVOs this if not <code>const</code>.
</p>

</aside>

</section>
<section id="slide-org8d8b9d9">
<h3 id="org8d8b9d9">Exhibit C</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">unsigned</span> <span style="color: #268bd2;">long</span> <span style="color: #268bd2;">long</span> <span style="color: #2aa198;">Time</span><span style="color: #2aa198;">()</span> <span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #b58900; font-weight: bold;">override</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">auto</span> <span style="color: #cb4b16;">ts</span> = <span style="color: #859900;">std</span>::get<span style="color: #b58900;">&lt;</span><span style="color: #859900;">1</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">std</span>::move<span style="color: #94BFF3;">(</span><span style="color: #859900;">Base</span>::metrics_-&gt;GetDataPointAndTime<span style="color: #dc322f;">()</span><span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> ts;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
Superfluous (potentially dangerous?) call to <code>std::move</code>.
</p>

<p>
NRVO is not guaranteed in debug mode. Better:
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">unsigned</span> <span style="color: #268bd2;">long</span> <span style="color: #268bd2;">long</span> <span style="color: #2aa198;">Time</span><span style="color: #2aa198;">()</span> <span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #b58900; font-weight: bold;">override</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> <span style="color: #859900;">std</span>::get<span style="color: #b58900;">&lt;</span><span style="color: #859900;">1</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">Base</span>::metrics_-&gt;GetDataPointAndTime<span style="color: #94BFF3;">()</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Just an integral type here, so no big deal. But if it gets changed, or this
pattern gets copied&#x2026;
</p>

</aside>

</section>
<section id="slide-org58f6c21">
<h3 id="org58f6c21">Interlude</h3>
<div class='vertspace2'></div>

<p>
Before we continue&#x2026;
</p>

<aside class="notes">
<p>
A brief respite&#x2026;
</p>

<p>
Here's where we start to get into the nitty-gritty.
</p>

<p>
Fair warning: there will probably come a time in this talk when you think, "why
is C++ this complicated?" (If this hasn't already crossed your mind.)
</p>

<p>
But for now, let's press on&#x2026;
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgb3e3419">
<h2 id="orgb3e3419">3. Putting stuff into a <code>vector</code></h2>
<p>
Should you use <code>push_back</code> or should you use <code>emplace_back</code>?
</p>

<p>
How should you use them?
</p>

<div class='vertspace2'></div>
<blockquote nil><p>&quot;Didst thou not say, when I did push thee back --<br>Which was when I perceived thee -- that thou camest<br>From good descending?&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>Pericles</em></div></blockquote>

<aside class="notes">
<p>
Let's avoid the tendency to think of <code>emplace_back</code> as magically being faster
than <code>push_back</code>.
</p>

</aside>

</section>
<section id="slide-org07cd7b6">
<h3 id="org07cd7b6"><code>push_back</code> and <code>emplace_back</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">void</span> <span style="color: #2aa198;">push_back</span><span style="color: #2aa198;">(</span><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">T</span>&amp; <span style="color: #cb4b16;">x</span><span style="color: #2aa198;">)</span>;
<span style="color: #268bd2;">void</span> <span style="color: #2aa198;">push_back</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">T</span>&amp;&amp; <span style="color: #cb4b16;">x</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">reference</span> <span style="color: #2aa198;">emplace_back</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">Args</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
These are the signatures provided by <code>push_back</code> and <code>emplace_back</code>. Notice that
<code>push_back</code> is overloaded on rvalue references.
</p>

<p>
Until C++17, <code>emplace_back</code> returns <code>void</code>.
</p>

</aside>

</section>
<section id="slide-orgd427ace">
<h3 id="orgd427ace">Example 1</h3>
<p>
What's the difference here?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s</span>;
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">...</span>

v.push_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
There is no difference.
</p>

<p>
Well there is one difference&#x2026; if you're on C++17 or later.
</p>

</aside>

</section>
<section id="slide-orgc376232">
<h3 id="orgc376232">Example 1.1</h3>
<p>
What's the difference here?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s</span>;
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">...</span>

v.push_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span>&amp; <span style="color: #cb4b16;">last_s</span> = v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
If we want to capture a reference to the thing that was pushed, we can use
<code>emplace_back</code>.
</p>

</aside>

</section>
<section id="slide-orgff01ed9">
<h3 id="orgff01ed9">Example 2</h3>
<p>
What's the difference here?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">char</span>* <span style="color: #cb4b16;">s</span> = <span style="color: #D01A4E;">"Hello"</span>;
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">...</span>

v.push_back<span style="color: #2aa198;">(</span>s<span style="color: #2aa198;">)</span>;
v.emplace_back<span style="color: #2aa198;">(</span>s<span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
This is the real proper usage of <code>emplace_back</code>.
</p>

<p>
<code>push_back</code> constructs a temporary then moves it.
</p>

<p>
<code>emplace_back</code> constructs directly in place.
</p>

<p>
Remember, for string, a move is usually as expensive as a copy.
</p>

</aside>

</section>
<section id="slide-orgad68e83">
<h3 id="orgad68e83">Example 2.1</h3>
<p>
Default in-place construct.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">first default-construct in the vector</span>
<span style="color: #268bd2;">S</span>&amp; <span style="color: #cb4b16;">s</span> = v.emplace_back<span style="color: #2aa198;">()</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">now mutate s</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">...</span>
</pre>
</div>

<p>
<code>emplace_back</code> takes a parameter pack. Parameter packs can be empty.
</p>

<aside class="notes">
<p>
In the upcoming slides, we're going to be using the <code>S</code> struct from the top of
the talk.
</p>

<p>
<code>emplace_back</code> is especially useful for this use case.
</p>

</aside>

</section>
<section id="slide-orgc51c797">
<h3 id="orgc51c797">Example 3</h3>
<p>
In-place construct with <code>explicit</code> constructor.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">recall: S has an explicit constructor from int</span>
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">push_back can't do explicit construction</span>
v.push_back<span style="color: #2aa198;">(</span><span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;  <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">compiler error!</span>

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">explicit construction is no problem for emplace_back</span>
<span style="color: #268bd2;">S</span>&amp; <span style="color: #cb4b16;">s</span> = v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
<code>emplace_back</code> does perfect forwarding. It can call <code>explicit</code> constructors.
</p>

<aside class="notes">
<p>
<code>emplace_back</code> is especially useful for this use case.
</p>

</aside>

</section>
<section id="slide-org720baf9">
<h3 id="org720baf9">Example: copy</h3>
<p>
Recall: our <code>S</code> class has a constructor from <code>Arg</code>, and an <code>explicit</code> constructor
from <code>int</code>.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">array</span><span style="color: #2aa198;">&lt;</span>Arg, <span style="color: #859900;">3</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">a</span> = <span style="color: #2aa198;">{</span> Arg<span style="color: #b58900;">{}</span>, Arg<span style="color: #b58900;">{}</span>, Arg<span style="color: #b58900;">{}</span> <span style="color: #2aa198;">}</span>;

<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
v.reserve<span style="color: #2aa198;">(</span>a.size<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
<span style="color: #859900;">std</span>::copy<span style="color: #2aa198;">(</span>a.cbegin<span style="color: #b58900;">()</span>, a.cend<span style="color: #b58900;">()</span>, <span style="color: #859900;">std</span>::back_inserter<span style="color: #b58900;">(</span>v<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
What does <code>back_insert_iterator</code> do here?
</p>

<aside class="notes">
<p>
For each element, we construct an <code>S</code> (from the <code>Arg</code>) and then we move it into
the <code>vector</code>.
</p>

</aside>

</section>
<section id="slide-org8f480f8">
<h3 id="org8f480f8">Example: copy</h3>
<p>
What if we have an <code>array</code> of <code>int</code>?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">array</span> <span style="color: #cb4b16;">a</span> = <span style="color: #2aa198;">{</span> <span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span>,<span style="color: #859900;">4</span>,<span style="color: #859900;">5</span> <span style="color: #2aa198;">}</span>;

<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
v.reserve<span style="color: #2aa198;">(</span>a.size<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
<span style="color: #859900;">std</span>::copy<span style="color: #2aa198;">(</span>a.cbegin<span style="color: #b58900;">()</span>, a.cend<span style="color: #b58900;">()</span>, <span style="color: #859900;">std</span>::back_inserter<span style="color: #b58900;">(</span>v<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p class="fragment (appear)">
Oops. The compiler is angry at us.
</p>

<aside class="notes">
<p>
<code>back_insert_iterator</code> calls <code>push_back</code> - it can't call our explicit
constructor.
</p>

</aside>

</section>
<section id="slide-org72234d6">
<h3 id="org72234d6">Example: copy?</h3>
<p>
OK, no problem, right?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">array</span> <span style="color: #cb4b16;">a</span> = <span style="color: #2aa198;">{</span> <span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span>,<span style="color: #859900;">4</span>,<span style="color: #859900;">5</span> <span style="color: #2aa198;">}</span>;
v.reserve<span style="color: #2aa198;">(</span>a.size<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900;">std</span>::transform<span style="color: #2aa198;">(</span>a.cbegin<span style="color: #b58900;">()</span>, a.cend<span style="color: #b58900;">()</span>, <span style="color: #859900;">std</span>::back_inserter<span style="color: #b58900;">(</span>v<span style="color: #b58900;">)</span>,
               <span style="color: #b58900;">[]</span> <span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span> <span style="color: #cb4b16;">i</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #94BFF3;">{</span>i<span style="color: #94BFF3;">}</span>; <span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
For each element, we construct an <code>S</code> (from the <code>int</code>) and then we move it into
the <code>vector</code>. No extra cost over the first solution, because the <code>return</code> from the
lambda RVOs.
</p>

<p>
But what we actually want to do is construct in place.
</p>

</aside>

</section>
<section id="slide-org0b19d51">
<h3 id="org0b19d51"><code>back_emplacer</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">Container</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">back_emplace_iterator</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">back_emplace_iterator</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">Container</span>&amp; <span style="color: #cb4b16;">c</span><span style="color: #b58900;">)</span> : c<span style="color: #b58900;">(</span>&amp;c<span style="color: #b58900;">)</span> <span style="color: #b58900;">{}</span>

  <span style="color: #268bd2;">back_emplace_iterator</span>&amp; <span style="color: #b58900; font-weight: bold;">operator</span><span style="color: #2aa198;">++</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> *<span style="color: #b58900; font-weight: bold;">this</span>; <span style="color: #b58900;">}</span>
  <span style="color: #268bd2;">back_emplace_iterator</span>&amp; <span style="color: #b58900; font-weight: bold;">operator</span><span style="color: #2aa198;">*</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> *<span style="color: #b58900; font-weight: bold;">this</span>; <span style="color: #b58900;">}</span>

  <span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #b58900;">&lt;</span><span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">Arg</span><span style="color: #b58900;">&gt;</span>
  <span style="color: #268bd2;">back_emplace_iterator</span>&amp; <span style="color: #b58900; font-weight: bold;">operator</span><span style="color: #2aa198;">=</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">Arg</span>&amp;&amp; <span style="color: #cb4b16;">arg</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    c-&gt;emplace_back<span style="color: #94BFF3;">(</span><span style="color: #859900;">std</span>::forward<span style="color: #dc322f;">&lt;</span><span style="color: #268bd2;">Arg</span><span style="color: #dc322f;">&gt;(</span><span style="color: #cb4b16;">arg</span><span style="color: #dc322f;">)</span><span style="color: #94BFF3;">)</span>;
    <span style="color: #b58900; font-weight: bold;">return</span> *<span style="color: #b58900; font-weight: bold;">this</span>;
  <span style="color: #b58900;">}</span>

<span style="color: #b58900; font-weight: bold;">private</span>:
  <span style="color: #268bd2;">Container</span>* <span style="color: #cb4b16;">c</span>;
<span style="color: #2aa198;">}</span>;
</pre>
</div>

<p>
(Slideware - some details omitted)
</p>

<aside class="notes">
<p>
Here's an alternative: instead of using <code>back_inserter</code>, let's create a
<code>back_emplacer</code> iterator that calls <code>emplace_back</code> instead of <code>push_back</code>.
</p>

<p>
(Some details omitted for slide.)
</p>

</aside>

</section>
<section id="slide-org557f844">
<h3 id="org557f844"><code>back_emplacer</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">pre-CTAD maker function</span>

<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">Container</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">auto</span> <span style="color: #2aa198;">back_emplacer</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">Container</span>&amp; <span style="color: #cb4b16;">c</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> back_emplace_iterator<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">Container</span><span style="color: #b58900;">&gt;(</span>c<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
<p>
(Or write a deduction guide for C++17)
</p>

<aside class="notes">
<p>
If you have C++17, you can write a deduction guide instead.
</p>

</aside>

</section>
<section id="slide-orgd8ae9dd">
<h3 id="orgd8ae9dd"><code>back_emplacer</code></h3>
<p>
What if we have an <code>array</code> of <code>int</code>?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">array</span> <span style="color: #cb4b16;">a</span> = <span style="color: #2aa198;">{</span> <span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span>,<span style="color: #859900;">4</span>,<span style="color: #859900;">5</span> <span style="color: #2aa198;">}</span>;
v.reserve<span style="color: #2aa198;">(</span>a.size<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900;">std</span>::copy<span style="color: #2aa198;">(</span>a.cbegin<span style="color: #b58900;">()</span>, a.cend<span style="color: #b58900;">()</span>, back_emplacer<span style="color: #b58900;">(</span>v<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
<p>
The compiler is happy now! And we get in-place construction.
</p>

<aside class="notes">
<p>
Now it works fine, and achieves in-place construction.
</p>

</aside>

</section>
<section id="slide-orgfd803ff">
<h3 id="orgfd803ff">Exhibit D</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string_view<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">tokens</span>;
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">...</span>
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">string_view</span> <span style="color: #cb4b16;">token</span> = <span style="color: #ff00ff;">/* </span><span style="color: #ff00ff;">stuff */</span>;
tokens.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>token<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Here's some code I saw that was trying really hard to be efficient.
</p>

<p>
A few things here:
</p>
<ul>
<li><code>string_view</code> is a pointer + length. recommendation is to pass by value;
<code>move</code> gains nothing anyway.</li>
<li><code>push_back</code> works with rvalues just fine - <code>emplace_back</code> gains nothing here.</li>
<li>if you want to, you should pass <code>/* stuff */</code> directly to <code>emplace_back</code>.</li>

</ul>

</aside>

</section>
<section id="slide-orgddd051b">
<h3 id="orgddd051b">Exhibit E</h3>
<div class="org-src-container">

<pre  class="src src-c++">m_headers.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::string<span style="color: #b58900;">(</span>headerData, numBytes<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
A superfluous move! Better:
</p>

<div class="org-src-container">

<pre  class="src src-c++">m_headers.emplace_back<span style="color: #2aa198;">(</span>headerData, numBytes<span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
Don't explicitly call a constructor with <code>emplace_back</code>.
</p>

<aside class="notes">
<p>
And remember, likely a superfluous "copy" if the string is
small-buffer-optimized.
</p>

</aside>

</section>
<section id="slide-orgd33a78d">
<h3 id="orgd33a78d"><code>vector</code> of <code>pair</code> = <code>map</code></h3>
<p>
Sometimes, we use a  sorted <code>vector</code> of <code>pair</code> as a replacement for <code>map</code>.
</p>

<p>
What do you do if part of your <code>pair</code> has a multi-argument constructor?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">Value</span> <span style="color: #2aa198;">{</span> <span style="color: #2aa198;">Value</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span>, <span style="color: #859900;">std</span>::string, <span style="color: #268bd2;">double</span><span style="color: #b58900;">)</span>; <span style="color: #2aa198;">}</span>;

<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">pair</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span>, <span style="color: #268bd2;">Value</span><span style="color: #b58900;">&gt;</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">this is very common!</span>
v.push_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span><span style="color: #859900;">1</span>, Value<span style="color: #94BFF3;">{</span><span style="color: #859900;">42</span>, <span style="color: #D01A4E;">"hello"</span>, <span style="color: #859900;">3.14</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">this is no better</span>
v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span><span style="color: #859900;">1</span>, Value<span style="color: #94BFF3;">{</span><span style="color: #859900;">42</span>, <span style="color: #D01A4E;">"hello"</span>, <span style="color: #859900;">3.14</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">how can we do better?</span>
v.emplace_back<span style="color: #2aa198;">(</span> <span style="color: #ff00ff;">/* </span><span style="color: #ff00ff;">what here? */</span> <span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Either <code>push_back</code> or <code>emplace_back</code> do the same thing:
</p>

<ul>
<li>we explicitly asking for a temporary to be constructed</li>
<li>it gets moved into the pair</li>
<li>the pair gets moved into the vector</li>

</ul>

<p>
2 extra moves!
</p>

</aside>

</section>
<section id="slide-org3f56ac7">
<h3 id="org3f56ac7"><code>piecewise_construct</code> to the rescue!</h3>
<p>
<code>pair</code> has a constructor that will handle your multi-argument constructor.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args1</span>, <span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args2</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #2aa198;">pair</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">piecewise_construct_t</span>,
     <span style="color: #268bd2;">tuple</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">Args1</span><span style="color: #2aa198;">...</span><span style="color: #b58900;">&gt;</span> <span style="color: #cb4b16;">first_args</span>,
     <span style="color: #268bd2;">tuple</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">Args2</span><span style="color: #2aa198;">...</span><span style="color: #b58900;">&gt;</span> <span style="color: #cb4b16;">second_args</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Types</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">constexpr</span> <span style="color: #268bd2;">tuple</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">Types</span>&amp;&amp;<span style="color: #2aa198;">...</span><span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">forward_as_tuple</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">Types</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span> <span style="color: #b58900; font-weight: bold;">noexcept</span>;
</pre>
</div>

<p>
<code>piecewise_construct_t</code> is a tag type.
</p>

<aside class="notes">
<p>
<code>piecewise_construct_t</code> is a tag type whose singleton value is
<code>piecewise_construct</code>.
</p>

</aside>

</section>
<section id="slide-org8a80d08">
<h3 id="org8a80d08">Using <code>piecewise_construct</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">Value</span> <span style="color: #2aa198;">{</span> <span style="color: #2aa198;">Value</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span>, <span style="color: #859900;">std</span>::string, <span style="color: #268bd2;">double</span><span style="color: #b58900;">)</span>; <span style="color: #2aa198;">}</span>;

<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">pair</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span>, <span style="color: #268bd2;">Value</span><span style="color: #b58900;">&gt;</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">instead of this...</span>
v.push_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span><span style="color: #859900;">1</span>, Value<span style="color: #94BFF3;">{</span><span style="color: #859900;">42</span>, <span style="color: #D01A4E;">"hello"</span>, <span style="color: #859900;">3.14</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">...we can do this</span>
v.emplace_back<span style="color: #2aa198;">(</span>
  <span style="color: #859900;">std</span>::piecewise_construct,
  <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">(</span><span style="color: #859900;">1</span><span style="color: #b58900;">)</span>,                   <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">args to int "constructor"</span>
  <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">(</span><span style="color: #859900;">42</span>, <span style="color: #D01A4E;">"hello"</span>, <span style="color: #859900;">3.14</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span><span style="color: #88090B;">)</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">args to Value constructor</span>
</pre>
</div>
<p>
Perfect forwarding and in-place construction.
</p>

<aside class="notes">
<p>
OK, so it's verbose. And on slideware, it's not compelling. But C++ is about "no
distributed fat" - optimality is possible. And when you need it, you need it.
</p>

</aside>

</section>
<section id="slide-org492a03a">
<h3 id="org492a03a">Recommendations</h3>
<ul>
<li><code>push_back</code> is perfectly fine for rvalues</li>
<li>use <code>emplace_back</code> only when you need its powers
<ul>
<li>in-place construction (including nullary construction)</li>
<li>a reference to what's added (C++17)</li>

</ul></li>
<li>never pass an explicit temporary to <code>emplace_back</code></li>
<li>use <code>piecewise_construct</code> / <code>forward_as_tuple</code> to forward args through <code>pair</code></li>

</ul>

<aside class="notes">
<p>
You can use <code>emplace_back</code> for rvalues, but I like to follow the "rule of least
power" - that is, to use the least powerful thing that will do the job.
<code>emplace_back</code> is very powerful and probably requires more effort to understand
the call site than <code>push_back</code> so if I just have an rvalue, I'll prefer to use
<code>push_back</code>.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org29cdb8c">
<h2 id="org29cdb8c">4. <code>initializer_list</code></h2>
<div class='vertspace2'></div>
<blockquote nil><p>&quot;I fear these stubborn lines lack power to move.&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>Love's Labours Lost</em></div></blockquote>

</section>
<section id="slide-org4e63dd7">
<h3 id="org4e63dd7">What is <code>initializer_list</code>?</h3>
<p>
When you write:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span><span style="color: #2aa198;">{</span> <span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span> <span style="color: #2aa198;">}</span>;
</pre>
</div>
<p>
It's as if you wrote:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">int</span> <span style="color: #cb4b16;">a</span><span style="color: #2aa198;">[]</span> = <span style="color: #2aa198;">{</span> <span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span> <span style="color: #2aa198;">}</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = <span style="color: #859900;">std</span>::initializer_list<span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;(</span>a, a+<span style="color: #859900;">3</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Notice: the backing array is <code>const</code>.
</p>

</aside>

</section>
<section id="slide-org981d460">
<h3 id="org981d460"><code>initializer_list</code> has <code>const</code> storage, 1</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">Is</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">auto</span> <span style="color: #2aa198;">f</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> <span style="color: #859900;">std</span>::<span style="color: #268bd2;">initializer_list</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;{</span> Is<span style="color: #2aa198;">...</span> <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">void</span> <span style="color: #2aa198;">fine</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span> <span style="color: #cb4b16;">i</span>: <span style="color: #94BFF3;">{</span><span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span>
    cout &lt;&lt; i &lt;&lt; <span style="color: #D01A4E;">'</span><span style="color: #5f127b; font-weight: bold;">\</span><span style="color: #b58900; font-weight: bold;">n</span><span style="color: #D01A4E;">'</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">void</span> <span style="color: #2aa198;">works_fine_until_it_explodes</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span> <span style="color: #cb4b16;">i</span>: f<span style="color: #94BFF3;">&lt;</span><span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span><span style="color: #94BFF3;">&gt;()</span><span style="color: #b58900;">)</span>
    cout &lt;&lt; i &lt;&lt; <span style="color: #D01A4E;">'</span><span style="color: #5f127b; font-weight: bold;">\</span><span style="color: #b58900; font-weight: bold;">n</span><span style="color: #D01A4E;">'</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<aside class="notes">
<p>
This is nasty, because it could work on one compiler and you wouldn't notice it.
</p>

<p>
The compiler probably won't warn for this.
</p>

<p>
<code>initializer_list</code> is a "view" type like <code>string_view</code> and doesn't own its
contents.
</p>

</aside>

</section>
<section id="slide-orge7c6db1">
<h3 id="orge7c6db1"><code>initializer_list</code> has <code>const</code> storage, 2</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">unique_ptr</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = <span style="color: #2aa198;">{</span> make_unique<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">1</span><span style="color: #b58900;">)</span>, make_unique<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">2</span><span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>;
</pre>
</div>
<p>
That also means <code>move</code> can't work.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #859900;">std</span>::<span style="color: #268bd2;">unique_ptr</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">a</span><span style="color: #2aa198;">[]</span> = <span style="color: #2aa198;">{</span> <span style="color: #859900;">std</span>::make_unique<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">1</span><span style="color: #b58900;">)</span>,
                                   <span style="color: #859900;">std</span>::make_unique<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">2</span><span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">unique_ptr</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> =
  <span style="color: #859900;">std</span>::initializer_list<span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">unique_ptr</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;</span><span style="color: #2aa198;">&gt;(</span>a, a+<span style="color: #859900;">3</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
You can't move from an <code>initializer_list</code> - this won't compile.
</p>

</aside>

</section>
<section id="slide-org24a6c9e">
<h3 id="org24a6c9e">But they're so convenient!</h3>
<p>
I'd much rather write:
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = <span style="color: #2aa198;">{</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>, S<span style="color: #b58900;">{</span><span style="color: #859900;">2</span><span style="color: #b58900;">}</span>, S<span style="color: #b58900;">{</span><span style="color: #859900;">3</span><span style="color: #b58900;">}</span> <span style="color: #2aa198;">}</span>;
</pre>
</div>
<p>
(3 constructs, 3 copies, 3 destructs)
</p>

<p>
Than:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
v.reserve<span style="color: #2aa198;">(</span><span style="color: #859900;">3</span><span style="color: #2aa198;">)</span>;
v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">2</span><span style="color: #2aa198;">)</span>;
v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">3</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
<p>
(3 constructs)
</p>

<aside class="notes">
<p>
The first version is probably OK for builtin primitive types.
</p>

<p>
It's way worse than the second version for types with more than trivial
construction.
</p>

</aside>

</section>
<section id="slide-org36b4609">
<h3 id="org36b4609">We can make it a little(?) better&#x2026;</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = <span style="color: #2aa198;">{</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>, S<span style="color: #b58900;">{</span><span style="color: #859900;">2</span><span style="color: #b58900;">}</span>, S<span style="color: #b58900;">{</span><span style="color: #859900;">3</span><span style="color: #b58900;">}</span> <span style="color: #2aa198;">}</span>;
</pre>
</div>
<p>
(3 constructs, 3 copies, 3 destructs)
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">a</span><span style="color: #2aa198;">[</span><span style="color: #859900;">3</span><span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">{</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>, S<span style="color: #b58900;">{</span><span style="color: #859900;">2</span><span style="color: #b58900;">}</span>, S<span style="color: #b58900;">{</span><span style="color: #859900;">3</span><span style="color: #b58900;">}</span> <span style="color: #2aa198;">}</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">S</span><span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">v</span><span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">make_move_iterator</span><span style="color: #b58900;">(</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">begin</span><span style="color: #94BFF3;">(</span><span style="color: #cb4b16;">a</span><span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span>,
                 <span style="color: #859900;">std</span>::<span style="color: #268bd2;">make_move_iterator</span><span style="color: #b58900;">(</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">end</span><span style="color: #94BFF3;">(</span><span style="color: #cb4b16;">a</span><span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
<p>
(3 constructs, 3 moves, 3 destructs)
</p>

</section>
<section id="slide-org3c03097">
<h3 id="org3c03097">What we really need&#x2026;</h3>
<p>
Is an in-place constructor for <code>vector</code>. (For everything?)
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">vector</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">in_place_t</span>, <span style="color: #268bd2;">Args</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
There is some work going on here, e.g. future (?) proposal by Sy Brand &amp; Chris
Di Bella&#x2026;
<a href="https://wg21.tartanllama.xyz/initializer_list">https://wg21.tartanllama.xyz/initializer_list</a>
</p>

<aside class="notes">
<p>
I'm not sure if this proposal will see publication, but I think there is some
work going on around initializer_list.
</p>

</aside>

</section>
<section id="slide-orga9c76f7">
<h3 id="orga9c76f7">Exhibit F</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">unordered_set</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">kKeywords</span> = <span style="color: #2aa198;">{</span>
    <span style="color: #D01A4E;">"alignas"</span>, <span style="color: #D01A4E;">"alignof"</span>, <span style="color: #D01A4E;">"and"</span>, <span style="color: #D01A4E;">"and_eq"</span>, <span style="color: #D01A4E;">"asm"</span>, <span style="color: #D01A4E;">"auto"</span>, <span style="color: #D01A4E;">"bitand"</span>, <span style="color: #D01A4E;">"bitor"</span>,
    <span style="color: #D01A4E;">"bool"</span>, <span style="color: #D01A4E;">"break"</span>, <span style="color: #D01A4E;">"case"</span>, <span style="color: #D01A4E;">"catch"</span>, <span style="color: #D01A4E;">"char"</span>, <span style="color: #D01A4E;">"class"</span>, <span style="color: #D01A4E;">"compl"</span>, <span style="color: #D01A4E;">"const"</span>,
    <span style="color: #D01A4E;">"constexpr"</span>, <span style="color: #D01A4E;">"const_cast"</span>, <span style="color: #D01A4E;">"continue"</span>, <span style="color: #D01A4E;">"decltype"</span>, <span style="color: #D01A4E;">"default"</span>, <span style="color: #D01A4E;">"delete"</span>,
    <span style="color: #D01A4E;">"do"</span>, <span style="color: #D01A4E;">"double"</span>, <span style="color: #D01A4E;">"dynamic_cast"</span>, <span style="color: #D01A4E;">"else"</span>, <span style="color: #D01A4E;">"enum"</span>, <span style="color: #D01A4E;">"explicit"</span>, <span style="color: #D01A4E;">"extern"</span>,
    <span style="color: #D01A4E;">"false"</span>, <span style="color: #D01A4E;">"float"</span>, <span style="color: #D01A4E;">"for"</span>, <span style="color: #D01A4E;">"friend"</span>, <span style="color: #D01A4E;">"goto"</span>, <span style="color: #D01A4E;">"if"</span>, <span style="color: #D01A4E;">"inline"</span>, <span style="color: #D01A4E;">"int"</span>, <span style="color: #D01A4E;">"long"</span>,
    <span style="color: #D01A4E;">"mutable"</span>, <span style="color: #D01A4E;">"namespace"</span>, <span style="color: #D01A4E;">"new"</span>, <span style="color: #D01A4E;">"noexcept"</span>, <span style="color: #D01A4E;">"not"</span>, <span style="color: #D01A4E;">"not_eq"</span>, <span style="color: #D01A4E;">"NULL"</span>,
    <span style="color: #D01A4E;">"operator"</span>, <span style="color: #D01A4E;">"or"</span>, <span style="color: #D01A4E;">"or_eq"</span>, <span style="color: #D01A4E;">"private"</span>, <span style="color: #D01A4E;">"protected"</span>, <span style="color: #D01A4E;">"public"</span>, <span style="color: #D01A4E;">"register"</span>,
    <span style="color: #D01A4E;">"reinterpret_cast"</span>, <span style="color: #D01A4E;">"return"</span>, <span style="color: #D01A4E;">"short"</span>, <span style="color: #D01A4E;">"signed"</span>, <span style="color: #D01A4E;">"sizeof"</span>, <span style="color: #D01A4E;">"static"</span>,
    <span style="color: #D01A4E;">"static_assert"</span>, <span style="color: #D01A4E;">"static_cast"</span>, <span style="color: #D01A4E;">"struct"</span>, <span style="color: #D01A4E;">"switch"</span>, <span style="color: #D01A4E;">"template"</span>, <span style="color: #D01A4E;">"this"</span>,
    <span style="color: #D01A4E;">"thread_local"</span>, <span style="color: #D01A4E;">"throw"</span>, <span style="color: #D01A4E;">"true"</span>, <span style="color: #D01A4E;">"try"</span>, <span style="color: #D01A4E;">"typedef"</span>, <span style="color: #D01A4E;">"typeid"</span>, <span style="color: #D01A4E;">"typename"</span>,
    <span style="color: #D01A4E;">"union"</span>, <span style="color: #D01A4E;">"unsigned"</span>, <span style="color: #D01A4E;">"using"</span>, <span style="color: #D01A4E;">"virtual"</span>, <span style="color: #D01A4E;">"void"</span>, <span style="color: #D01A4E;">"volatile"</span>, <span style="color: #D01A4E;">"wchar_t"</span>,
    <span style="color: #D01A4E;">"while"</span>, <span style="color: #D01A4E;">"xor"</span>, <span style="color: #D01A4E;">"xor_eq"</span>
<span style="color: #2aa198;">}</span>;
</pre>
</div>

</section>
<section id="slide-org8f2f000">
<h3 id="org8f2f000">Caveat Constructor</h3>
<p>
<code>std::string</code> is an interesting case here. We intuit/are taught:
</p>

<blockquote nil><p>Delay construction, allocation, etc. as late as possible.</p></blockquote>

<p>
But that might hurt us with <code>std::string</code>.
</p>

<p>
<a href="https://www.youtube.com/watch?v=sSlmmZMFsXQ">"Initializer Lists are Broken, Let's Fix Them"</a> &#x2013; Jason Turner, C++Now 2018
</p>

</section>
<section id="slide-orgb590794">
<h3 id="orgb590794">Surprising: <code>string</code> vs <code>const char*</code></h3>
<p>
SBO-strings
<a href="http://quick-bench.com/5dPSX8rx-R8_BIUYbYOp6DcqhAc">http://quick-bench.com/5dPSX8rx-R8_BIUYbYOp6DcqhAc</a>
</p>

<p>
Non SBO-strings 1:
<a href="http://quick-bench.com/mr6ZIQ8Jy0ghe1scBcTznYF2s5w">http://quick-bench.com/mr6ZIQ8Jy0ghe1scBcTznYF2s5w</a>
</p>

<p>
Non SBO-strings 2:
<a href="http://quick-bench.com/vzlG11LwZN-uMAKdK8X1XgRuaWs">http://quick-bench.com/vzlG11LwZN-uMAKdK8X1XgRuaWs</a>
</p>

<aside class="notes">
<p>
Two things mess with our mental model for strings. First - the small buffer
optimization. As previously mentioned, it makes copy the same cost as move.
</p>

<p>
Second - we often make strings from string literals. What's the type of a string
literal at declaration? Array of char. What's the type of it when you pass it to
a function? It decays to pointer to char.
</p>

<p>
So, if a string isn't small-buffer optimized, move is cheap. And if we're
constructing it from a string literal, the compiler knows the size. If we let it
decay to a char*, we're going to call strlen at some point.
</p>

</aside>

</section>
<section id="slide-org319e91c">
<h3 id="org319e91c">Recommendations</h3>
<ul>
<li>use <code>initializer_list</code> only for literal types</li>
<li>consider using <code>array</code> and manually moving?</li>
<li>probably don't use <code>initializer_list</code> for anything that'll get run more than
once</li>
<li>wait for an <code>in_place_t</code> constructor on <code>vector</code>?</li>
<li>wait for more work on <code>std::initializer_list</code>?</li>
<li>watch Jason's talk</li>

</ul>

<aside class="notes">
<p>
I'm not sure what to recommend. Really the first point, and the last.
</p>

<p>
There are not many good answers here.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org2d00e33">
<h2 id="org2d00e33">5. Putting stuff into a <code>map</code></h2>
<p>
(or other associative container)
</p>

<p>
It's <del>a bit</del> complicated.
</p>

<div class='vertspace2'></div>
<blockquote nil><p>&quot;A plague upon it! I have forgot the map.&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>Henry IV, Part I</em></div></blockquote>

<aside class="notes">
<p>
When I say <code>map</code>, I mean <code>map</code>, <code>unordered_map</code>, <code>multimap</code>, <code>unordered_multimap</code>,
etc, and also the various flavours of <code>set</code>.
</p>

<p>
Note: the <code>value_type</code> of a <code>map</code> is <code>pair&lt;const K, V&gt;</code>. Confusingly, if we want
to refer to just the value in the map and not the key, it's called the
<code>mapped_type</code>.
</p>

</aside>

</section>
<section id="slide-orgf7e973c">
<h3 id="orgf7e973c"><code>initializer_list</code> with <code>map</code></h3>
<p>
It's perfectly possible to initialize a map with an <code>initializer_list</code>.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">recall S has an implicit constructor from Arg</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span> <span style="color: #2aa198;">{</span> <span style="color: #b58900;">{</span><span style="color: #859900;">0</span>, Arg<span style="color: #94BFF3;">{}</span><span style="color: #b58900;">}</span> <span style="color: #2aa198;">}</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">how many constructs/copies/moves?</span>
</pre>
</div>

<p>
Use aggregate initialization with <code>pair</code>.
</p>

<p>
Is this good?
</p>

<aside class="notes">
<p>
Same as the <code>vector</code> init case basically. <code>initializer_list</code> still suffers from
the same problems.
</p>

<p>
You can't use explicit constructors easily here.
</p>

<p>
If you have explicit constructors you might need to explicitly call out the type
 of pair; it's not going to make a lot of difference.
</p>

</aside>

</section>
<section id="slide-org88221b2">
<h3 id="org88221b2">Alternative: templatery</h3>
<p>
(Originally? by Vittorio Romeo)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">call an N-ary function on each lot of N args passed in</span>
<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">size_t</span> <span style="color: #cb4b16;">N</span>, <span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">F</span>, <span style="color: #b58900; font-weight: bold;">typename</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Ts</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">void</span> <span style="color: #2aa198;">for_each_n_args</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">F</span>&amp;&amp; <span style="color: #cb4b16;">f</span>, <span style="color: #268bd2;">Ts</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">ts</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
for_each_n_args<span style="color: #2aa198;">&lt;</span><span style="color: #859900;">2</span><span style="color: #2aa198;">&gt;(</span>
  <span style="color: #b58900;">[</span>&amp;<span style="color: #b58900;">]</span> <span style="color: #b58900;">(</span><span style="color: #b58900; font-weight: bold;">auto</span>&amp;&amp; <span style="color: #cb4b16;">k</span>, <span style="color: #b58900; font-weight: bold;">auto</span>&amp;&amp; <span style="color: #cb4b16;">v</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
      m.emplace<span style="color: #94BFF3;">(</span>forward<span style="color: #dc322f;">&lt;</span><span style="color: #b58900; font-weight: bold;">decltype</span><span style="color: #859900;">(</span>k<span style="color: #859900;">)</span><span style="color: #dc322f;">&gt;(</span>k<span style="color: #dc322f;">)</span>,
                forward<span style="color: #dc322f;">&lt;</span><span style="color: #b58900; font-weight: bold;">decltype</span><span style="color: #859900;">(</span>v<span style="color: #859900;">)</span><span style="color: #dc322f;">&gt;(</span>v<span style="color: #dc322f;">)</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>,
  <span style="color: #859900;">0</span>, <span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">we can call explicit constructor</span>
</pre>
</div>

<p>
If you know the types, you can probably write the lambda in a less ugly way.
</p>

<aside class="notes">
<p>
<code>for_each_n_args</code> is a function template that perfectly-forwards its arguments
in groups of N to the function you give it.
</p>

<p>
Everything here gets constructed in place. No moves or copies.
</p>

<p>
This lambda deals with single-argument constructors for value. But&#x2026;
</p>

</aside>

</section>
<section id="slide-org864424c">
<h3 id="org864424c">Alternative: multi-arg templatery</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
for_each_n_args<span style="color: #2aa198;">&lt;</span><span style="color: #859900;">3</span><span style="color: #2aa198;">&gt;(</span>
  <span style="color: #b58900;">[</span>&amp;<span style="color: #b58900;">]</span> <span style="color: #b58900;">(</span><span style="color: #b58900; font-weight: bold;">auto</span>&amp;&amp; <span style="color: #cb4b16;">k</span>, <span style="color: #b58900; font-weight: bold;">auto</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">v</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
      m.emplace<span style="color: #94BFF3;">(</span>
        <span style="color: #859900;">std</span>::piecewise_construct,
        <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #dc322f;">(</span><span style="color: #859900;">std</span>::forward<span style="color: #859900;">&lt;</span><span style="color: #b58900; font-weight: bold;">decltype</span><span style="color: #268bd2;">(</span>k<span style="color: #268bd2;">)</span><span style="color: #859900;">&gt;(</span>k<span style="color: #859900;">)</span><span style="color: #dc322f;">)</span>,
        <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #dc322f;">(</span><span style="color: #859900;">std</span>::forward<span style="color: #859900;">&lt;</span><span style="color: #b58900; font-weight: bold;">decltype</span><span style="color: #268bd2;">(</span>v<span style="color: #268bd2;">)</span><span style="color: #859900;">&gt;(</span>v<span style="color: #859900;">)</span><span style="color: #2aa198;">...</span><span style="color: #dc322f;">)</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>,
  <span style="color: #859900;">0</span>, <span style="color: #859900;">1</span>, <span style="color: #859900;">2</span><span style="color: #2aa198;">)</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">explicit multi-arg value constructor</span>
</pre>
</div>

<p>
Everything constructed in place.
</p>

<aside class="notes">
<p>
Here we are calling S's two-arg constructor.
</p>

<p>
<code>for_each_n_args</code> also works with vector (including vector-of-pair) as an
alternative to <code>initializer_list</code>
</p>

<p>
With modern compilers, this works; with older MSVC compilers I ran into some
issues with calling <code>explicit</code> constructors.
</p>

</aside>

</section>
<section id="slide-org0c9ef0a">
<h3 id="org0c9ef0a">Enough about initializing</h3>
<p>
How about putting things into an existing <code>map</code>?
</p>

</section>
<section id="slide-orgef77e33">
<h3 id="orgef77e33">The Easy Way: <code>operator[]</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">recall S has an implicit constructor from Arg</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">but an explicit constructor from int</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m<span style="color: #2aa198;">[</span><span style="color: #859900;">0</span><span style="color: #2aa198;">]</span> = S<span style="color: #2aa198;">{</span><span style="color: #859900;">1</span><span style="color: #2aa198;">}</span>;
m<span style="color: #2aa198;">[</span><span style="color: #859900;">1</span><span style="color: #2aa198;">]</span> = Arg<span style="color: #2aa198;">{}</span>;
</pre>
</div>

<p>
How many constructs/moves/copies?
</p>

<aside class="notes">
<p>
These each have a construct, a default construct, and a move.
</p>

<p>
The advantage of this is that when you know the element is there already, it's
fine. You just get a lookup and an assign.
</p>

<p>
But if the element isn't there, you never get a copy construct or a move
construct here.
</p>

<p>
You always get an assign! Because you always get a default construct if the
element isn't there.
</p>

<p>
In fact this is the only function on map that requires your mapped_type to have
a default constructor! It's fine to use objects without default constructors in
a map, if you never use this function. And that can be a significant thing.
</p>

</aside>

</section>
<section id="slide-org4d664a8">
<h3 id="org4d664a8">The Other Easy(?) Way: <code>insert</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">recall S has an implicit constructor from Arg</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">but an explicit constructor from int</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">pair&lt;iterator,bool&gt; insert(value_type&amp;&amp; value);</span>

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">template &lt;class T1, class T2&gt;</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">pair&lt;V1,V2&gt; make_pair(T1&amp;&amp; t, T2&amp;&amp; u);</span>

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">alternatives:</span>
m.insert<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span><span style="color: #859900;">0</span>, S<span style="color: #94BFF3;">{</span><span style="color: #859900;">1</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
m.insert<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::pair<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span>, <span style="color: #268bd2;">S</span>&amp;&amp;<span style="color: #b58900;">&gt;(</span><span style="color: #859900;">0</span>, S<span style="color: #94BFF3;">{</span><span style="color: #859900;">1</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
m.insert<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span><span style="color: #859900;">0</span>, <span style="color: #859900;">1</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
How many constructs/moves/copies?
</p>

<aside class="notes">
<p>

</p>

<p>
The first line here creates an S, moves it into pair&lt;int, S&gt;, then moves the
pair into the map.
</p>

<p>
Remember that make_pair deduces the type of its arguments. And V1 and V2 here
are the decayed types of T1 and T2.
</p>

<p>
The second line forces a pair of type &lt;int, S&amp;&amp;&gt;, so you get one move after the
initial construct.
</p>

<p>
The third line makes a pair&lt;int, int&gt; then uses that pair to construct a pair of
&lt;int, S&gt; in the map. This works because pair's constructor is conditionally
explicit?
</p>

</aside>

</section>
<section id="slide-orgd5e8d0f">
<h3 id="orgd5e8d0f"><code>emplace</code></h3>
<p>
Enter the <i>wonderful C++11 panacea</i> that is move semantics.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">recall S has an implicit constructor from Arg</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">but an explicit constructor from int</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">template &lt;class... Args&gt;</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">pair&lt;iterator,bool&gt; emplace(Args&amp;&amp;... args);</span>

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">this was 2 moves</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">m.insert(make_pair(0, S{1}));</span>

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">much better, right?</span>
m.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span><span style="color: #859900;">0</span>, S<span style="color: #94BFF3;">{</span><span style="color: #859900;">1</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
You guessed it&#x2026;
</p>

<aside class="notes">
<p>
Don't do this. It is <i>exactly</i> the same as <code>insert</code> here. Two moves.
</p>

</aside>

</section>
<section id="slide-orgc3c918a">
<h3 id="orgc3c918a"><code>emplace</code>, better usage</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">recall S has an implicit constructor from Arg</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">but an explicit constructor from int</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">template &lt;class... Args&gt;</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">pair&lt;iterator,bool&gt; emplace(Args&amp;&amp;... args);</span>

m.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">0</span>, <span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">no moves, just a construct</span>
</pre>
</div>

<aside class="notes">
<p>
Again, the point of <code>emplace</code> is in-place construction.
</p>

<p>
It doesn't help you over <code>insert</code> if you just pass rvalues. <code>insert</code> works just
fine with rvalues.
</p>

</aside>

</section>
<section id="slide-org08789f5">
<h3 id="org08789f5"><code>emplace</code> problem</h3>
<p>
What do we do when we want to default-construct the value?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">0</span><span style="color: #2aa198;">)</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">default construct S please!</span>
</pre>
</div>

<p class="fragment (appear)">
<i>error 2665: <code>std::pair&lt;const _Kty,_Ty&gt;::pair</code>: none of the 2 overloads could
convert all the argument types</i>
</p>

<aside class="notes">
<p>
Here's a problem: how can we tell <code>emplace</code> to zero-arg construct the value when
we can't syntactically pass "zero arguments" in the place of an argument.
</p>

<p>
We don't want to default-construct an S explicitly here and move it in.
</p>

</aside>

</section>
<section id="slide-orgca47dd5">
<h3 id="orgca47dd5"><code>emplace</code> problem</h3>
<p>
What do we do when we want to default-construct the value?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m<span style="color: #2aa198;">[</span><span style="color: #859900;">0</span><span style="color: #2aa198;">]</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">default construct S please!</span>
</pre>
</div>

<p class="fragment (appear)">
_
</p>

<aside class="notes">
<p>
We could use <code>operator[]</code> but that would be weird.
</p>

<p>
I don't like expression statements and I would probably write <code>operator[]</code> with
nodiscard.
</p>

<p>
Remember the <code>value_type</code> of the <code>map</code> is a <code>pair</code> - that's what <code>emplace</code> is
trying to construct.
</p>

</aside>

</section>
<section id="slide-orge34e0cd">
<h3 id="orge34e0cd"><code>emplace</code> with zero-arg constructor</h3>
<p>
Our old friend <code>piecewise_construct</code> can help.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::piecewise_construct,
          <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">(</span><span style="color: #859900;">0</span><span style="color: #b58900;">)</span>,
          <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">default construct S please!</span>
</pre>
</div>

<p>
Tuples are allowed to be empty!
</p>

<p>
Yes, we can also use this for more-than-one-arg constructors.
</p>

<aside class="notes">
<p>
Here's the piecewise constructor on <code>pair</code> again.
</p>

</aside>

</section>
<section id="slide-orgdfaa38a">
<h3 id="orgdfaa38a">Exhibit G</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">explicit ClientRecord(</span>
<span style="color: #ff00ff;">//    </span><span style="color: #ff00ff;">const string&amp; clientId,</span>
<span style="color: #ff00ff;">//    </span><span style="color: #ff00ff;">const ProcessId&amp; clientProcess,</span>
<span style="color: #ff00ff;">//    </span><span style="color: #ff00ff;">const MachineId&amp; clientMachine);</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">Storage</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">unordered_set</span><span style="color: #2aa198;">&lt;</span>ClientRecord<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">Storage</span> <span style="color: #cb4b16;">m_storage</span>;
m_storage.emplace<span style="color: #2aa198;">(</span>clientId, processId, machineId<span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
Perfectly fine as far as <code>emplace</code> usage.
</p>

<p>
Then we want to change the <code>unordered_set</code> to an <code>unordered_map</code>.
</p>

<aside class="notes">
<p>
ClientRecord has a 3-argument constructor.
</p>

<p>
<code>clientId</code> is a string.
</p>

<p>
One in-place construct. This is fine.
</p>

</aside>

</section>
<section id="slide-orgc1551fe">
<h3 id="orgc1551fe">Exhibit G</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">explicit ClientRecord(</span>
<span style="color: #ff00ff;">//    </span><span style="color: #ff00ff;">const string&amp; clientId,</span>
<span style="color: #ff00ff;">//    </span><span style="color: #ff00ff;">const ProcessId&amp; clientProcess,</span>
<span style="color: #ff00ff;">//    </span><span style="color: #ff00ff;">const MachineId&amp; clientMachine);</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">Storage</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">unordered_map</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string, ClientRecord<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">Storage</span> <span style="color: #cb4b16;">m_storage</span>;
m_storage.emplace<span style="color: #2aa198;">(</span>
  <span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span>clientId,
                 ClientRecord<span style="color: #94BFF3;">(</span>clientId, processId, machineId<span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
Is this optimal?
</p>

<aside class="notes">
<p>
2 extra moves here now, because we switched from a set to map and wrote the
naive code.
</p>

<p>
How do we do better?
</p>

</aside>

</section>
<section id="slide-org871031a">
<h3 id="org871031a">Exhibit G</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">Storage</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">unordered_map</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string, ClientRecord<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">Storage</span> <span style="color: #cb4b16;">m_storage</span>;
m_storage.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::piecewise_construct,
                  <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">(</span>clientId<span style="color: #b58900;">)</span>,
                  <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">(</span>clientId, processId, machineId<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
Use <code>piecewise_construct</code> again.
</p>

<aside class="notes">
<p>
So easy to make a change like this and miss it in code review and incur
penalties.
</p>

</aside>

</section>
<section id="slide-orgd1edde4">
<h3 id="orgd1edde4"><code>emplace</code> problem 2</h3>
<p>
What do you do if you want to <code>emplace</code> the result of a function call?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">get_S</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>; <span style="color: #2aa198;">}</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">0</span>, get_S<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
How can we avoid the move?
</p>

<p>
Is it possible to in-place construct here?
</p>

<aside class="notes">
<p>
<code>get_S()</code> will be evaluated and produce an rvalue before we call <code>emplace</code>, so
we'll get a construct and a move.
</p>

</aside>

</section>
<section id="slide-orgfda244a">
<h3 id="orgfda244a">In-place construct a function call result</h3>
<div class='vertspace2'></div>

<p>
We can't avoid evaluating the function call before calling <code>emplace</code>.
</p>

<p>
But we can control when the result of the function call becomes an <code>S</code>.
</p>

</section>
<section id="slide-orgbad06cb">
<h3 id="orgbad06cb">In-place construct a function call result</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">F</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">with_result_of_t</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">T</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">invoke_result_t</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">F</span><span style="color: #b58900;">&gt;</span>;
  <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">with_result_of_t</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">F</span>&amp;&amp; <span style="color: #cb4b16;">f</span><span style="color: #b58900;">)</span> : f<span style="color: #b58900;">(</span><span style="color: #859900;">std</span>::forward<span style="color: #94BFF3;">&lt;</span><span style="color: #268bd2;">F</span><span style="color: #94BFF3;">&gt;(</span>f<span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{}</span>
  <span style="color: #ff00ff;">/* </span><span style="color: #ff00ff;">explicit(false) */</span> <span style="color: #b58900; font-weight: bold;">operator</span> <span style="color: #268bd2;">T</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> f<span style="color: #94BFF3;">()</span>; <span style="color: #b58900;">}</span>

<span style="color: #b58900; font-weight: bold;">private</span>:
  <span style="color: #268bd2;">F</span> <span style="color: #cb4b16;">f</span>;
<span style="color: #2aa198;">}</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">prior to CTAD</span>
<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">F</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">inline</span> <span style="color: #b58900; font-weight: bold;">auto</span> <span style="color: #2aa198;">with_result_of</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">F</span>&amp;&amp; <span style="color: #cb4b16;">f</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> with_result_of_t<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">F</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">std</span>::forward<span style="color: #94BFF3;">&lt;</span><span style="color: #268bd2;">F</span><span style="color: #94BFF3;">&gt;(</span>f<span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
<p>
<a href="https://quuxplusone.github.io/blog/2018/05/17/super-elider-round-2/">Superconstructing super elider</a>, Arthur O'Dwyer
</p>

<p>
<a href="https://akrzemi1.wordpress.com/2018/05/16/rvalues-redefined/">Rvalues redefined</a>, Andrzej Krzemieski
</p>

<aside class="notes">
<p>
Capture the function and call it only at the point that we want to convert the
result to an <code>S</code>.
</p>

<p>
<code>invoke_result_t</code> is C++17 - before that you can use <code>result_of_t</code>.
</p>

<p>
Note <code>explicit(false)</code> is C++20.
</p>

<p>
"Andre Ksheminski"
</p>

</aside>

</section>
<section id="slide-orgf4bc2a4">
<h3 id="orgf4bc2a4"><code>emplace</code> problem 2</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">get_S</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>; <span style="color: #2aa198;">}</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, <span style="color: #268bd2;">S</span><span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">0</span>, with_result_of<span style="color: #b58900;">(</span><span style="color: #94BFF3;">[]</span> <span style="color: #94BFF3;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> get_S<span style="color: #dc322f;">()</span>; <span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">m.emplace(0, with_result_of(get_S));</span>
</pre>
</div>

<p>
Compilers are really good at optimizing single-use lambdas.
</p>

<aside class="notes">
<p>
In general, compilers do better here with the lambda than with the free
function.
</p>

<p>
You would think the second line here would work just as well. But VC++17 at
least doesn't manage to elide the move.
</p>

</aside>

</section>
<section id="slide-org36c1d55">
<h3 id="org36c1d55">C++17: <code>insert_or_assign</code></h3>
<p>
Of course, <code>insert</code> / <code>emplace</code> and <code>operator[]</code> actually do different things.
</p>

<p>
What do you do if you want to insert, or assign if the element is already there?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span> <span style="color: #268bd2;">M</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">pair</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">iterator</span>, <span style="color: #268bd2;">bool</span><span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">insert_or_assign</span><span style="color: #2aa198;">(</span><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">key_type</span>&amp; <span style="color: #cb4b16;">k</span>, <span style="color: #268bd2;">M</span>&amp;&amp; <span style="color: #cb4b16;">obj</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span> <span style="color: #268bd2;">M</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">pair</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">iterator</span>, <span style="color: #268bd2;">bool</span><span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">insert_or_assign</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">key_type</span>&amp;&amp; <span style="color: #cb4b16;">k</span>, <span style="color: #268bd2;">M</span>&amp;&amp; <span style="color: #cb4b16;">obj</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
Introduced with C++17.
</p>

<aside class="notes">
<p>
<code>insert_or_assign</code> doesn't need default construction (unlike <code>operator[]</code>).
</p>

<p>
<code>insert_or_assign</code> was introduced with C++17. Can be written as a free function,
but difficult/impossible to make as efficient as map can as a member function.
</p>

</aside>

</section>
<section id="slide-org544f648">
<h3 id="org544f648">C++17: <code>insert_or_assign</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m.insert_or_assign<span style="color: #2aa198;">(</span><span style="color: #859900;">0</span>, Arg<span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">implicit construction - fine</span>

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">m.insert_or_assign(1, 1);  // explicit construction - error!</span>
m.insert_or_assign<span style="color: #2aa198;">(</span><span style="color: #859900;">1</span>, with_result_of<span style="color: #b58900;">(</span><span style="color: #94BFF3;">[]{</span> <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #dc322f;">{</span><span style="color: #859900;">1</span><span style="color: #dc322f;">}</span>; <span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">RVO</span>
</pre>
</div>

<aside class="notes">
<p>
Unfortunately there is no <code>emplace_or_assign</code>. (In the assign case presumably
could not avoid making a temporary to assign). But you can use the same
<code>with_result_of</code> technique with <code>insert_or_assign</code>.
</p>

</aside>

</section>
<section id="slide-orgd97a0e1">
<h3 id="orgd97a0e1">In case you're not keeping count&#x2026;</h3>
<p>
We now have at least <del>3</del> <del>4</del> <del>5</del> N (&gt;5) different <i>interface styles</i> for putting
things in a <code>map</code>&#x2026;
</p>

<ul>
<li><code>insert</code> takes a <code>value_type</code> (aka <code>pair</code>)
<ul>
<li>or an iterator pair</li>
<li>or an <code>initializer_list</code></li>
<li>or a node</li>

</ul></li>
<li><code>emplace</code> takes a parameter pack</li>
<li><code>try_emplace</code> takes a key and a parameter pack</li>
<li><code>insert_or_assign</code> takes a key and [something convertible to] a value
<ul>
<li>so does <code>operator[]</code> (without forwarding)</li>

</ul></li>
<li><code>merge</code> takes another map&#x2026;</li>

</ul>

<p>
See also: <a href="https://www.youtube.com/watch?v=kye4aD-KvTU">"A Clean and Minimal Map API"</a> &#x2013; Chandler Carruth, C++Now 2019
</p>

<aside class="notes">
<p>
This is unfortunate.
</p>

<p>
Remember when I said you'd probably reach a point in this talk when you thought
C++ is too complicated?
</p>

<p>
Actually, you probably already reached that point about 20 slides back, didn't
you&#x2026;
</p>

</aside>

</section>
<section id="slide-orgfd875b6">
<h3 id="orgfd875b6"><code>emplace</code> &amp; <code>emplace_back</code> epilogue</h3>
<p>
What to do if <code>mapped_type</code> is an aggregate? You want the rule of zero.
</p>

<p>
C++20 <a href="http://wg21.link/p0960">P0960</a>: Aggregate initialization with parentheses.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, Aggregate<span style="color: #2aa198;">&gt;</span>;

<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::piecewise_construct,
          <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">(</span><span style="color: #859900;">1</span><span style="color: #b58900;">)</span>,
          <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">(</span><span style="color: #ff00ff;">/* </span><span style="color: #ff00ff;">members of Aggregate */</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
In C++20, we get parenthesized initialization for aggregate types.
</p>

<p>
This should mean you can get in-place construction for them too without
moving(copying) and without tediously having to provide SMFs to achieve
optimality (and technically not be an aggregate).
</p>

<p>
Question: does this mean emplace can do narrowing conversions with parenthetical
initialization? And what does it do now?
</p>

</aside>

</section>
<section id="slide-orgbcea6cb">
<h3 id="orgbcea6cb">Recommendations</h3>
<p>
Yes, C++ is complicated.
</p>

<ul>
<li>Initialization: consider <code>for_each_n_args</code></li>
<li>You can use <code>insert</code> with <code>make_pair</code> and implicit construction
<ul>
<li>But don't use call-site explicit construction</li>

</ul></li>
<li>Use <code>emplace</code> but beware of explicit construction</li>
<li>Use <code>piecewise_construct</code> for other than single-arg construction</li>
<li>Use <code>operator[]</code> only when you know the key exists</li>
<li>Adopt <code>insert_or_assign</code> when you can</li>
<li>Consider <code>with_result_of</code></li>
<li>Aggregates will suck until C++20</li>

</ul>

<p>
Or, use a non-standard map with a better API
</p>

</section>
</section>
<section>
<section id="slide-org0b62ea7">
<h2 id="org0b62ea7">6. Putting stuff into other things</h2>
<p>
Like <code>optional</code>, <code>variant</code>, <code>any</code>.
</p>

<div class='vertspace2'></div>
<blockquote nil><p>&quot;There's more depends on this than on the value.&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>The Merchant of Venice</em></div></blockquote>

<aside class="notes">
<p>
This is where it gets a lot easier.
</p>

</aside>

</section>
<section id="slide-orgcb4da80">
<h3 id="orgcb4da80"><code>optional</code> and friends</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">constexpr</span> <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">optional</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">in_place_t</span>, <span style="color: #268bd2;">Args</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span> <span style="color: #268bd2;">T</span>, <span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">constexpr</span> <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">variant</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">in_place_type_t</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">T</span><span style="color: #b58900;">&gt;</span>, <span style="color: #268bd2;">Args</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">size_t</span> <span style="color: #cb4b16;">I</span>, <span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">constexpr</span> <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">variant</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">in_place_index_t</span><span style="color: #b58900;">&lt;</span>I<span style="color: #b58900;">&gt;</span>, <span style="color: #268bd2;">Args</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span> <span style="color: #268bd2;">ValueType</span>, <span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">any</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">in_place_type_t</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">ValueType</span><span style="color: #b58900;">&gt;</span>, <span style="color: #268bd2;">Args</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
All these new vocabulary types have constructors that take <code>in_place</code> tag
arguments. They work similarly to <code>piecewise_construct</code> but they're only
constructing one thing.
</p>

</aside>

</section>
<section id="slide-org4136076">
<h3 id="org4136076"><code>optional</code> construction</h3>
<p>
implicit constructor
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span> = Arg<span style="color: #2aa198;">{}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (naive method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span> = S<span style="color: #2aa198;">{</span><span style="color: #859900;">1</span><span style="color: #2aa198;">}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (in-place method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span><span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::in_place, <span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
In the first case, it's fine: just one in-place construct.
</p>

<p>
In the second case, we have an <code>explicit</code> constructor. So if we use this style,
we get a construct and a move.
</p>

<p>
The third case is the way to go for in-place construction. It can also be used
with an implicit constructor of course.
</p>

</aside>

</section>
<section id="slide-org0e4231a">
<h3 id="org0e4231a"><code>optional</code> assignment</h3>
<p>
implicit constructor
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span>;
opt = Arg<span style="color: #2aa198;">{}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (naive method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span>;
opt = S<span style="color: #2aa198;">{</span><span style="color: #859900;">1</span><span style="color: #2aa198;">}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (in-place method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span>;
opt.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Similar story here.
</p>

</aside>

</section>
<section id="slide-org0adca09">
<h3 id="org0adca09"><code>optional</code> recommendations</h3>
<ul>
<li>use the <code>in_place_t</code> constructor</li>
<li>avoid <code>explicit</code> construction</li>
<li>use <code>emplace</code> for assignment</li>

</ul>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span><span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::in_place, <span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
opt.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">2</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
You'll never go wrong with these.
</p>

<p>
Again we could use the with_result_of to in-place construct the result of a
function call.
</p>

</aside>

</section>
<section id="slide-org4d52cf5">
<h3 id="org4d52cf5"><code>variant</code> construction</h3>
<p>
implicit constructor
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = Arg<span style="color: #2aa198;">{}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (naive method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = S<span style="color: #2aa198;">{</span><span style="color: #859900;">1</span><span style="color: #2aa198;">}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (oops method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = <span style="color: #859900;">1</span>;
</pre>
</div>

<aside class="notes">
<p>
Similar story as <code>optional</code>.
</p>

<p>
But there is the potential for a bug with the <code>explicit</code> constructor. Especially
if someone changes a constructor's explicitness after code is written, or if
you're trying to do something in generic code.
</p>

</aside>

</section>
<section id="slide-orgdac6976">
<h3 id="orgdac6976"><code>variant</code> construction</h3>
<p>
Recommendation: use either of these two constructions.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">v</span><span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">in_place_type</span><span style="color: #b58900;">&lt;</span>S<span style="color: #b58900;">&gt;</span>, <span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">v</span><span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">in_place_index</span><span style="color: #b58900;">&lt;</span><span style="color: #859900;">1</span><span style="color: #b58900;">&gt;</span>, <span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
I would generally prefer the first except in cases where the same type occurs in
multiple places in the <code>variant</code>, which is relatively rarer.
</p>

</aside>

</section>
<section id="slide-org34b728b">
<h3 id="org34b728b"><code>variant</code> assignment</h3>
<p>
Similar story to construction.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;

v = Arg<span style="color: #2aa198;">{}</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">fine</span>
v = S<span style="color: #2aa198;">{</span><span style="color: #859900;">1</span><span style="color: #2aa198;">}</span>;  <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">constructs a temporary</span>
v = <span style="color: #859900;">1</span>;     <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">oops</span>
</pre>
</div>

<aside class="notes">
<p>
Trying to put an <code>S</code> in the <code>variant</code> here, accidentally putting an integer in.
</p>

</aside>

</section>
<section id="slide-orged85a18">
<h3 id="orged85a18"><code>variant</code> danger!</h3>
<p>
Implicitly-typed <code>variant</code> construction/assignment can be dangerous.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">int</span> <span style="color: #2aa198;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">bool</span>, <span style="color: #859900;">std</span>::string<span style="color: #b58900;">&gt;</span> <span style="color: #cb4b16;">v</span> = <span style="color: #D01A4E;">"Hello"</span>;
  <span style="color: #859900;">std</span>::cout &lt;&lt; <span style="color: #D01A4E;">"index is "</span> &lt;&lt; v.index<span style="color: #b58900;">()</span> &lt;&lt; <span style="color: #D01A4E;">'</span><span style="color: #5f127b; font-weight: bold;">\</span><span style="color: #b58900; font-weight: bold;">n</span><span style="color: #D01A4E;">'</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
What does this output?
</p>

<p class="fragment (appear)">C++20 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0608r3.html">P0608</a> A sane variant converting constructor</p>

<aside class="notes">
<p>
Avoid implicit type conversions. They're dangerous. The first possible one will apply.
</p>

<p>
This is fixed in 20. (Prevent narrowing conversions and conversions to bool.)
</p>

</aside>

</section>
<section id="slide-org5ba13d0">
<h3 id="org5ba13d0">Safe, efficient <code>variant</code> assignment</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">template &lt;class T, class... Args&gt;</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">T&amp; emplace(Args&amp;&amp;... args);</span>
v.emplace<span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;(</span><span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;  <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">S{1}</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">template &lt;size_t I, class... Args&gt;</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">variant_alternative_t&lt;I, variant&gt;&amp; emplace(Args&amp;&amp;... args);</span>
v.emplace<span style="color: #2aa198;">&lt;</span><span style="color: #859900;">1</span><span style="color: #2aa198;">&gt;(</span><span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;  <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">S{1}</span>
</pre>
</div>

</section>
<section id="slide-org675e66a">
<h3 id="org675e66a"><code>variant</code> recommendations</h3>
<ul>
<li>always be explicit about types</li>
<li>use <code>in_place_type</code> or <code>in_place_index</code> constructors</li>
<li>use <code>emplace&lt;T&gt;</code> or <code>emplace&lt;I&gt;</code></li>
<li>avoid <code>operator=</code> (except actual <code>variant</code>-to-<code>variant</code>)</li>

</ul>

<aside class="notes">
<p>
Obviously <code>operator=</code> is used implicitly by the compiler.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org77aa1af">
<h2 id="org77aa1af">7. Final Guidelines and Recommendations</h2>
<div class='vertspace2'></div>
<blockquote nil><p>&quot;Share the advice betwixt you; if both gain all,<br>The gift doth stretch itself as 'tis receiv'd,<br>And is enough for both.&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>All's Well That Ends Well</em></div></blockquote>

</section>
<section id="slide-orgd93982f">
<h3 id="orgd93982f">Recommendations</h3>
<div class='vertspace2'></div>

<p>
Think about copies and moves.
</p>

<p>
Moves aren't free, and may not be cheap.
</p>

<p>
Usually, in-place construction is preferable. And it is nearly always possible.
</p>

<p>
Know how RVO works, and check that the compiler is doing it when you think it is.
</p>

<p>
Study the interfaces of the containers you're using.
</p>

<p>
Beware <code>initializer_list</code>.
</p>
</section>
</section>
</div>
</div>
<script src="../reveal.js/lib/js/head.min.js"></script>
<script src="../reveal.js/js/reveal.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,

overview: true,
width: 1600,
height: 900,
margin: 0.10,
minScale: 0.50,
maxScale: 2.50,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'none', // see README of reveal.js for options
transitionSpeed: 'default',

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]

});
</script>
</body>
</html>
