<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Everyday Efficiency: In-place Construction</title>
<meta name="author" content="(Ben Deane)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="../reveal.js/css/theme/blood.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h2>Everyday Efficiency: In-place Construction</h2><div class='vertspace2'></div><blockquote nil><p>&quot;I fear these stubborn lines lack power to move&quot;</p><div></div><div class='author'>-- William Shakespeare, <em>Love's Labours Lost</em></div></blockquote><div class='vertspace3'></div><h3>Ben Deane / <a href="mailto:bdeane@blizzard.com">bdeane@blizzard.com</a> / <a href="http://twitter.com/ben_deane">@ben_deane</a></h3><h4>July 2018</h4>
</section>

<section>
<section id="slide-org65affa8">
<h2 id="org65affa8">Get Ready</h2>
<ol>
<li>What happens when we <code>move</code> something?</li>
<li>Copy elision (RVO)</li>
<li>Putting stuff into a <code>vector</code></li>
<li><code>initializer_list</code></li>
<li>Putting stuff into a <code>map</code></li>
<li>Putting stuff into other things</li>
<li>Final thoughts</li>

</ol>

<aside class="notes">
<p>
There will be a lot of code snippets in this talk.
</p>

<p>
I will be asking a lot of questions.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org17fab79">
<h2 id="org17fab79">Disclaimer</h2>
<p>
I'm going to critique some code in this talk.
</p>

<p>
If it's your code, please don't feel slighted.
</p>

<p>
I assure you that I write and have written plenty of suboptimal code.
</p>

<p>
Let's make code better together!
</p>

</section>
</section>
<section>
<section id="slide-org5e569a7">
<h2 id="org5e569a7">Preliminaries</h2>
<iframe width="1400px" height="600px" src="https://godbolt.org/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.5479341055999998,j:1,lang:c%2B%2B,source:'%23include+%3Cstdio.h%3E%0A%0Astruct+Foo+%7B%7D%3B%0A%0Astruct+S%0A%7B%0A++S()+%7B+puts(%22Default+construct%5Cn%22)%3B+%7D%0A++S(Foo)+%7B+puts(%22Implicit+value+construct%5Cn%22)%3B+%7D%0A++explicit+S(int)+%7B+puts(%22Explicit+value+construct+(1)%5Cn%22)%3B+%7D%0A++explicit+S(int,+int)+%7B+puts(%22Explicit+value+construct+(2)%5Cn%22)%3B%7D%0A++~S()+%7B+puts(%22Destruct%5Cn%22)%3B+%7D%0A++S(const+S%26)+%7B+puts(%22Copy+construct%5Cn%22)%3B+%7D%0A++S(S%26%26)+%7B+puts(%22Move+construct%5Cn%22)%3B+%7D%0A%7D%3B%0A%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:61.43386897404203,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:clang_trunk,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',trim:'1',undefined:'1'),lang:c%2B%2B,libs:!(),options:'-O3+-std%3Dc%2B%2B17',source:1),l:'5',n:'0',o:'x86-64+clang+(trunk)+(Editor+%231,+Compiler+%231)+C%2B%2B',t:'0')),k:38.56613102595797,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

<aside class="notes">
<p>
You're going to see a lot of this later in the talk, when we examine how various
snippets of code behave.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org1ae919e">
<h2 id="org1ae919e">1. What happens when we <code>move</code> something?</h2>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v1</span> = <span style="color: #707183;">{</span><span style="color: #008b8b;">1</span>, <span style="color: #008b8b;">2</span>, <span style="color: #008b8b;">3</span>, <span style="color: #008b8b;">4</span>, <span style="color: #008b8b;">5</span><span style="color: #707183;">}</span>;
<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v2</span> = move<span style="color: #707183;">(</span>v1<span style="color: #707183;">)</span>;
</pre>
</div>

<p>
What's in <code>v1</code> after the move?
</p>

<aside class="notes">
<p>
The standard says "valid but unspecified". We know that we're allowed to destroy
it, because for things to be otherwise would be a nonsense. <code>v1</code> <span class="underline">will</span> be
destroyed like any other C++ object when it goes out of scope.
</p>

<p>
Here's where we deviate from the standard. How is <code>vector</code> implemented,
basically? (pointer-to-buffer, size, capacity). On destruction, what must it do?
</p>

</aside>

</section>
<section id="slide-org20fa69c">
<h3 id="org20fa69c">A moved-from <code>vector</code></h3>
<p>
It must be destroyable.
</p>

<p>
What is sufficient? What is likely?
</p>
<ul>
<li>begin pointer is null?</li>
<li>size is zero?</li>
<li>capacity is zero?</li>

</ul>

</section>
<section id="slide-org936584d">
<h3 id="org936584d">Exhibit A</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #008b8b;">WebSocketHandshakerImpl</span>::<span style="color: #0000ff;">ProcessServerHandshake</span><span style="color: #707183;">(</span><span style="color: #228b22;">HttpMessage</span> <span style="color: #a0522d;">message</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #006400;">// </span><span style="color: #006400;">some stuff...</span>

  m_result.extra = <span style="color: #008b8b;">blz</span>::move<span style="color: #7388d6;">(</span>m_readBuffer<span style="color: #7388d6;">)</span>;
  m_result.headers = <span style="color: #008b8b;">blz</span>::move<span style="color: #7388d6;">(</span>message.headers<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
This code assumes that it's safe to do whatever comes later to a moved-from <code>vector</code>.
</p>

</section>
<section id="slide-orgd6d0291">
<h3 id="orgd6d0291">Now consider:</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">string</span> <span style="color: #a0522d;">s1</span> = <span style="color: #b22222;">"Hello, world"</span>;
<span style="color: #228b22;">string</span> <span style="color: #a0522d;">s2</span> = move<span style="color: #707183;">(</span>s1<span style="color: #707183;">)</span>;
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">string</span> <span style="color: #a0522d;">s1</span> = <span style="color: #b22222;">"Greetings, planet"</span>;
<span style="color: #228b22;">string</span> <span style="color: #a0522d;">s2</span> = move<span style="color: #707183;">(</span>s1<span style="color: #707183;">)</span>;
</pre>
</div>

<p>
What's the moved-from state of <code>s1</code>?
</p>

<aside class="notes">
<p>
What is the state of s1 in the second case? Same as the vector case basically.
</p>

<p>
But the first example is small-string optimized. What happens when you move from
a small string? You have to copy.
</p>

<p>
What is the state of s1 in the first case? It happens that all major
implementations (blz included) will set the size to zero on a move, even when in
the small string buffer. So it's actually ever so slightly <i>slower</i> than a copy.
</p>

<p>
If you're lucky, the optimizer can help you out and spot dead stores&#x2026;
</p>

<p>
Bloomberg's STL does not clear a moved-from SSO string.
</p>

</aside>

</section>
<section id="slide-org726e704">
<h3 id="org726e704">Observation</h3>
<p>
Moving from a <code>string</code> usually <i>isn't any faster</i> than copying from it.
</p>

<p>
(If you doubt this, ask yourself why the small string optimization exists in the
first place.)
</p>

<p>
Moves <i>only</i> matter for objects on the heap.
</p>

<p>
<a href="http://quick-bench.com/GtvOqmK-eltAretuiNzQQEcBxdY">http://quick-bench.com/GtvOqmK-eltAretuiNzQQEcBxdY</a>
</p>

<aside class="notes">
<p>
And as noted, it may be technically slower.
</p>

</aside>

</section>
<section id="slide-org4dc43aa">
<h3 id="org4dc43aa">Exhibit B</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #008b8b;">Context</span>::<span style="color: #0000ff;">Trigger</span><span style="color: #707183;">(</span><span style="color: #006400;">/* </span><span style="color: #006400;">some args */</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #006400;">// </span><span style="color: #006400;">Make sure that it will trigger only once.</span>
  <span style="color: #a020f0;">const</span> <span style="color: #228b22;">OnResponseCallback</span> <span style="color: #a0522d;">cb</span> = <span style="color: #008b8b;">blz</span>::move<span style="color: #7388d6;">(</span>m_responseCallback<span style="color: #7388d6;">)</span>;

  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>cb<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">{</span>
    cb<span style="color: #909183;">(</span>errorCode, errorReason, payload, size, opaque<span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
Is this comment telling the truth?
</p>

<aside class="notes">
<p>
Playing with fire. The comment is misleading. We're relying on implementation.
</p>

<p>
Function has a small buffer optimization just like string. There's no reason for
function to be null after a move.
</p>

<p>
Think back to the vector case now: what happens if the container is replaced
with a small-buffer optimizable container?
</p>

</aside>

</section>
<section id="slide-org60c9d53">
<h3 id="org60c9d53">Guideline (specific)</h3>
<p>
Don't assume things are empty after a <code>move</code>.
</p>

<p>
Use <code>exchange</code> to make sure. Assigning an empty object is a trivial price for
safety.
</p>

<div class="org-src-container">

<pre  class="src src-c++">m_result.extra = <span style="color: #008b8b;">blz</span>::exchange<span style="color: #707183;">(</span>m_readBuffer, <span style="color: #7388d6;">{}</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">const</span> <span style="color: #228b22;">OnResponseCallback</span> <span style="color: #a0522d;">cb</span> = <span style="color: #008b8b;">blz</span>::exchange<span style="color: #707183;">(</span>m_responseCallback, <span style="color: #008b8b;">nullptr</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Make your code safe for future small-buffer optimizations.
</p>

</section>
<section id="slide-org012f46d">
<h3 id="org012f46d">Guideline (more general)</h3>
<p>
If you didn't write the move constructor/operator yourself, after a <code>move</code>, you
may assume:
</p>

<ul>
<li>the object is destroyable</li>
<li>the object is (re-)assignable</li>

</ul>

<p>
<i>NOTHING ELSE</i>
</p>

<p>
Note: This is a stronger constraint than what the standard says.
</p>

<aside class="notes">
<p>
[defns.valid] "the object's invariants are met and operations on the object
behave as specified for its type"
</p>

<p>
The standard says you can call any function without preconditions.
</p>

<p>
But I'm not saying anything that, I'm just saying something <i>more</i> constrained,
and safer.
</p>

</aside>

</section>
<section id="slide-org7386f70">
<h3 id="org7386f70">Let's look at this again</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #008b8b;">WebSocketHandshakerImpl</span>::<span style="color: #0000ff;">ProcessServerHandshake</span><span style="color: #707183;">(</span><span style="color: #228b22;">HttpMessage</span> <span style="color: #a0522d;">message</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #006400;">// </span><span style="color: #006400;">some stuff...</span>

  <span style="color: #006400;">// </span><span style="color: #006400;">which would be right here? this?</span>
  m_result.headers = <span style="color: #008b8b;">blz</span>::move<span style="color: #7388d6;">(</span>message.headers<span style="color: #7388d6;">)</span>;

  <span style="color: #006400;">// </span><span style="color: #006400;">or this?</span>
  m_result.headers = <span style="color: #008b8b;">blz</span>::move<span style="color: #7388d6;">(</span>message<span style="color: #7388d6;">)</span>.headers;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
The first option is saying a much stronger thing. The result of <code>move</code> is always
an rvalue reference. That's literally all <code>move</code> does: a cast to an rvalue
reference.
</p>

<p>
The second one is using C++ member access rules to infer the rvalue-ness of the
member. That's fine. We still get the rvalue.
</p>

<p>
The first one is saying "this is definitely an rvalue - trust me!".
</p>

<p>
The second is saying "hey, this is an rvalue, unless something else prevents it".
</p>

<p>
So what would "prevent it"?
</p>

</aside>

</section>
<section id="slide-org0953982">
<h3 id="org0953982">There may be trouble ahead</h3>
<p>
Let's say we want always want pretty much the same headers for all requests.
</p>

<p>
What if we decided to change this&#x2026;
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">HttpMessage</span>
<span style="color: #707183;">{</span>
  <span style="color: #008b8b;">blz</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">requestLine</span>;
  <span style="color: #228b22;">Headers</span> <span style="color: #a0522d;">headers</span>;
<span style="color: #707183;">}</span>;
</pre>
</div>
<p>
&#x2026;to this?
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">HttpMessage</span>
<span style="color: #707183;">{</span>
  <span style="color: #008b8b;">blz</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">requestLine</span>;
  <span style="color: #228b22;">Headers</span>&amp; <span style="color: #a0522d;">headers</span>;
<span style="color: #707183;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
What happens when we change <code>Header</code> to a reference?
</p>

<p>
The HttpMessage itself can be an rvalue, but what it's referencing isn't.
</p>

</aside>

</section>
<section id="slide-org03616a3">
<h3 id="org03616a3">Guideline</h3>
<p>
Use <code>move(obj).member</code> rather than <code>move(obj.member)</code>
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">always safe, non-reference member is still an rvalue</span>
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">x</span> = move<span style="color: #707183;">(</span>obj<span style="color: #707183;">)</span>.member;

<span style="color: #006400;">// </span><span style="color: #006400;">could erroneously move from an lvalue-ref!</span>
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">x</span> = move<span style="color: #707183;">(</span>obj.member<span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
If we cast obj to an rvalue-ref, its member will also (usually) be an rvalue
ref, no problem. We aren't losing anything and we're gaining safety.
</p>

</aside>

</section>
<section id="slide-org48bf1fd">
<h3 id="org48bf1fd"><code>move</code> safety guidelines</h3>
<ul>
<li>after <code>move</code>, destroy or assign <i>only</i></li>
<li>use <code>exchange</code> to move-and-clear</li>
<li>use <code>move(obj).member</code>, not <code>move(obj.member)</code></li>

</ul>

<aside class="notes">
<p>
The last two points here are useful a lot of the time for writing move
constructors. You're going to be working in terms of the subobjects.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org9645816">
<h2 id="org9645816">2. Copy Elision (RVO)</h2>
<p>
What is the return value optimization?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">string</span> <span style="color: #0000ff;">bar</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">string</span> <span style="color: #a0522d;">a</span><span style="color: #7388d6;">{</span><span style="color: #b22222;">"Hi"</span><span style="color: #7388d6;">}</span>;
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">b</span> = <span style="color: #008b8b;">42</span>;
  <span style="color: #006400;">// </span><span style="color: #006400;">...</span>
  <span style="color: #a020f0;">return</span> a;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">foo</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">string</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">{</span>bar<span style="color: #909183;">()</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
The caller sets aside space in its own stack frame for the result of the
function, and the callee constructs the result directly in that space.
</p>

<p>
bar() has two local variables.
</p>

<p>
when foo() calls bar() it "passes" the address of the stack variable s.
</p>

</aside>

</section>
<section id="slide-org2c2f084">
<h3 id="org2c2f084">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org451ec04">
<h3 id="org451ec04">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orgbe28542">
<h3 id="orgbe28542">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo3.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orgcbeb16a">
<h3 id="orgcbeb16a">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo4.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orgd9db599">
<h3 id="orgd9db599">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo5.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org26c3342">
<h3 id="org26c3342">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orgba1fa14">
<h3 id="orgba1fa14">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orgb1bfbaa">
<h3 id="orgb1bfbaa">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo3.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orgd6c4b1f">
<h3 id="orgd6c4b1f">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo4.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orgf9cf055">
<h3 id="orgf9cf055">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo5.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org6083823">
<h3 id="org6083823">When can RVO not apply?</h3>
<p>
RVO Rules: what is returned has to be either:
</p>

<ul>
<li>a temporary (prvalue)</li>
<li>the name of a stack variable</li>

</ul>

</section>
<section id="slide-org3affefc">
<h3 id="org3affefc">When can RVO not apply?</h3>
<p>
RVO Ability: sometimes, the callee <i>can't</i> construct the object in-place.
</p>

<ul>
<li>if there is no opportunity to</li>
<li>if it's not of the right type</li>
<li>if the callee doesn't know enough</li>

</ul>

<aside class="notes">
<p>
Function arguments that are passed to you already-constructed can't be RVOed on
return. But you can move them.
</p>

<p>
You have to know at construction time that you're going to be returning that
variable in order to RVO it.
</p>

</aside>

</section>
<section id="slide-orgee66edc">
<h3 id="orgee66edc">No RVO because no opportunity</h3>
<p>
You can't RVO a variable if you didn't get the chance to construct it in the
first place.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">string</span> <span style="color: #0000ff;">sad_function</span><span style="color: #707183;">(</span><span style="color: #228b22;">string</span> <span style="color: #a0522d;">s</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  s += <span style="color: #b22222;">"No RVO for you!"</span>;
  <span style="color: #a020f0;">return</span> s;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
But the compiler will still move it. (Since C++11)
</p>

<aside class="notes">
<p>
C++11 mandates that if you can't do the RVO, you must try to move and only copy
as a last resort.
</p>

</aside>

</section>
<section id="slide-orgcfcc730">
<h3 id="orgcfcc730">No RVO because wrong type, 1</h3>
<p>
An rvalue-ref is not the same type.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">string</span> <span style="color: #0000ff;">sad_function</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">string</span> <span style="color: #a0522d;">s</span> = <span style="color: #b22222;">"No RVO for you!"</span>;
  <span style="color: #a020f0;">return</span> move<span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
Don't <code>return move(x)</code> in most cases - you will get a move when you didn't need anything!
</p>

<aside class="notes">
<p>
There are legitimate cases for returning an rvalue reference.
</p>

<p>
One of the few times when <code>return move(x)</code> is proper is when you're returning a
member variable out of a rvalue-ref-qualified member function.
</p>

</aside>

</section>
<section id="slide-org82ea856">
<h3 id="org82ea856">No RVO because wrong type, 2</h3>
<p>
Factory functions can't RVO.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Base</span> <span style="color: #707183;">{</span> <span style="color: #0000ff;">...</span> <span style="color: #707183;">}</span>;
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Derived</span> : <span style="color: #228b22;">Base</span> <span style="color: #707183;">{</span> <span style="color: #0000ff;">...</span> <span style="color: #707183;">}</span>;

<span style="color: #228b22;">shared_ptr</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">Base</span><span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">factory</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> make_shared<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Derived</span><span style="color: #7388d6;">&gt;()</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
But will still move.
</p>

<aside class="notes">
<p>
This is also true of any types that are inter-convertible.
e.g. returning a pair when the function returns a tuple, or something like that.
</p>

</aside>

</section>
<section id="slide-org7038cd4">
<h3 id="org7038cd4">No RVO because not enough info</h3>
<p>
It has to be decidable at construction time.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">string</span> <span style="color: #0000ff;">undecided_function</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">string</span> <span style="color: #a0522d;">happy</span> = <span style="color: #b22222;">"Hooray"</span>;
  <span style="color: #228b22;">string</span> <span style="color: #a0522d;">sad</span> = <span style="color: #b22222;">"Boo hoo"</span>;

  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>getHappiness<span style="color: #909183;">()</span> &gt; <span style="color: #008b8b;">0.5</span><span style="color: #7388d6;">)</span>
    <span style="color: #a020f0;">return</span> happy;
  <span style="color: #a020f0;">else</span>
    <span style="color: #a020f0;">return</span> sad;
<span style="color: #707183;">}</span>

</pre>
</div>
<p>
Again, return value will still be moved.
</p>

</section>
<section id="slide-orgcb0fbad">
<h3 id="orgcb0fbad">Quiz time</h3>
<p>
Wake up!
</p>

<p>
And tell me if the upcoming code snippets will activate RVO.
</p>

</section>
<section id="slide-org72af58c">
<h3 id="org72af58c">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">const</span> <span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes.
</p>

<aside class="notes">
<p>
Yes. You're allowed to cv-qualify return types and RVO still works.
</p>

<p>
But don't do this. The compiler ignores const-qualified builtin types anyway.
</p>

</aside>

</section>
<section id="slide-org5c284d8">
<h3 id="org5c284d8">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>b<span style="color: #7388d6;">)</span>
    <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">else</span>
    <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes.
</p>

<aside class="notes">
<p>
Yes. This is URVO, and works pretty reliably even in debug builds.
</p>

</aside>

</section>
<section id="slide-org2ba5a95">
<h3 id="org2ba5a95">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span>, <span style="color: #228b22;">S</span> <span style="color: #a0522d;">s</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>b<span style="color: #7388d6;">)</span>
    s = S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">return</span> s;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
No. (No opportunity.)
</p>

<aside class="notes">
<p>
No - can't RVO a function parameter. It will move though.
</p>

</aside>

</section>
<section id="slide-org775958b">
<h3 id="org775958b">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">get_S</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span> <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>; <span style="color: #707183;">}</span>

<span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>b<span style="color: #7388d6;">)</span>
    <span style="color: #a020f0;">return</span> get_S<span style="color: #7388d6;">()</span>;
  <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes. (Can RVO all the way down the callstack.)
</p>

<aside class="notes">
<p>
Yes. This RVOs.
RVO is allowed to elide multiple copies.
</p>

</aside>

</section>
<section id="slide-org3f3a094">
<h3 id="org3f3a094">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>b<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">{</span>
    <span style="color: #228b22;">S</span> <span style="color: #a0522d;">s</span><span style="color: #909183;">{</span><span style="color: #008b8b;">1</span><span style="color: #909183;">}</span>;
    <span style="color: #a020f0;">return</span> s;
  <span style="color: #7388d6;">}</span>
  <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes (Clang), no (MSVC/GCC).
</p>

<aside class="notes">
<p>
There's nothing stopping it&#x2026; but only Clang successfully RVO's this.
</p>

</aside>

</section>
<section id="slide-org064162d">
<h3 id="org064162d">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">S</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>b<span style="color: #7388d6;">)</span>
    <span style="color: #a020f0;">return</span> s;
  <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
No. Possibly in future?
</p>

<aside class="notes">
<p>
We hoisted the S out of the condition.
</p>

<p>
No RVO here (a sufficiently smart compiler might be able to&#x2026;)
</p>

<p>
It still moves.
</p>

</aside>

</section>
<section id="slide-org6f9610a">
<h3 id="org6f9610a">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">S</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">return</span> b ? s : S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
No. (Against the rules.)
</p>

<aside class="notes">
<p>
No RVO. We're not naming a variable.
Will it still move? No.
</p>

<p>
We're not naming a variable. And it's not a prvalue - the conditional operator
produces an lvalue reference here. We have to copy.
</p>

<p>
This is perhaps a semi-common pattern that defeats RVO!
</p>

</aside>

</section>
<section id="slide-org2e43c3e">
<h3 id="org2e43c3e">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">get_S</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span> <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>; <span style="color: #707183;">}</span>

<span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> b ? get_S<span style="color: #7388d6;">()</span> : S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes. (Returning temporary.)
</p>

<aside class="notes">
<p>
This RVOs. This time the conditional operator produces a prvalue because both of
its operands are prvalues.
</p>

</aside>

</section>
<section id="slide-orgacbb198">
<h3 id="orgacbb198">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">S</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
  s = S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">2</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">return</span> s;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes.
</p>

<aside class="notes">
<p>
Yep. Plain NRVO.
</p>

</aside>

</section>
<section id="slide-orgef926d2">
<h3 id="orgef926d2">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">S</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes. Identifiers are allowed to be parenthesized in the <code>return</code> expression.
</p>

<aside class="notes">
<p>
The standard explicitly allows this.
</p>

<p>
However&#x2026; there seems to be a bug in GCC where it doesn't RVO this. MSVC does
and Clang does.
</p>

<p>
Technically GCC is still adhering to the standard, because it's not required to
RVO. It does in C++11 mode, just not in C++14 or C++17 mode.
</p>

</aside>

</section>
<section id="slide-org24b65a9">
<h3 id="org24b65a9">Exhibit C</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #228b22;">long</span> <span style="color: #0000ff;">Time</span><span style="color: #707183;">()</span> <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">override</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">ts</span> = <span style="color: #008b8b;">blz</span>::get<span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">blz</span>::move<span style="color: #909183;">(</span><span style="color: #008b8b;">Base</span>::metrics_-&gt;GetDataPointAndTime<span style="color: #709870;">()</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">return</span> ts;
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
Superfluous (potentially dangerous?) call to <code>move</code>.
</p>

<p>
NRVO is not guaranteed in debug mode. Better:
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #228b22;">long</span> <span style="color: #0000ff;">Time</span><span style="color: #707183;">()</span> <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">override</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">blz</span>::get<span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">Base</span>::metrics_-&gt;GetDataPointAndTime<span style="color: #909183;">()</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Just an integral type here, so no big deal. But if it gets changed, or this
pattern gets copied&#x2026;
</p>

</aside>

</section>
<section id="slide-orgd592871">
<h3 id="orgd592871">Guidelines for RVO-friendliness</h3>
<ul>
<li>don't const-qualify returned value types</li>
<li>almost never return <code>move(x)</code></li>
<li>return temporaries where you can</li>
<li>when you return named things, avoid conditions</li>
<li>don't parenthesize return expressions</li>

</ul>

<aside class="notes">
<p>
First point does not affect RVO but is generally useless.
</p>

<p>
URVO is easier for the compiler than NRVO. You are likely to get URVO in debug
builds.
</p>

<p>
Beware of the conditional operator.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org6ab2a3e">
<h2 id="org6ab2a3e">3. Putting stuff into a <code>vector</code></h2>
<p>
Should you use <code>push_back</code> or should you use <code>emplace_back</code>?
</p>

<p>
How should you use them?
</p>

</section>
<section id="slide-org4074f53">
<h3 id="org4074f53"><code>push_back</code> and <code>emplace_back</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">push_back</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">T</span>&amp; <span style="color: #a0522d;">x</span><span style="color: #707183;">)</span>;
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">push_back</span><span style="color: #707183;">(</span><span style="color: #228b22;">T</span>&amp;&amp; <span style="color: #a0522d;">x</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">reference</span> <span style="color: #0000ff;">emplace_back</span><span style="color: #707183;">(</span><span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Until C++17, <code>emplace_back</code> returns <code>void</code>.
</p>

<p>
<code>blz</code>'s emplace<sub>back</sub> returns a reference.
</p>

</aside>

</section>
<section id="slide-orgcf1c858">
<h3 id="orgcf1c858">Example 1</h3>
<p>
What's the difference here?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">string</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #228b22;">string</span> <span style="color: #a0522d;">s</span>;
<span style="color: #006400;">// </span><span style="color: #006400;">...</span>

v.push_back<span style="color: #707183;">(</span>move<span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
v.emplace_back<span style="color: #707183;">(</span>move<span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
There is no difference.
</p>

</aside>

</section>
<section id="slide-orgb2a07bd">
<h3 id="orgb2a07bd">Example 1.1</h3>
<p>
What's the difference here?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">string</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #228b22;">string</span> <span style="color: #a0522d;">s</span>;
<span style="color: #006400;">// </span><span style="color: #006400;">...</span>

v.push_back<span style="color: #707183;">(</span>move<span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
<span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">last_s</span> = v.emplace_back<span style="color: #707183;">(</span>move<span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
If we want to capture a reference to the thing that was pushed, we can use
<code>emplace_back</code>.
</p>

</aside>

</section>
<section id="slide-org68573fb">
<h3 id="org68573fb">Example 2</h3>
<p>
What's the difference here?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">string</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span> = <span style="color: #b22222;">"Hello"</span>;
<span style="color: #006400;">// </span><span style="color: #006400;">...</span>

v.push_back<span style="color: #707183;">(</span>s<span style="color: #707183;">)</span>;
v.emplace_back<span style="color: #707183;">(</span>s<span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
<code>push_back</code> constructs a temporary then moves it.
</p>

<p>
<code>emplace_back</code> constructs directly in place.
</p>

<p>
Remember, for string, a move is usually as expensive as a copy.
</p>

</aside>

</section>
<section id="slide-orgb5b0058">
<h3 id="orgb5b0058">Example 2.1</h3>
<p>
Default in-place construct.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">first default-construct in the vector</span>
<span style="color: #228b22;">S</span>&amp; <span style="color: #a0522d;">s</span> = v.emplace_back<span style="color: #707183;">()</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">now mutate s</span>
<span style="color: #006400;">// </span><span style="color: #006400;">...</span>
</pre>
</div>

<p>
<code>emplace_back</code> takes a parameter pack. Parameter packs can be empty.
</p>

<aside class="notes">
<p>
<code>emplace_back</code> is especially useful for this use case.
</p>

</aside>

</section>
<section id="slide-orgd38b2db">
<h3 id="orgd38b2db">Example 3</h3>
<p>
In-place construct with <code>explicit</code> constructor.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">recall: S has an explicit constructor from int</span>
<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">push_back can't do explicit construction</span>
v.push_back<span style="color: #707183;">(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;  <span style="color: #006400;">// </span><span style="color: #006400;">compiler error!</span>

<span style="color: #006400;">// </span><span style="color: #006400;">explicit construction is no problem for emplace_back</span>
<span style="color: #228b22;">S</span>&amp; <span style="color: #a0522d;">s</span> = v.emplace_back<span style="color: #707183;">(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
<code>emplace_back</code> does perfect forwarding. It can call <code>explicit</code> constructors.
</p>

<aside class="notes">
<p>
<code>emplace_back</code> is especially useful for this use case.
</p>

</aside>

</section>
<section id="slide-orgb847ab7">
<h3 id="orgb847ab7">Example: copy</h3>
<p>
Recall: our <code>S</code> class has a constructor from <code>Foo</code>, and an <code>explicit</code> constructor
from <code>int</code>.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #228b22;">array</span><span style="color: #707183;">&lt;</span>Foo, N<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">a</span> = <span style="color: #707183;">{</span> <span style="color: #0000ff;">...</span> <span style="color: #707183;">}</span>;
v.reserve<span style="color: #707183;">(</span>a.size<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>;

copy<span style="color: #707183;">(</span>a.cbegin<span style="color: #7388d6;">()</span>, a.cend<span style="color: #7388d6;">()</span>, back_inserter<span style="color: #7388d6;">(</span>v<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
What does <code>back_insert_iterator</code> do here?
</p>

<aside class="notes">
<p>
For each element, we construct an <code>S</code> (from the <code>Foo</code>) and then we move it into
the <code>vector</code>.
</p>

</aside>

</section>
<section id="slide-org43e85c9">
<h3 id="org43e85c9">Example: copy</h3>
<p>
What if we have an <code>array</code> of <code>int</code>?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #228b22;">array</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, N<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">a</span> = <span style="color: #707183;">{</span> <span style="color: #0000ff;">...</span> <span style="color: #707183;">}</span>;
v.reserve<span style="color: #707183;">(</span>a.size<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>;

copy<span style="color: #707183;">(</span>a.cbegin<span style="color: #7388d6;">()</span>, a.cend<span style="color: #7388d6;">()</span>, back_inserter<span style="color: #7388d6;">(</span>v<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p class="fragment (appear)">
Oops. The compiler is angry at us.
</p>

<aside class="notes">
<p>
<code>back_insert_iterator</code> calls <code>push_back</code> - it can't call our explicit
constructor.
</p>

</aside>

</section>
<section id="slide-org70bfaf4">
<h3 id="org70bfaf4">Example: copy?</h3>
<p>
OK, no problem, right?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #228b22;">array</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, N<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">a</span> = <span style="color: #707183;">{</span> <span style="color: #0000ff;">...</span> <span style="color: #707183;">}</span>;
v.reserve<span style="color: #707183;">(</span>a.size<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>;

transform<span style="color: #707183;">(</span>a.cbegin<span style="color: #7388d6;">()</span>, a.cend<span style="color: #7388d6;">()</span>, back_inserter<span style="color: #7388d6;">(</span>v<span style="color: #7388d6;">)</span>,
          <span style="color: #7388d6;">[]</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span> <span style="color: #a020f0;">return</span> S<span style="color: #909183;">{</span>i<span style="color: #909183;">}</span>; <span style="color: #7388d6;">}</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
For each element, we construct an <code>S</code> (from the <code>int</code>) and then we move it into
the <code>vector</code>. No extra cost over the first solution, because the <code>return</code> from the
lambda RVOs.
</p>

<p>
But what we actually want to do is construct in place.
</p>

</aside>

</section>
<section id="slide-org4900b43">
<h3 id="org4900b43"><code>back_emplacer</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Container</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">back_emplace_iterator</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">back_emplace_iterator</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">Container</span>&amp; <span style="color: #a0522d;">c</span><span style="color: #7388d6;">)</span> : c<span style="color: #7388d6;">(</span>&amp;c<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{}</span>

  <span style="color: #228b22;">back_emplace_iterator</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">++</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{</span> <span style="color: #a020f0;">return</span> *<span style="color: #a020f0;">this</span>; <span style="color: #7388d6;">}</span>
  <span style="color: #228b22;">back_emplace_iterator</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">*</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{</span> <span style="color: #a020f0;">return</span> *<span style="color: #a020f0;">this</span>; <span style="color: #7388d6;">}</span>

  <span style="color: #a020f0;">template</span> <span style="color: #7388d6;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Arg</span><span style="color: #7388d6;">&gt;</span>
  <span style="color: #228b22;">back_emplace_iterator</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">=</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">Arg</span>&amp;&amp; <span style="color: #a0522d;">arg</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
    c-&gt;emplace_back<span style="color: #909183;">(</span>forward<span style="color: #709870;">&lt;</span><span style="color: #228b22;">Arg</span><span style="color: #709870;">&gt;(</span><span style="color: #a0522d;">arg</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>;
    <span style="color: #a020f0;">return</span> *<span style="color: #a020f0;">this</span>;
  <span style="color: #7388d6;">}</span>

<span style="color: #a020f0;">private</span>:
  <span style="color: #228b22;">Container</span>* <span style="color: #a0522d;">c</span>;
<span style="color: #707183;">}</span>;
</pre>
</div>

</section>
<section id="slide-org79017a7">
<h3 id="org79017a7"><code>back_emplacer</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Container</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">back_emplacer</span><span style="color: #707183;">(</span><span style="color: #228b22;">Container</span>&amp; <span style="color: #a0522d;">c</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> back_emplace_iterator<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Container</span><span style="color: #7388d6;">&gt;(</span>c<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-orgac93a07">
<h3 id="orgac93a07"><code>back_emplacer</code></h3>
<p>
What if we have an <code>array</code> of <code>int</code>?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #228b22;">array</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, N<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">a</span> = <span style="color: #707183;">{</span> <span style="color: #0000ff;">...</span> <span style="color: #707183;">}</span>;
v.reserve<span style="color: #707183;">(</span>a.size<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>;

copy<span style="color: #707183;">(</span>a.cbegin<span style="color: #7388d6;">()</span>, a.cend<span style="color: #7388d6;">()</span>, back_emplacer<span style="color: #7388d6;">(</span>v<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Now it works. And constructs in place.
</p>

</section>
<section id="slide-org1786673">
<h3 id="org1786673">Exhibit D</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">blz</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">blz</span>::string_view<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">tokens</span>;
<span style="color: #006400;">// </span><span style="color: #006400;">...</span>
<span style="color: #008b8b;">blz</span>::<span style="color: #228b22;">string_view</span> <span style="color: #a0522d;">token</span> = <span style="color: #006400;">/* </span><span style="color: #006400;">stuff */</span>;
tokens.emplace_back<span style="color: #707183;">(</span><span style="color: #008b8b;">blz</span>::move<span style="color: #7388d6;">(</span>token<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
A few things here:
</p>
<ul>
<li><code>string_view</code> is a pointer + length. recommendation is to pass by value;
<code>move</code> gains nothing anyway.</li>
<li><code>push_back</code> works with rvalues just fine - <code>emplace_back</code> gains nothing here.</li>
<li>if you want to, you should pass <code>/* stuff */</code> directly to <code>emplace_back</code>.</li>

</ul>

</aside>

</section>
<section id="slide-org96c95be">
<h3 id="org96c95be">Exhibit E</h3>
<div class="org-src-container">

<pre  class="src src-c++">context-&gt;m_result-&gt;m_headers.emplace_back<span style="color: #707183;">(</span>string<span style="color: #7388d6;">(</span>headerData, numBytes<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
A superfluous move! Better:
</p>

<div class="org-src-container">

<pre  class="src src-c++">context-&gt;m_result-&gt;m_headers.emplace_back<span style="color: #707183;">(</span>headerData, numBytes<span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Don't explicitly call a constructor with <code>emplace_back</code>.
</p>

<aside class="notes">
<p>
And remember, likely a superfluous copy if the string is small-buffer-optimized.
</p>

</aside>

</section>
<section id="slide-org1498fc0">
<h3 id="org1498fc0"><code>vector</code> of <code>pair</code> = <code>map</code></h3>
<p>
Sometimes, we use a  sorted <code>vector</code> of <code>pair</code> as a replacement for <code>map</code>.
</p>

<p>
What do you do if part of your <code>pair</code> has a multi-argument constructor?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Foo</span> <span style="color: #707183;">{</span> <span style="color: #0000ff;">Foo</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span>, <span style="color: #228b22;">string</span>, <span style="color: #228b22;">double</span><span style="color: #7388d6;">)</span>; <span style="color: #707183;">}</span>;

<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">pair</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span>, <span style="color: #228b22;">Foo</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">this is very common!</span>
v.push_back<span style="color: #707183;">(</span>make_pair<span style="color: #7388d6;">(</span><span style="color: #008b8b;">1</span>, Foo<span style="color: #909183;">{</span><span style="color: #008b8b;">42</span>, <span style="color: #b22222;">"hello"</span>, <span style="color: #008b8b;">3.14</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">this is no better</span>
v.emplace_back<span style="color: #707183;">(</span>make_pair<span style="color: #7388d6;">(</span><span style="color: #008b8b;">1</span>, Foo<span style="color: #909183;">{</span><span style="color: #008b8b;">42</span>, <span style="color: #b22222;">"hello"</span>, <span style="color: #008b8b;">3.14</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">how can we do better?</span>
v.emplace_back<span style="color: #707183;">(</span> <span style="color: #006400;">/* </span><span style="color: #006400;">what here? */</span> <span style="color: #707183;">)</span>;
</pre>
</div>

</section>
<section id="slide-org3744240">
<h3 id="org3744240"><code>piecewise_construct</code> to the rescue!</h3>
<p>
<code>pair</code> has a constructor that will handle your multi-argument constructor.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args1</span>, <span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args2</span><span style="color: #707183;">&gt;</span>
<span style="color: #0000ff;">pair</span><span style="color: #707183;">(</span><span style="color: #228b22;">piecewise_construct_t</span>,
     <span style="color: #228b22;">tuple</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Args1</span><span style="color: #0000ff;">...</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">first_args</span>,
     <span style="color: #228b22;">tuple</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Args2</span><span style="color: #0000ff;">...</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">second_args</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Types</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">tuple</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">Types</span>&amp;&amp;<span style="color: #0000ff;">...</span><span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">forward_as_tuple</span><span style="color: #707183;">(</span><span style="color: #228b22;">Types</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span> <span style="color: #a020f0;">noexcept</span>;
</pre>
</div>

<p>
<code>piecewise_construct_t</code> is a tag type.
</p>

</section>
<section id="slide-orge73e30b">
<h3 id="orge73e30b">Using <code>piecewise_construct</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Foo</span> <span style="color: #707183;">{</span> <span style="color: #0000ff;">Foo</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span>, <span style="color: #228b22;">string</span>, <span style="color: #228b22;">double</span><span style="color: #7388d6;">)</span>; <span style="color: #707183;">}</span>;

<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">pair</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span>, <span style="color: #228b22;">Foo</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">instead of this...</span>
v.push_back<span style="color: #707183;">(</span>make_pair<span style="color: #7388d6;">(</span><span style="color: #008b8b;">1</span>, Foo<span style="color: #909183;">{</span><span style="color: #008b8b;">42</span>, <span style="color: #b22222;">"hello"</span>, <span style="color: #008b8b;">3.14</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">...we can do this</span>
v.emplace_back<span style="color: #707183;">(</span>
  make_pair<span style="color: #7388d6;">(</span>piecewise_construct,
            forward_as_tuple<span style="color: #909183;">(</span><span style="color: #008b8b;">1</span><span style="color: #909183;">)</span>,                   <span style="color: #006400;">// </span><span style="color: #006400;">args to int "constructor"</span>
            forward_as_tuple<span style="color: #909183;">(</span><span style="color: #008b8b;">42</span>, <span style="color: #b22222;">"hello"</span>, <span style="color: #008b8b;">3.14</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">args to Foo constructor</span>
</pre>
</div>
<p>
Perfect forwarding and in-place construction.
</p>

</section>
<section id="slide-org323c213">
<h3 id="org323c213">Recommendations</h3>
<ul>
<li><code>push_back</code> is perfectly fine for rvalues</li>
<li>use <code>emplace_back</code> only when you need its powers
<ul>
<li>in-place construction (including nullary construction)</li>
<li>a reference to what's added (C++17)</li>

</ul></li>
<li>never pass an explicit temporary to <code>emplace_back</code></li>
<li>try to construct in place when you can</li>
<li>use <code>piecewise_construct</code> / <code>forward_as_tuple</code> to forward args through <code>pair</code></li>

</ul>

</section>
</section>
<section>
<section id="slide-org3ddfb57">
<h2 id="org3ddfb57">4. <code>initializer_list</code></h2>
<p>
How does it work?
</p>

<p>
What are its limits?
</p>

</section>
<section id="slide-orgde57c0a">
<h3 id="orgde57c0a">What is <code>initializer_list</code>?</h3>
<p>
When you write:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span><span style="color: #707183;">{</span> <span style="color: #008b8b;">1</span>,<span style="color: #008b8b;">2</span>,<span style="color: #008b8b;">3</span> <span style="color: #707183;">}</span>;
</pre>
</div>
<p>
It's as if you wrote:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">a</span><span style="color: #707183;">[]</span> = <span style="color: #707183;">{</span> <span style="color: #008b8b;">1</span>,<span style="color: #008b8b;">2</span>,<span style="color: #008b8b;">3</span> <span style="color: #707183;">}</span>;
<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = initializer_list<span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;(</span>a, a+<span style="color: #008b8b;">3</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Notice: the backing array is <code>const</code>.
</p>

</aside>

</section>
<section id="slide-orgcceaf28">
<h3 id="orgcceaf28"><code>initializer_list</code> has <code>const</code> storage, 1</h3>
<p>
The compiler is free to locate that array elsewhere in memory.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">f</span><span style="color: #707183;">()</span> <span style="color: #707183;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">j</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">k</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #228b22;">initializer_list</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;{</span> i,j,k <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
But it may not&#x2026;
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">f</span><span style="color: #707183;">()</span> <span style="color: #707183;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">j</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">k</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">a</span><span style="color: #7388d6;">[]</span> = <span style="color: #7388d6;">{</span> i,j,k <span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">return</span> initializer_list<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;(</span>a, a+<span style="color: #008b8b;">3</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
&#x2026;and then you've returned a dangling reference.
</p>

<aside class="notes">
<p>
This is nasty, because it could work on one compiler and you wouldn't notice it.
</p>

<p>
The compiler probably won't warn for this.
</p>

<p>
<code>initializer_list</code> is a "view" type like <code>string_view</code> and doesn't own its
contents.
</p>

</aside>

</section>
<section id="slide-org71cbe24">
<h3 id="org71cbe24"><code>initializer_list</code> has <code>const</code> storage, 2</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">unique_ptr</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = <span style="color: #707183;">{</span> make_unique<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span>, make_unique<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">2</span><span style="color: #7388d6;">)</span> <span style="color: #707183;">}</span>;
</pre>
</div>
<p>
That also means <code>move</code> can't work.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">const</span> <span style="color: #228b22;">unique_ptr</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">a</span><span style="color: #707183;">[]</span> = <span style="color: #707183;">{</span> make_unique<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span>,
                              make_unique<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">2</span><span style="color: #7388d6;">)</span> <span style="color: #707183;">}</span>;
<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">unique_ptr</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> =
  initializer_list<span style="color: #707183;">&lt;</span><span style="color: #228b22;">unique_ptr</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;(</span>a, a+<span style="color: #008b8b;">3</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
You can't move from an <code>initializer_list</code> - this won't compile.
</p>

</aside>

</section>
<section id="slide-org1676151">
<h3 id="org1676151">But they're so convenient!</h3>
<p>
I'd much rather write:
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = <span style="color: #707183;">{</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>, S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">2</span><span style="color: #7388d6;">}</span>, S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">3</span><span style="color: #7388d6;">}</span> <span style="color: #707183;">}</span>;
</pre>
</div>
<p>
(3 constructs, 3 copies, 3 destructs)
</p>

<p>
Than:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
v.reserve<span style="color: #707183;">(</span><span style="color: #008b8b;">3</span><span style="color: #707183;">)</span>;
v.emplace_back<span style="color: #707183;">(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
v.emplace_back<span style="color: #707183;">(</span><span style="color: #008b8b;">2</span><span style="color: #707183;">)</span>;
v.emplace_back<span style="color: #707183;">(</span><span style="color: #008b8b;">3</span><span style="color: #707183;">)</span>;
</pre>
</div>
<p>
(3 constructs)
</p>

<aside class="notes">
<p>
The first version is probably OK for builtin primitive types.
</p>

<p>
It's way worse than the second version for types with more than trivial
construction.
</p>

</aside>

</section>
<section id="slide-orgf59a421">
<h3 id="orgf59a421">We can make it a little better&#x2026;</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = <span style="color: #707183;">{</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>, S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">2</span><span style="color: #7388d6;">}</span>, S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">3</span><span style="color: #7388d6;">}</span> <span style="color: #707183;">}</span>;
</pre>
</div>
<p>
(3 constructs, 3 copies, 3 destructs)
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #a0522d;">a</span><span style="color: #707183;">[</span><span style="color: #008b8b;">3</span><span style="color: #707183;">]</span> = <span style="color: #707183;">{</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>, S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">2</span><span style="color: #7388d6;">}</span>, S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">3</span><span style="color: #7388d6;">}</span> <span style="color: #707183;">}</span>;
<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">S</span><span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">v</span><span style="color: #707183;">(</span><span style="color: #228b22;">make_move_iterator</span><span style="color: #7388d6;">(</span><span style="color: #a0522d;">begin</span><span style="color: #909183;">(</span>a<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>,
            <span style="color: #228b22;">make_move_iterator</span><span style="color: #7388d6;">(</span><span style="color: #a0522d;">end</span><span style="color: #909183;">(</span>a<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>
<p>
(3 constructs, 3 moves, 3 destructs)
</p>

</section>
<section id="slide-org9862bd8">
<h3 id="org9862bd8">What we really need&#x2026;</h3>
<p>
Is an in-place constructor for <code>vector</code>. (For everything?)
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">vector</span><span style="color: #707183;">(</span><span style="color: #228b22;">in_place_t</span>, <span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Future (?) proposal by Simon Brand.
</p>

<p>
<a href="https://wg21.tartanllama.xyz/initializer_list">https://wg21.tartanllama.xyz/initializer_list</a>
</p>

</section>
<section id="slide-org5932f01">
<h3 id="org5932f01">Exhibit F</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">unordered_set</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">string</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">kKeywords</span> = <span style="color: #707183;">{</span>
        <span style="color: #b22222;">"alignas"</span>, <span style="color: #b22222;">"alignof"</span>, <span style="color: #b22222;">"and"</span>, <span style="color: #b22222;">"and_eq"</span>, <span style="color: #b22222;">"asm"</span>, <span style="color: #b22222;">"auto"</span>, <span style="color: #b22222;">"bitand"</span>, <span style="color: #b22222;">"bitor"</span>,
        <span style="color: #b22222;">"bool"</span>, <span style="color: #b22222;">"break"</span>, <span style="color: #b22222;">"case"</span>, <span style="color: #b22222;">"catch"</span>, <span style="color: #b22222;">"char"</span>, <span style="color: #b22222;">"class"</span>, <span style="color: #b22222;">"compl"</span>, <span style="color: #b22222;">"const"</span>,
        <span style="color: #b22222;">"constexpr"</span>, <span style="color: #b22222;">"const_cast"</span>, <span style="color: #b22222;">"continue"</span>, <span style="color: #b22222;">"decltype"</span>, <span style="color: #b22222;">"default"</span>, <span style="color: #b22222;">"delete"</span>, <span style="color: #b22222;">"do"</span>,
        <span style="color: #b22222;">"double"</span>, <span style="color: #b22222;">"dynamic_cast"</span>, <span style="color: #b22222;">"else"</span>, <span style="color: #b22222;">"enum"</span>, <span style="color: #b22222;">"explicit"</span>, <span style="color: #b22222;">"extern"</span>, <span style="color: #b22222;">"false"</span>,
        <span style="color: #b22222;">"float"</span>, <span style="color: #b22222;">"for"</span>, <span style="color: #b22222;">"friend"</span>, <span style="color: #b22222;">"goto"</span>, <span style="color: #b22222;">"if"</span>, <span style="color: #b22222;">"inline"</span>, <span style="color: #b22222;">"int"</span>, <span style="color: #b22222;">"long"</span>, <span style="color: #b22222;">"mutable"</span>,
        <span style="color: #b22222;">"namespace"</span>, <span style="color: #b22222;">"new"</span>, <span style="color: #b22222;">"noexcept"</span>, <span style="color: #b22222;">"not"</span>, <span style="color: #b22222;">"not_eq"</span>, <span style="color: #b22222;">"NULL"</span>, <span style="color: #b22222;">"operator"</span>, <span style="color: #b22222;">"or"</span>,
        <span style="color: #b22222;">"or_eq"</span>, <span style="color: #b22222;">"private"</span>, <span style="color: #b22222;">"protected"</span>, <span style="color: #b22222;">"public"</span>, <span style="color: #b22222;">"register"</span>, <span style="color: #b22222;">"reinterpret_cast"</span>,
        <span style="color: #b22222;">"return"</span>, <span style="color: #b22222;">"short"</span>, <span style="color: #b22222;">"signed"</span>, <span style="color: #b22222;">"sizeof"</span>, <span style="color: #b22222;">"static"</span>, <span style="color: #b22222;">"static_assert"</span>,
        <span style="color: #b22222;">"static_cast"</span>, <span style="color: #b22222;">"struct"</span>, <span style="color: #b22222;">"switch"</span>, <span style="color: #b22222;">"template"</span>, <span style="color: #b22222;">"this"</span>, <span style="color: #b22222;">"thread_local"</span>,
        <span style="color: #b22222;">"throw"</span>, <span style="color: #b22222;">"true"</span>, <span style="color: #b22222;">"try"</span>, <span style="color: #b22222;">"typedef"</span>, <span style="color: #b22222;">"typeid"</span>, <span style="color: #b22222;">"typename"</span>, <span style="color: #b22222;">"union"</span>, <span style="color: #b22222;">"unsigned"</span>,
        <span style="color: #b22222;">"using"</span>, <span style="color: #b22222;">"virtual"</span>, <span style="color: #b22222;">"void"</span>, <span style="color: #b22222;">"volatile"</span>, <span style="color: #b22222;">"wchar_t"</span>, <span style="color: #b22222;">"while"</span>, <span style="color: #b22222;">"xor"</span>, <span style="color: #b22222;">"xor_eq"</span>
<span style="color: #707183;">}</span>;
</pre>
</div>

</section>
<section id="slide-orgbc41e21">
<h3 id="orgbc41e21">Caveat Constructor</h3>
<p>
<code>string</code> is an interesting case here. We intuit/are taught:
</p>

<blockquote nil><p>Delay construction, allocation, etc. as late as possible.</p></blockquote>

<p>
But that might hurt us with <code>string</code>.
</p>

<p>
<a href="https://www.youtube.com/watch?v=sSlmmZMFsXQ">"Initializer Lists are Broken, Let's Fix Them"</a> &#x2013; Jason Turner, C++Now 2018
</p>

</section>
<section id="slide-orgfcb21df">
<h3 id="orgfcb21df">Surprising: <code>string</code> vs <code>const char*</code></h3>
<p>
SBO-strings
<a href="http://quick-bench.com/5dPSX8rx-R8_BIUYbYOp6DcqhAc">http://quick-bench.com/5dPSX8rx-R8_BIUYbYOp6DcqhAc</a>
</p>

<p>
Non SBO-strings 1:
<a href="http://quick-bench.com/mr6ZIQ8Jy0ghe1scBcTznYF2s5w">http://quick-bench.com/mr6ZIQ8Jy0ghe1scBcTznYF2s5w</a>
</p>

<p>
Non SBO-strings 2:
<a href="http://quick-bench.com/vzlG11LwZN-uMAKdK8X1XgRuaWs">http://quick-bench.com/vzlG11LwZN-uMAKdK8X1XgRuaWs</a>
</p>

<aside class="notes">
<p>
Two things mess with our mental model for strings. First - the small buffer
optimization. As previously mentioned, it makes copy the same cost as move.
</p>

<p>
Second - we often make strings from string literals. What's the type of a string
literal at declaration? Array of char. What's the type of it when you pass it to
a function? It decays to pointer to char.
</p>

<p>
So, if a string isn't small-buffer optimized, move is cheap. And if we're
constructing it from a string literal, the compiler knows the size. If we let it
decay to a char*, we're going to call strlen at some point.
</p>

</aside>

</section>
<section id="slide-org42bc9fb">
<h3 id="org42bc9fb">Recommendations</h3>
<ul>
<li>use <code>initializer_list</code> only for literal types</li>
<li>consider using <code>array</code> and manually moving</li>
<li>probably don't use <code>initializer_list</code> for anything that'll get run more than
once</li>
<li>wait for an <code>in_place_t</code> constructor on <code>vector</code> ?</li>
<li>watch Jason's talk</li>

</ul>

<aside class="notes">
<p>
I'm not sure what to recommend. Really the first point.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org4fc0d57">
<h2 id="org4fc0d57">5. Putting stuff into a <code>map</code></h2>
<p>
(or other associative container)
</p>

<p>
It's a bit complicated.
</p>

<aside class="notes">
<p>
When I say <code>map</code>, I mean <code>map</code>, <code>unordered_map</code>, <code>multimap</code>, <code>unordered_multimap</code>,
etc, and also the various flavours of <code>set</code>.
</p>

</aside>

</section>
<section id="slide-org6a646bb">
<h3 id="org6a646bb"><code>initializer_list</code> with <code>map</code></h3>
<p>
It's perfectly possible to initialize a map with an <code>initializer_list</code>.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">recall S has an implicit constructor from Foo</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span> <span style="color: #707183;">{</span> <span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span>, Foo<span style="color: #909183;">{}</span><span style="color: #7388d6;">}</span> <span style="color: #707183;">}</span>; <span style="color: #006400;">// </span><span style="color: #006400;">how many constructs/copies/moves?</span>
</pre>
</div>

<p>
Use aggregate initialization with <code>pair</code>.
</p>

<p>
Suffers from the same problems as we saw earlier.
</p>

<p>
And we can use the manual-array and move-iterator trick also.
</p>

<aside class="notes">
<p>
Same as the <code>vector</code> init case basically.
</p>

<p>
You can't use explicit constructors easily here.
</p>

<p>
If you have explicit constructors you might need to explicitly call out the type
 of pair; it's not going to make a lot of difference.
</p>

</aside>

</section>
<section id="slide-orgadf9ece">
<h3 id="orgadf9ece">Alternative: templatery</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">call an N-ary function on each lot of N args passed in</span>
<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">N</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">F</span>, <span style="color: #a020f0;">typename</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Ts</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">for_each_n_args</span><span style="color: #707183;">(</span><span style="color: #228b22;">F</span>&amp;&amp; <span style="color: #a0522d;">f</span>, <span style="color: #228b22;">Ts</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">ts</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
for_each_n_args<span style="color: #707183;">&lt;</span><span style="color: #008b8b;">2</span><span style="color: #707183;">&gt;(</span>
  <span style="color: #7388d6;">[</span>&amp;<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #a020f0;">auto</span>&amp;&amp; <span style="color: #a0522d;">k</span>, <span style="color: #a020f0;">auto</span>&amp;&amp; <span style="color: #a0522d;">v</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
      m.emplace<span style="color: #909183;">(</span>forward<span style="color: #709870;">&lt;</span><span style="color: #a020f0;">decltype</span><span style="color: #907373;">(</span>k<span style="color: #907373;">)</span><span style="color: #709870;">&gt;(</span>k<span style="color: #709870;">)</span>,
                forward<span style="color: #709870;">&lt;</span><span style="color: #a020f0;">decltype</span><span style="color: #907373;">(</span>v<span style="color: #907373;">)</span><span style="color: #709870;">&gt;(</span>v<span style="color: #709870;">)</span><span style="color: #909183;">)</span>; <span style="color: #7388d6;">}</span>,
  <span style="color: #008b8b;">0</span>, <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">we can call explicit constructor</span>
</pre>
</div>

<p>
If you know the types, you can probably write the lambda in a less ugly way.
</p>

<aside class="notes">
<p>
<code>for_each_n_args</code> is a function template that perfectly-forwards its arguments
in groups of N to the function you give it.
</p>

<p>
It's in the Phoenix code base and it's useful for things like this.
</p>

<p>
Everything here gets constructed in place. No moves or copies.
</p>

<p>
This lambda deals with single-argument constructors for value. But&#x2026;
</p>

</aside>


</section>
<section id="slide-org5efaf8f">
<h3 id="org5efaf8f">Alternative: multi-arg templatery</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">call an N-ary function on each lot of N args passed in</span>
<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">N</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">F</span>, <span style="color: #a020f0;">typename</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Ts</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">for_each_n_args</span><span style="color: #707183;">(</span><span style="color: #228b22;">F</span>&amp;&amp; <span style="color: #a0522d;">f</span>, <span style="color: #228b22;">Ts</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">ts</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
for_each_n_args<span style="color: #707183;">&lt;</span><span style="color: #008b8b;">3</span><span style="color: #707183;">&gt;(</span>
  <span style="color: #7388d6;">[</span>&amp;<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #a020f0;">auto</span>&amp;&amp; <span style="color: #a0522d;">k</span>, <span style="color: #a020f0;">auto</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">v</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
      m.emplace<span style="color: #909183;">(</span>
        piecewise_construct,
        forward_as_tuple<span style="color: #709870;">(</span>forward<span style="color: #907373;">&lt;</span><span style="color: #a020f0;">decltype</span><span style="color: #6276ba;">(</span>k<span style="color: #6276ba;">)</span><span style="color: #907373;">&gt;(</span>k<span style="color: #907373;">)</span><span style="color: #709870;">)</span>,
        forward_as_tuple<span style="color: #709870;">(</span>forward<span style="color: #907373;">&lt;</span><span style="color: #a020f0;">decltype</span><span style="color: #6276ba;">(</span>v<span style="color: #6276ba;">)</span><span style="color: #907373;">&gt;(</span>v<span style="color: #907373;">)</span><span style="color: #0000ff;">...</span><span style="color: #709870;">)</span>; <span style="color: #88090B;">}</span>,
  <span style="color: #008b8b;">0</span>, <span style="color: #008b8b;">1</span>, <span style="color: #008b8b;">2</span><span style="color: #88090B;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">explicit multi-arg value constructor</span>
</pre>
</div>

<p>
Everything constructed in place.
</p>

<aside class="notes">
<p>
Here we are calling S's two-arg constructor.
</p>

</aside>

</section>
<section id="slide-orgb6701e8">
<h3 id="orgb6701e8">Enough about initializing</h3>
<p>
How about putting things into an existing <code>map</code>?
</p>

</section>
<section id="slide-orga32fefb">
<h3 id="orga32fefb">The Easy Way: <code>operator[]</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">recall S has an implicit constructor from Foo</span>
<span style="color: #006400;">// </span><span style="color: #006400;">but an explicit constructor from int</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
m<span style="color: #707183;">[</span><span style="color: #008b8b;">0</span><span style="color: #707183;">]</span> = S<span style="color: #707183;">{</span><span style="color: #008b8b;">1</span><span style="color: #707183;">}</span>;
m<span style="color: #707183;">[</span><span style="color: #008b8b;">1</span><span style="color: #707183;">]</span> = Foo<span style="color: #707183;">{}</span>;
</pre>
</div>

<p>
How many constructs/moves/copies?
</p>

<aside class="notes">
<p>
These each have a construct, a default construct, and a move.
</p>

<p>
The advantage of this is that when you know the element is there already, it's
fine. You just get a lookup and an assign.
</p>

<p>
But if the element isn't there, you never get a copy construct or a move
construct here.
</p>

<p>
You always get an assign! Because you always get a default construct if the
element isn't there.
</p>

<p>
In fact this is the only function on map that requires your mapped<sub>type</sub> to have
a default constructor! It's fine to use objects without default constructors in
a map, if you never use this function. And that can be a significant thing.
</p>

</aside>

</section>
<section id="slide-org804f166">
<h3 id="org804f166">The Other Easy Way: <code>insert</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">recall S has an implicit constructor from Foo</span>
<span style="color: #006400;">// </span><span style="color: #006400;">but an explicit constructor from int</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">pair&lt;iterator,bool&gt; insert(value_type&amp;&amp; value);</span>

<span style="color: #006400;">// </span><span style="color: #006400;">template &lt;class T1, class T2&gt;</span>
<span style="color: #006400;">// </span><span style="color: #006400;">pair&lt;V1,V2&gt; make_pair(T1&amp;&amp; t, T2&amp;&amp; u);</span>

<span style="color: #006400;">// </span><span style="color: #006400;">alternatives:</span>
m.insert<span style="color: #707183;">(</span>make_pair<span style="color: #7388d6;">(</span><span style="color: #008b8b;">0</span>, S<span style="color: #909183;">{</span><span style="color: #008b8b;">1</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
m.insert<span style="color: #707183;">(</span>pair&lt;<span style="color: #228b22;">int</span>, <span style="color: #228b22;">S</span>&amp;&amp;&gt;<span style="color: #7388d6;">(</span><span style="color: #008b8b;">0</span>, S<span style="color: #909183;">{</span><span style="color: #008b8b;">1</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
m.insert<span style="color: #707183;">(</span>make_pair<span style="color: #7388d6;">(</span><span style="color: #008b8b;">0</span>, <span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
How many constructs/moves/copies?
</p>

<aside class="notes">
<p>

</p>

<p>
The first line here creates an S, moves it into pair&lt;int, S&gt;, then moves the
pair into the map.
</p>

<p>
Remember that make<sub>pair</sub> deduces the type of its arguments. And V1 and V2 here
are the decayed types of T1 and T2.
</p>

<p>
The second line forces a pair of type &lt;int, S&amp;&amp;&gt;, so you get one move after the
initial construct.
</p>

<p>
The third line makes a pair&lt;int, int&gt; then uses that pair to construct a pair
of &lt;int, S&gt; in the map.
</p>

</aside>

</section>
<section id="slide-org53a6911">
<h3 id="org53a6911"><code>emplace</code></h3>
<p>
Enter the <i>wonderful C++11 panacea</i> that is move semantics.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">recall S has an implicit constructor from Foo</span>
<span style="color: #006400;">// </span><span style="color: #006400;">but an explicit constructor from int</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">template &lt;class... Args&gt;</span>
<span style="color: #006400;">// </span><span style="color: #006400;">pair&lt;iterator,bool&gt; emplace(Args&amp;&amp;... args);</span>

<span style="color: #006400;">// </span><span style="color: #006400;">this was 2 moves</span>
<span style="color: #006400;">// </span><span style="color: #006400;">m.insert(make_pair(0, S{1}));</span>

<span style="color: #006400;">// </span><span style="color: #006400;">much better, right?</span>
m.emplace<span style="color: #707183;">(</span>make_pair<span style="color: #7388d6;">(</span><span style="color: #008b8b;">0</span>, S<span style="color: #909183;">{</span><span style="color: #008b8b;">1</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
You guessed it&#x2026;
</p>

<aside class="notes">
<p>
Don't do this. It is <i>exactly</i> the same as <code>insert</code> here. Two moves.
</p>

</aside>

</section>
<section id="slide-orgb1185f4">
<h3 id="orgb1185f4"><code>emplace</code>, better usage</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">recall S has an implicit constructor from Foo</span>
<span style="color: #006400;">// </span><span style="color: #006400;">but an explicit constructor from int</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">template &lt;class... Args&gt;</span>
<span style="color: #006400;">// </span><span style="color: #006400;">pair&lt;iterator,bool&gt; emplace(Args&amp;&amp;... args);</span>

m.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">0</span>, <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">no moves, just a construct</span>
</pre>
</div>

<aside class="notes">
<p>
Again, the point of <code>emplace</code> is in-place construction.
</p>

<p>
It doesn't help you over <code>insert</code> if you just pass rvalues. <code>insert</code> works just
fine with rvalues.
</p>

</aside>

</section>
<section id="slide-orge00affa">
<h3 id="orge00affa"><code>emplace</code>: <code>blz</code> caveat</h3>
<p>
At the moment, <code>blz::map::emplace</code> cannot invoke <code>explicit</code> constructors.
</p>

<p>
(<code>blz::vector::emplace_back</code> can)
</p>

<aside class="notes">
<p>
This is a gnarly area of the STL: conditionally explicit constructors on <code>pair</code>.
</p>

<p>
There's an issue open on <code>blz</code> about it: if it's important to you, help with the
fix. It's been difficult to achieve cross-platform compiler support properly.
</p>

</aside>

</section>
<section id="slide-orgc27573e">
<h3 id="orgc27573e"><code>emplace</code> problem</h3>
<p>
What do we do when we want to default-construct the value?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
m.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">0</span><span style="color: #707183;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">default construct S please!</span>
</pre>
</div>

<p class="fragment (appear)">
<i>error 2665: <code>std::pair&lt;const _Kty,_Ty&gt;::pair</code>: none of the 2 overloads could
convert all the argument types</i>
</p>

<aside class="notes">
<p>
Here's a problem: how can we tell <code>emplace</code> to zero-arg construct the value when
we can't syntactically pass "zero arguments" in the place of an argument.
</p>

<p>
We don't want to default-construct an S explicitly here and move it in.
</p>

<p>
Remember the <code>value_type</code> of the <code>map</code> is a <code>pair</code> - that's what <code>emplace</code> is
trying to construct.
</p>

</aside>

</section>
<section id="slide-org8d54451">
<h3 id="org8d54451"><code>emplace</code> with zero-arg constructor</h3>
<p>
Our old friend <code>piecewise_construct</code> can help.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
m.emplace<span style="color: #707183;">(</span>piecewise_construct,
          forward_as_tuple<span style="color: #7388d6;">(</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">)</span>,
          forward_as_tuple<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">default construct S please!</span>
</pre>
</div>

<p>
Tuples are allowed to be empty!
</p>

<p>
Yes, we can also use this for more-than-one-arg constructors.
</p>

<aside class="notes">
<p>
Here's the piecewise constructor on <code>pair</code> again.
</p>

<p>
This also gets around the <code>blz</code> limitation on <code>explicit</code> constructors with
<code>emplace</code>. So there is a way to achieve optimality with <code>blz</code>.
</p>

</aside>

</section>
<section id="slide-org2b44c87">
<h3 id="org2b44c87">Exhibit G</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">explicit ClientIdRecord(</span>
<span style="color: #006400;">//  </span><span style="color: #006400;">const string&amp; clientId, const ProcessId&amp; clientProcess, const ProcessId&amp; romeoProcess);</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">Storage</span> = <span style="color: #228b22;">unordered_set</span><span style="color: #707183;">&lt;</span>ClientIdRecord<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">Storage</span> <span style="color: #a0522d;">m_storage</span>;
m_storage.emplace<span style="color: #707183;">(</span>inClientId, process, romeoProcess<span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Perfectly fine as far as <code>emplace</code> usage.
</p>

<p>
Then we want to change the <code>unordered_set</code> to an <code>unordered_map</code>.
</p>

<aside class="notes">
<p>
ClientIdRecord has a 3-argument constructor.
</p>

<p>
<code>inClientId</code> is a string
</p>

<p>
One in-place construct. This is fine.
</p>

</aside>

</section>
<section id="slide-orgd05fb6b">
<h3 id="orgd05fb6b">Exhibit G</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">explicit ClientIdRecord(</span>
<span style="color: #006400;">//  </span><span style="color: #006400;">const string&amp; clientId, const ProcessId&amp; clientProcess, const ProcessId&amp; romeoProcess);</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">Storage</span> = <span style="color: #228b22;">unordered_map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">string</span>, ClientIdRecord<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">Storage</span> <span style="color: #a0522d;">m_storage</span>;
m_storage.emplace<span style="color: #707183;">(</span>
  make_pair<span style="color: #7388d6;">(</span>inClientId,
            ClientIdRecord<span style="color: #909183;">(</span>inClientId, process, romeoProcess<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Is this optimal?
</p>

<aside class="notes">
<p>
2 extra moves here.
</p>

<p>
How do we do better?
</p>

</aside>

</section>
<section id="slide-org58c8dc6">
<h3 id="org58c8dc6">Exhibit G</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">Storage</span> = <span style="color: #228b22;">unordered_map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">string</span>, ClientIdRecord<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">Storage</span> <span style="color: #a0522d;">m_storage</span>;
m_storage.emplace<span style="color: #707183;">(</span>piecewise_construct,
                  forward_as_tuple<span style="color: #7388d6;">(</span>inClientId<span style="color: #7388d6;">)</span>,
                  forward_as_tuple<span style="color: #7388d6;">(</span>inClientId, process, romeoProcess<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Use <code>piecewise_construct</code> again.
</p>

</section>
<section id="slide-org3f539f0">
<h3 id="org3f539f0"><code>emplace</code> problem 2</h3>
<p>
What do you do if you want to <code>emplace</code> the result of a function call?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">get_S</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span> <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>; <span style="color: #707183;">}</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
m.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">0</span>, get_S<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
How can we avoid the move?
</p>

<p>
Is it possible to in-place construct here?
</p>

</section>
<section id="slide-org4b88cdb">
<h3 id="org4b88cdb">In-place construct a function call result</h3>
<p>
We can't avoid evaluating the function call before calling <code>emplace</code>.
</p>

<p>
But, we can control when the result of the function call becomes an <code>S</code>.
</p>

</section>
<section id="slide-org9128ba7">
<h3 id="org9128ba7">In-place construct a function call result</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">F</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">with_result_of_t</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">using</span> <span style="color: #228b22;">T</span> = <span style="color: #228b22;">invoke_result_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">F</span><span style="color: #7388d6;">&gt;</span>;
  <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">with_result_of_t</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">F</span> <span style="color: #a0522d;">f</span><span style="color: #7388d6;">)</span> : f<span style="color: #7388d6;">(</span>move<span style="color: #909183;">(</span>f<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{}</span>
  <span style="color: #a020f0;">operator</span> <span style="color: #228b22;">T</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{</span> <span style="color: #a020f0;">return</span> f<span style="color: #909183;">()</span>; <span style="color: #7388d6;">}</span>

<span style="color: #a020f0;">private</span>:
  <span style="color: #228b22;">F</span> <span style="color: #a0522d;">f</span>;
<span style="color: #707183;">}</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">F</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">inline</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">with_result_of</span><span style="color: #707183;">(</span><span style="color: #228b22;">F</span>&amp;&amp; <span style="color: #a0522d;">f</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> with_result_of_t<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">F</span><span style="color: #7388d6;">&gt;(</span>forward<span style="color: #909183;">&lt;</span><span style="color: #228b22;">F</span><span style="color: #909183;">&gt;(</span>f<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Capture the function and call it only at the point that we want to convert the
result to an <code>S</code>.
</p>

</aside>

</section>
<section id="slide-orge2af73f">
<h3 id="orge2af73f"><code>emplace</code> problem 2</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">get_S</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span> <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>; <span style="color: #707183;">}</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
m.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">0</span>, with_result_of<span style="color: #7388d6;">(</span><span style="color: #909183;">[]</span> <span style="color: #909183;">{</span> <span style="color: #a020f0;">return</span> get_S<span style="color: #709870;">()</span>; <span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">m.emplace(0, with_result_of(get_S));</span>
</pre>
</div>

<p>
Compilers are really good at optimizing single-use lambdas.
</p>

<aside class="notes">
<p>
You would think the second line here would work just as well. But VC++
doesn't manage to elide the move.
</p>

</aside>

</section>
<section id="slide-orgfd19d1e">
<h3 id="orgfd19d1e">C++17: <code>insert_or_assign</code></h3>
<p>
Of course, <code>insert</code> / <code>emplace</code> and <code>operator[]</code> actually do different things.
</p>

<p>
What do you do if you want to insert, or assign if the element is already there?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">M</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">pair</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">iterator</span>, <span style="color: #228b22;">bool</span><span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">insert_or_assign</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">key_type</span>&amp; <span style="color: #a0522d;">k</span>, <span style="color: #228b22;">M</span>&amp;&amp; <span style="color: #a0522d;">obj</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">M</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">pair</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">iterator</span>, <span style="color: #228b22;">bool</span><span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">insert_or_assign</span><span style="color: #707183;">(</span><span style="color: #228b22;">key_type</span>&amp;&amp; <span style="color: #a0522d;">k</span>, <span style="color: #228b22;">M</span>&amp;&amp; <span style="color: #a0522d;">obj</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Introduced with C++17.
</p>

<aside class="notes">
<p>
<code>insert_or_assign</code> doesn't need default construction (unlike <code>operator[]</code>).
</p>

<p>
<code>insert_or_assign</code> was introduced with C++17. Can be written as a free function,
but difficult/impossible to make as efficient as map can as a member function.
</p>

</aside>

</section>
<section id="slide-orge3039fb">
<h3 id="orge3039fb">C++17: <code>insert_or_assign</code></h3>
<p>
Yet another slightly different interface&#x2026;
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
m.insert_or_assign<span style="color: #707183;">(</span><span style="color: #008b8b;">0</span>, Foo<span style="color: #7388d6;">{}</span><span style="color: #707183;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">implicit construction - fine</span>

<span style="color: #006400;">// </span><span style="color: #006400;">m.insert_or_assign(1, 1);  // explicit construction - error!</span>
m.insert_or_assign<span style="color: #707183;">(</span><span style="color: #008b8b;">1</span>, with_result_of<span style="color: #7388d6;">(</span><span style="color: #909183;">[]{</span> <span style="color: #a020f0;">return</span> S<span style="color: #709870;">{</span><span style="color: #008b8b;">1</span><span style="color: #709870;">}</span>; <span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">RVO</span>
</pre>
</div>

<aside class="notes">
<p>
Unfortunately there is no <code>emplace_or_assign</code>. (In the assign case presumably
could not avoid making a temporary to assign). But you can use the same
<code>with_result_of</code> technique with <code>insert_or_assign</code>.
</p>

</aside>

</section>
<section id="slide-org500cee5">
<h3 id="org500cee5">Exhibit H</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">K</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">V</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">typename</span> <span style="color: #008b8b;">LRUCache</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">K</span>, <span style="color: #228b22;">V</span><span style="color: #707183;">&gt;</span>::<span style="color: #228b22;">EntryPtr</span> <span style="color: #008b8b;">LRUCache</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">K</span>, <span style="color: #228b22;">V</span><span style="color: #707183;">&gt;</span>::<span style="color: #0000ff;">Insert</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">K</span>&amp; <span style="color: #a0522d;">key</span>, <span style="color: #228b22;">V</span> <span style="color: #a0522d;">value</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #006400;">// </span><span style="color: #006400;">Is the key already present?</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>m_entries.find<span style="color: #909183;">(</span>key<span style="color: #909183;">)</span> != m_entries.end<span style="color: #909183;">()</span><span style="color: #7388d6;">)</span> <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">nullptr</span>;

  <span style="color: #006400;">// </span><span style="color: #006400;">Is the cache full?</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>m_entries.size<span style="color: #909183;">()</span> == m_capacity<span style="color: #7388d6;">)</span> Evict<span style="color: #7388d6;">(</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span>;

  <span style="color: #006400;">// </span><span style="color: #006400;">Insert the new value.</span>
  <span style="color: #228b22;">EntryPtr</span> <span style="color: #a0522d;">e</span> = <span style="color: #008b8b;">blz</span>::make_shared<span style="color: #7388d6;">&lt;</span>Entry<span style="color: #7388d6;">&gt;(</span>key, <span style="color: #008b8b;">blz</span>::move<span style="color: #909183;">(</span>value<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
  Append<span style="color: #7388d6;">(</span>e.get<span style="color: #909183;">()</span><span style="color: #7388d6;">)</span>;
  m_entries<span style="color: #7388d6;">[</span>key<span style="color: #7388d6;">]</span> = e;

  <span style="color: #a020f0;">return</span> e;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Given everything we've learned, let's critique this code.
</p>

<p>
We can see that it's inserting a KV pair into a cache with a least-recently-used
eviction strategy. There is a map that owns a shared<sub>ptr</sub>, and that shared<sub>ptr</sub> is
also weakly-referenced from a deque (see Append call)?
</p>

<ul>
<li>use pass-by-value to simplify handling</li>
<li>use <code>make_shared</code></li>

<li>use <code>operator[]</code> - default construct shared<sub>ptr</sub> + assign</li>
<li>extra shared<sub>ptr</sub> ref</li>

</ul>

</aside>

</section>
<section id="slide-org5525390">
<h3 id="org5525390">Exhibit H</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">Insert the new value.</span>
<span style="color: #a020f0;">decltype</span><span style="color: #707183;">(</span>m_entries.begin<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">it</span>;
<span style="color: #008b8b;">blz</span>::tie<span style="color: #707183;">(</span>it, <span style="color: #008b8b;">blz</span>::ignore<span style="color: #707183;">)</span> =
  m_entries.emplace<span style="color: #707183;">(</span>key, <span style="color: #008b8b;">blz</span>::make_shared<span style="color: #7388d6;">&lt;</span>Entry<span style="color: #7388d6;">&gt;(</span>key, <span style="color: #008b8b;">blz</span>::move<span style="color: #909183;">(</span>value<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
Append<span style="color: #707183;">(</span>it-&gt;second.get<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">return</span> it-&gt;second;
</pre>
</div>

<aside class="notes">
<ul>
<li>m<sub>entries</sub> can still be any associative container (no loss of generality)</li>
<li>save 2 shared<sub>ptr</sub> reference updates (plus check on assign of the default-constructed one)</li>

</ul>

<p>
We could use with<sub>result</sub><sub>of</sub> here to construct the shared<sub>ptr</sub> directly in place.
</p>

</aside>

</section>
<section id="slide-org5e50891">
<h3 id="org5e50891">Recommendations</h3>
<p>
Yes, C++ is complicated.
</p>

<ul>
<li>Initialization: consider <code>for_each_n_args</code></li>
<li>Feel free to use <code>insert</code> with <code>make_pair</code>
<ul>
<li>But don't use call-site construction</li>

</ul></li>
<li>Use <code>emplace</code> but beware of explicit construction with <code>blz</code></li>
<li>Use <code>piecewise_construct</code> for other than single-arg construction</li>
<li>Try to avoid <code>operator[]</code></li>
<li>Adopt <code>insert_or_assign</code> when it's available</li>
<li>Consider <code>with_result_of</code></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgf68f8d4">
<h2 id="orgf68f8d4">6. Putting stuff into other things</h2>
<p>
Like <code>optional</code>, <code>variant</code>, <code>any</code>.
</p>

</section>
<section id="slide-org0243c0f">
<h3 id="org0243c0f"><code>optional</code> and friends</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">optional</span><span style="color: #707183;">(</span><span style="color: #228b22;">in_place_t</span>, <span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span>, <span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">variant</span><span style="color: #707183;">(</span><span style="color: #228b22;">in_place_type_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #7388d6;">&gt;</span>, <span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span>;
<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">I</span>, <span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">variant</span><span style="color: #707183;">(</span><span style="color: #228b22;">in_place_index_t</span><span style="color: #7388d6;">&lt;</span>I<span style="color: #7388d6;">&gt;</span>, <span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">ValueType</span>, <span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">any</span><span style="color: #707183;">(</span><span style="color: #228b22;">in_place_type_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">ValueType</span><span style="color: #7388d6;">&gt;</span>, <span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
All these new vocabulary types have constructors that take <code>in_place</code> tag
arguments. They work similarly to <code>piecewise_construct</code> but they're only
constructing one thing.
</p>

</aside>

</section>
<section id="slide-orgfe2460c">
<h3 id="orgfe2460c"><code>optional</code> construction</h3>
<p>
implicit constructor
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span> = Foo<span style="color: #707183;">{}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (naive method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span> = S<span style="color: #707183;">{</span><span style="color: #008b8b;">1</span><span style="color: #707183;">}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (in-place method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span><span style="color: #707183;">(</span>in_place, <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
In the first case, it's fine: just one in-place construct.
</p>

<p>
In the second case, we have an <code>explicit</code> constructor. So if we use this style,
we get a construct and a move.
</p>

<p>
The third case is the way to go for in-place construction. It can also be used
with an implicit constructor of course.
</p>

</aside>

</section>
<section id="slide-orgfb58c80">
<h3 id="orgfb58c80"><code>optional</code> assignment</h3>
<p>
implicit constructor
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span>;
opt = Foo<span style="color: #707183;">{}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (naive method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span>;
opt = S<span style="color: #707183;">{</span><span style="color: #008b8b;">1</span><span style="color: #707183;">}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (in-place method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span>;
opt.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Similar story here.
</p>

</aside>

</section>
<section id="slide-orgd9fafb9">
<h3 id="orgd9fafb9"><code>optional</code> recommendations</h3>
<ul>
<li>use the <code>in_place_t</code> constructor</li>
<li>use <code>=</code> for assignment, but avoid <code>explicit</code> construction</li>
<li>use <code>emplace</code> for assignment</li>

</ul>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span><span style="color: #707183;">(</span>in_place, <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
opt = Foo<span style="color: #707183;">{}</span>;
opt.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">2</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
You'll never go wrong with these.
</p>

</aside>

</section>
<section id="slide-org541af60">
<h3 id="org541af60"><code>variant</code> construction</h3>
<p>
implicit constructor
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = Foo<span style="color: #707183;">{}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (naive method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = S<span style="color: #707183;">{</span><span style="color: #008b8b;">1</span><span style="color: #707183;">}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (oops method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = <span style="color: #008b8b;">1</span>;
</pre>
</div>

<aside class="notes">
<p>
Similar story as <code>optional</code>.
</p>

<p>
But there is the potential for a bug with the <code>explicit</code> constructor. What makes
this somewhat likely is that it might be the case that someone makes a
constructor explicit later on.
</p>

</aside>

</section>
<section id="slide-org181b3fc">
<h3 id="org181b3fc"><code>variant</code> construction</h3>
<p>
Recommendation: use either of these two constructions.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">v</span><span style="color: #707183;">(</span><span style="color: #228b22;">in_place_type</span><span style="color: #7388d6;">&lt;</span>S<span style="color: #7388d6;">&gt;</span>, <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">v</span><span style="color: #707183;">(</span><span style="color: #228b22;">in_place_index</span><span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">&gt;</span>, <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
I would generally prefer the first except in cases where the same type occurs in
multiple places in the <code>variant</code>, which is relatively rarer.
</p>

</aside>

</section>
<section id="slide-orge5f4f5c">
<h3 id="orge5f4f5c"><code>variant</code> assignment</h3>
<p>
Similar story to construction.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;

v = Foo<span style="color: #707183;">{}</span>; <span style="color: #006400;">// </span><span style="color: #006400;">fine</span>
v = S<span style="color: #707183;">{</span><span style="color: #008b8b;">1</span><span style="color: #707183;">}</span>;  <span style="color: #006400;">// </span><span style="color: #006400;">constructs a temporary</span>
v = <span style="color: #008b8b;">1</span>;     <span style="color: #006400;">// </span><span style="color: #006400;">oops</span>
</pre>
</div>

</section>
<section id="slide-org6809d68">
<h3 id="org6809d68"><code>variant</code> danger!</h3>
<p>
Implicitly-typed <code>variant</code> construction/assignment can be dangerous.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">bool</span>, <span style="color: #008b8b;">std</span>::string<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = <span style="color: #b22222;">"Hello"</span>;
cout &lt;&lt; <span style="color: #b22222;">"index is "</span> &lt;&lt; v.index<span style="color: #707183;">()</span> &lt;&lt; <span style="color: #b22222;">'</span><span style="color: #b22222; font-weight: bold;">\</span><span style="color: #b22222; font-weight: bold;">n</span><span style="color: #b22222;">'</span>;
</pre>
</div>

<p>
What does this output?
</p>

<aside class="notes">
<p>
Avoid implicit type conversions. They're dangerous. The first possible one will apply.
</p>

</aside>

</section>
<section id="slide-org1643ae8">
<h3 id="org1643ae8">Safe, efficient <code>variant</code> assignment</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #006400;">// </span><span style="color: #006400;">template &lt;class T, class... Args&gt;</span>
<span style="color: #006400;">// </span><span style="color: #006400;">T&amp; emplace(Args&amp;&amp;... args);</span>
v.emplace<span style="color: #707183;">&lt;</span><span style="color: #008b8b;">1</span><span style="color: #707183;">&gt;(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;  <span style="color: #006400;">// </span><span style="color: #006400;">S{1}</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #006400;">// </span><span style="color: #006400;">template &lt;size_t I, class... Args&gt;</span>
<span style="color: #006400;">// </span><span style="color: #006400;">variant_alternative_t&lt;I, variant&gt;&amp; emplace(Args&amp;&amp;... args);</span>
v.emplace<span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;  <span style="color: #006400;">// </span><span style="color: #006400;">S{1}</span>
</pre>
</div>

</section>
<section id="slide-org9caa482">
<h3 id="org9caa482"><code>variant</code> recommendations</h3>
<ul>
<li>always be explicit about types</li>
<li>use <code>in_place_type</code> or <code>in_place_index</code> constructors</li>
<li>use <code>emplace</code></li>
<li>avoid <code>operator=</code> (except actual <code>variant</code>-to-<code>variant</code>)</li>

</ul>

<aside class="notes">
<p>
Obviously <code>operator=</code> is used implicitly by the compiler.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org691fddb">
<h2 id="org691fddb">7. Final Guidelines and Recommendations</h2>
<p>
Think about copies and moves.
</p>

<p>
Moves aren't free, and may not be cheap.
</p>

<p>
Usually, in-place construction is preferable. And it is nearly always possible.
</p>

<p>
Know how RVO works, and check that the compiler is doing it when you think it is.
</p>

<p>
Beware <code>initializer_list</code>.
</p>

<p>
Feel free to ping me with any questions, any time.
</p>
</section>
</section>
</div>
</div>
<script src="../reveal.js/lib/js/head.min.js"></script>
<script src="../reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
overview: true,
width: 1600,
height: 900,
margin: 0.10,
minScale: 0.50,
maxScale: 2.50,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
