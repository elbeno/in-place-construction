<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Everyday Efficiency: In-place Construction</title>
<meta name="author" content="Ben Deane"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="../reveal.js/css/theme/blood.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h2>Everyday Efficiency:</h2><h2>In-place Construction</h2><h3>Back to Basics?</h3><div class='vertspace2'></div><blockquote nil><p>&quot;Make no collection of it: let him show<br>His skill is in the construction.&quot;</p><div></div><div class='author'>-- William Shakespeare, <em>Cymbeline</em></div></blockquote><div class='vertspace3'></div><h3>Ben Deane / <a href=\"http://twitter.com/ben_deane\">@ben_deane</a></h3><h4>September 19 2018</h4>
</section>
<script type="text/javascript" src="./rison.js"></script>
<script type="text/javascript" src="./presentation.js"></script>

<section>
<section id="slide-org0ca8e7c">
<h2 id="org0ca8e7c">Disclaimer</h2>
<div class='vertspace2'></div>

<p>
I'm going to critique some code in this talk.
</p>

<p>
If it's like your code, please don't feel slighted.
</p>

<p>
I assure you that I write and have written plenty of suboptimal code.
</p>

<p>
Let's make code better together!
</p>

<aside class="notes">
<p>
I developed this talk in response to code I saw in real-life codebases. The code
was often written by people who knew C++ and were trying to take advantage of
modern features like move semantics and perfect forwarding, but were doing so in
a way that was sometimes ineffective and sometimes looked like "magical
thinking". Basically they were trying to do the efficient thing, but so often
failing to. So I made this talk to try to help.
</p>

<p>
Who here is using C++20? 17? 14? 11? pre-11?
</p>

<p>
There is something here for everyone, even if you're still on a compiler without
move semantics.
</p>

<p>
For each slide with code, there will be a star in the corner indicating which
version of C++ it applies to.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org15f1604">
<h2 id="org15f1604">Get Ready</h2>
<div class='vertspace2'></div>

<ol>
<li>What happens when we <code>move</code> something?</li>
<li>Copy elision (RVO)</li>
<li>Putting stuff into a <code>vector</code></li>
<li><code>initializer_list</code></li>
<li>Putting stuff into a <code>map</code></li>
<li>Putting stuff into other things</li>
<li>Final thoughts</li>

</ol>

<aside class="notes">
<p>
There will be a lot of code snippets in this talk.
</p>

<p>
I will be asking a lot of questions.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org0a2fdde">
<h2 id="org0a2fdde">Preliminaries</h2>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #94BFF3;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #D01A4E;">cstdio</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">Arg</span> <span style="color: #2aa198;">{}</span>;

<span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">S</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #2aa198;">S</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Default construct"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>
  <span style="color: #2aa198;">S</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">Arg</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Value construct"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>
  <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">S</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Explicit value construct (1)"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>
  <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">S</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span>, <span style="color: #268bd2;">int</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Explicit value construct (2)"</span><span style="color: #94BFF3;">)</span>;<span style="color: #b58900;">}</span>
  ~<span style="color: #2aa198;">S</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Destruct"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>
  <span style="color: #2aa198;">S</span><span style="color: #b58900;">(</span><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">S</span>&amp;<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Copy construct"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>
  <span style="color: #2aa198;">S</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">S</span>&amp;&amp;<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Move construct"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>
  <span style="color: #268bd2;">S</span>&amp; <span style="color: #b58900; font-weight: bold;">operator</span><span style="color: #2aa198;">=</span><span style="color: #b58900;">(</span><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">S</span>&amp;<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Copy assign"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900; font-weight: bold;">return</span> *<span style="color: #b58900; font-weight: bold;">this</span>; <span style="color: #b58900;">}</span>
  <span style="color: #268bd2;">S</span>&amp; <span style="color: #b58900; font-weight: bold;">operator</span><span style="color: #2aa198;">=</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">S</span>&amp;&amp;<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> puts<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Move assign"</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900; font-weight: bold;">return</span> *<span style="color: #b58900; font-weight: bold;">this</span>; <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;

<span style="color: #268bd2;">int</span> <span style="color: #2aa198;">main</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<aside class="notes">
<p>
You're going to see a lot of this later in the talk, when we examine how various
snippets of code behave.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org164d0da">
<h2 id="org164d0da">1. What happens when we <code>move</code> something?</h2>
<div class='vertspace2'></div>
<blockquote nil><p>&quot;Mov'd! In good time! Let him that mov'd you hither<br>remove you hence.&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>The Taming of the Shrew</em></div></blockquote>
<div class='vertspace2'></div>
<p>
Are moves cheap or not?
</p>

</section>
<section id="slide-org968587f">
<h3 id="org968587f">A moved-from <code>vector</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v1</span> = <span style="color: #2aa198;">{</span><span style="color: #859900;">1</span>, <span style="color: #859900;">2</span>, <span style="color: #859900;">3</span>, <span style="color: #859900;">4</span>, <span style="color: #859900;">5</span><span style="color: #2aa198;">}</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v2</span> = <span style="color: #859900;">std</span>::move<span style="color: #2aa198;">(</span>v1<span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
What's in <code>v1</code> after the <code>move</code>?
</p>

<aside class="notes">
<p>
The standard says "valid but unspecified". We know that we're allowed to destroy
it, because for things to be otherwise would be a nonsense. <code>v1</code> <span class="underline">will</span> be
destroyed like any other C++ object when it goes out of scope.
</p>

<p>
Here's where we deviate from the standard. How is <code>vector</code> implemented,
basically? (pointer-to-buffer, size, capacity). On destruction, what must it do?
</p>

</aside>

</section>
<section id="slide-org0762190">
<h3 id="org0762190">A moved-from <code>vector</code></h3>
<p>
It <i>must</i> be destroyable.
</p>

<p>
What is sufficient? What is likely?
</p>
<ul>
<li>begin pointer is null?</li>
<li>size is zero?</li>
<li>capacity is zero?</li>

</ul>

<aside class="notes">
<p>
I don't advocate guessing what the standard library implementation is doing, or
relying on implementation, but it's worth thinking about these types of
questions to inform outselves.
</p>

</aside>

</section>
<section id="slide-org46ea125">
<h3 id="org46ea125">Exhibit A</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">void</span> <span style="color: #859900;">WebClient</span>::<span style="color: #2aa198;">ProcessServerResponse</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">HttpMessage</span> <span style="color: #cb4b16;">message</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">some stuff...</span>

  m_result.extra = <span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>m_readBuffer<span style="color: #b58900;">)</span>;
  m_result.headers = <span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>message<span style="color: #b58900;">)</span>.headers;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
This code assumes that it's safe to do whatever comes later to a moved-from <code>vector</code>.
</p>

<aside class="notes">
<p>
<code>m_readBuffer</code> here is a member variable that's used to accumulate the text of
the server response.
</p>

<p>
This variable gets reused on a later response. This code is assuming that it's
safe to reuse after move. In this case, it is, because the way it's used is by
appending elements.
</p>

</aside>

</section>
<section id="slide-org4a475d8">
<h3 id="org4a475d8">Now consider:</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s1</span> = <span style="color: #D01A4E;">"Greetings, planet"</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s2</span> = <span style="color: #859900;">std</span>::move<span style="color: #2aa198;">(</span>s1<span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
What's the moved-from state of <code>s1</code>?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s3</span> = <span style="color: #D01A4E;">"Hello, world"</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s4</span> = <span style="color: #859900;">std</span>::move<span style="color: #2aa198;">(</span>s3<span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
What's the moved-from state of <code>s3</code>?
</p>

<aside class="notes">
<p>
What is the state of s1 after the move? Same as the vector case basically.
</p>

<p>
But the first example is small-string optimized. What happens when you move from
a small string? You have to copy.
</p>

<p>
What is the state of s1 in the first case? It happens that all major
implementations will set the size to zero on a move, even when in the small
string buffer. So it's actually ever so slightly <i>slower</i> than a copy.
</p>

<p>
If you're lucky, the optimizer can help you out and spot dead stores&#x2026;
</p>

<p>
Bloomberg's STL does not clear a moved-from SSO string.
</p>

</aside>

</section>
<section id="slide-org635c9c1">
<h3 id="org635c9c1">Observation</h3>
<div class='vertspace2'></div>
<p>
Moving from a <code>string</code> <i>usually isn't any faster</i> than copying from it.
</p>

<div class='vertspace2'></div>
<p>
(If you doubt this, ask yourself why the small string optimization exists in the
first place.)
</p>

<p>
Moves <i>only</i> matter for objects on the heap.
</p>

<p>
<a href="http://quick-bench.com/7zo0OLXgCyR3v_KwZKNIe5Z5Z64">http://quick-bench.com/7zo0OLXgCyR3v_KwZKNIe5Z5Z64</a>
</p>

<aside class="notes">
<p>
And as noted, it may be technically slower.
</p>

</aside>

</section>
<section id="slide-orgb34d664">
<h3 id="orgb34d664">Exhibit B</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">void</span> <span style="color: #859900;">Context</span>::<span style="color: #2aa198;">Trigger</span><span style="color: #2aa198;">(</span><span style="color: #ff00ff;">/* </span><span style="color: #ff00ff;">some args */</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">ResponseCallback</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">function</span><span style="color: #b58900;">&lt;</span><span style="color: #ff00ff;">/* </span><span style="color: #ff00ff;">some signature */</span><span style="color: #b58900;">&gt;</span>;

  <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">Make sure that it will trigger only once.</span>
  <span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">ResponseCallback</span> <span style="color: #cb4b16;">callback</span> = <span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>m_responseCallback<span style="color: #b58900;">)</span>;
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>callback<span style="color: #b58900;">)</span>
  <span style="color: #b58900;">{</span>
    callback<span style="color: #94BFF3;">(</span>errorCode, errorReason, payload, size, opaque<span style="color: #94BFF3;">)</span>;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
<p>
Is this comment telling the truth?
</p>

<aside class="notes">
<p>
Playing with fire. The comment is misleading. We're relying on implementation.
</p>

<p>
Function has a small buffer optimization just like string. There's no reason for
function to be null after a move.
</p>

<p>
Think back to the vector case now: what happens if the container is replaced
with a small-buffer optimizable container?
</p>

</aside>

</section>
<section id="slide-org73e779c">
<h3 id="org73e779c">Guideline</h3>
<p>
Don't assume things are empty after a <code>move</code>.
</p>

<p>
Use <code>exchange</code> to make sure. Assigning an empty object is a trivial price for
safety.
</p>

<div class="org-src-container">

<pre  class="src src-c++">m_result.extra = <span style="color: #859900;">std</span>::exchange<span style="color: #2aa198;">(</span>m_readBuffer, <span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">OnResponseCallback</span> <span style="color: #cb4b16;">cb</span> = <span style="color: #859900;">std</span>::exchange<span style="color: #2aa198;">(</span>m_responseCallback, <span style="color: #859900;">nullptr</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
Make your code safe for future small-buffer optimizations.
</p>

<aside class="notes">
<p>
<code>std::exchange</code> is an underappreciated function. It's C++14 but if you're only
on C++11 you can easily provide your own version.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org9dd17ad">
<h2 id="org9dd17ad">2. Copy Elision</h2>
<div class='vertspace2'></div>
<blockquote nil><p>&quot;If you will, lead these graces to the grave<br>And leave the world no copy.&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>Twelfth Night, or What You Will</em></div></blockquote>


</section>
<section id="slide-orgf1e284b">
<h3 id="orgf1e284b">Copy Elision, aka RVO</h3>
<div class='vertspace2'></div>
<p>
Q. What is the Return Value Optimization?
</p>
<div class='vertspace2'></div>
<p>
A. Perhaps the most important optimization the compiler does.
</p>
<div class='vertspace2'></div>
<p>
[<a href="http://eel.is/c++draft/class.copy.elision">class.copy.elision</a>]
</p>

<aside class="notes">
<p>
When we talk about in-place construction, the return value optimization is a
good starting point.
</p>

<p>
This is such an important optimization that all competitive compilers have done
it for decades. And it's right on the border of optimizations your compiler will
do for you whether or not you ask for it.
</p>

<p>
If you look for it in the standard, it's called class.copy.elision. But that's
not the whole story, because that deals with so-called NAMED RVO. There is also
elision of temporaries or UNNAMED RVO which is often much more reliable.
</p>

</aside>

</section>
<section id="slide-org1474574">
<h3 id="org1474574">RVO in pictures</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo_singleslide.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<aside class="notes">
<p>
When a function is called, the caller passes an extra argument: the address of
the return value, which is in the caller's stack frame. So that when the callee
returns, it can copy the returned value to that address.
</p>

<p>
The return value optimization is where the callee can construct the result
directly in the space reserved in the caller's stack frame. There is no need for
the callee to have space in its stack frame, or incur the copy on return.
</p>

</aside>

</section>
<section id="slide-orgb296fa7">
<h3 id="orgb296fa7">When can RVO not apply?</h3>
<p>
RVO Rules: what is returned has to be either:
</p>

<ul>
<li>a temporary (prvalue)</li>
<li>the name of a stack variable</li>

</ul>

<aside class="notes">
<p>
So when it comes to thinking about whether or not RVO can happen, we have to
think about two distinct things:
</p>

<ul>
<li>is it allowed by the standard?</li>
<li>is it possible?</li>

</ul>

<p>
The standard rules are pretty simple. Either URVO or NRVO.
</p>

</aside>

</section>
<section id="slide-org118b2bf">
<h3 id="org118b2bf">When can RVO not apply?</h3>
<p>
RVO Ability: sometimes, the callee <i>can't</i> construct the object in-place.
</p>

<ul>
<li>if there is no opportunity to</li>
<li>if it's not of the right type</li>
<li>if the callee doesn't know enough</li>

</ul>

<aside class="notes">
<p>
More interesting is to think about when it's possible.
</p>

<p>
Function arguments - that are passed to you already-constructed - can't be RVOed
on return. But you can move them.
</p>

<p>
You have to know at construction time that you're going to be returning that
variable in order to RVO it.
</p>

</aside>

</section>
<section id="slide-orgf5b1ea5">
<h3 id="orgf5b1ea5">No RVO because no opportunity</h3>
<p>
You can't RVO a variable if you didn't get the chance to construct it in the
first place.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #2aa198;">sad_function</span><span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  s += <span style="color: #D01A4E;">"No RVO for you!"</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> s;
<span style="color: #2aa198;">}</span>
</pre>
</div>
<p>
But the compiler will still move it. (Since C++11)
</p>

<aside class="notes">
<p>
C++11 mandates that if you can't do the RVO, you must try to move and only copy
as a last resort.
</p>

</aside>

</section>
<section id="slide-orgd94b504">
<h3 id="orgd94b504">No RVO because wrong type, 1</h3>
<p>
An rvalue-ref is not the same type.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #2aa198;">sad_function</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s</span> = <span style="color: #D01A4E;">"No RVO for you!"</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> <span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
Don't <code>return std::move(x)</code> in most cases - you will get a move when you didn't
need anything!
</p>

<aside class="notes">
<p>
There are legitimate cases for returning an rvalue reference. e.g. value
wrappers with ref-qualified get functions.
</p>

<p>
But there are whole other talks on this.
</p>

</aside>

</section>
<section id="slide-org97f3033">
<h3 id="org97f3033">No RVO because wrong type, 2</h3>
<p>
Factory functions often can't RVO.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">Base</span> <span style="color: #2aa198;">{</span> <span style="color: #2aa198;">...</span> <span style="color: #2aa198;">}</span>;
<span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">Derived</span> : <span style="color: #268bd2;">Base</span> <span style="color: #2aa198;">{</span> <span style="color: #2aa198;">...</span> <span style="color: #2aa198;">}</span>;

<span style="color: #859900;">std</span>::<span style="color: #268bd2;">shared_ptr</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">Base</span><span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">factory</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> <span style="color: #859900;">std</span>::make_shared<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">Derived</span><span style="color: #b58900;">&gt;()</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
<p>
But will still move.
</p>

<aside class="notes">
<p>
This is also true of any types that are inter-convertible.
e.g. returning a pair when the function returns a tuple, or something like that.
</p>

</aside>

</section>
<section id="slide-org63bb3dc">
<h3 id="org63bb3dc">No RVO because not enough info</h3>
<p>
It has to be decidable at construction time.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #2aa198;">undecided_function</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">happy</span> = <span style="color: #D01A4E;">"Hooray"</span>;
  <span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">sad</span> = <span style="color: #D01A4E;">"Boo hoo"</span>;

  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>getHappiness<span style="color: #94BFF3;">()</span> &gt; <span style="color: #859900;">0.5</span><span style="color: #b58900;">)</span>
    <span style="color: #b58900; font-weight: bold;">return</span> happy;
  <span style="color: #b58900; font-weight: bold;">else</span>
    <span style="color: #b58900; font-weight: bold;">return</span> sad;
<span style="color: #2aa198;">}</span>

</pre>
</div>
<p>
Again, return value will still be moved.
</p>

</section>
<section id="slide-org81867e4">
<h3 id="org81867e4">Why is RVO important?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string, <span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span>;

<span style="color: #268bd2;">M</span> <span style="color: #2aa198;">build_map</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
  m.insert<span style="color: #b58900;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #94BFF3;">(</span><span style="color: #D01A4E;">"Jenny"</span>, <span style="color: #859900;">8675309</span><span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> m;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Because move isn't necessarily cheap.
</p>

<p>
Imagine you have this code, and you don't have RVO (which you do here).
</p>

<p>
Imagine this is using Microsoft's STL.
</p>

</aside>

</section>
<section id="slide-org0f303bb">
<h3 id="org0f303bb">Why is RVO so important?</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><img src="./map_move.png" alt="map_move.png" />
</p>
</div>

<aside class="notes">
<p>
Microsoft's current ABI uses stable sentinel nodes. This means a move construct
of a node-based container must allocate.
</p>

</aside>

</section>
<section id="slide-org18641ac">
<h3 id="org18641ac">Quiz time</h3>
<p>
Wake up!
</p>

<p>
And tell me if the upcoming code snippets will activate RVO.
</p>

</section>
<section id="slide-orgcb45b65">
<h3 id="orgcb45b65">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes.
</p>

<aside class="notes">
<p>
Yes. You're allowed to cv-qualify return types and RVO still works.
</p>

<p>
But don't do this. The compiler ignores const-qualified builtin types anyway.
</p>

</aside>

</section>
<section id="slide-orgcc784d3">
<h3 id="orgcc784d3">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span>
    <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
  <span style="color: #b58900; font-weight: bold;">else</span>
    <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes. Even in debug builds.
</p>

<aside class="notes">
<p>
Yes. This is URVO, and works pretty reliably even in debug builds.
</p>

</aside>

</section>
<section id="slide-org5131def">
<h3 id="org5131def">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span>, <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span>
    s = S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> s;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
No (no opportunity).
</p>

<aside class="notes">
<p>
No - can't RVO a function parameter. It will move though.
</p>

</aside>

</section>
<section id="slide-orgf726798">
<h3 id="orgf726798">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">get_S</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>; <span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span>
    <span style="color: #b58900; font-weight: bold;">return</span> get_S<span style="color: #b58900;">()</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes (can elide multiple copies).
</p>

<aside class="notes">
<p>
Yes. This RVOs.
RVO is allowed to elide multiple copies down the callstack.
</p>

</aside>

</section>
<section id="slide-org3f0241a">
<h3 id="org3f0241a">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span>
  <span style="color: #b58900;">{</span>
    <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span><span style="color: #94BFF3;">{</span><span style="color: #859900;">1</span><span style="color: #94BFF3;">}</span>;
    <span style="color: #b58900; font-weight: bold;">return</span> s;
  <span style="color: #b58900;">}</span>
  <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes (Clang), no (MSVC/GCC).
</p>

<aside class="notes">
<p>
There's nothing stopping it&#x2026; but only Clang successfully RVO's this.
</p>

</aside>

</section>
<section id="slide-org034be96">
<h3 id="org034be96">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span><span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span>
    <span style="color: #b58900; font-weight: bold;">return</span> s;
  <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
No. Possibly in future?
</p>

<aside class="notes">
<p>
We hoisted the S out of the condition.
</p>

<p>
No RVO here (a sufficiently smart compiler might be able to&#x2026;)
</p>

<p>
It still moves.
</p>

</aside>

</section>
<section id="slide-org354e13c">
<h3 id="org354e13c">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span><span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> b ? s : S<span style="color: #b58900;">{</span><span style="color: #859900;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
No. (Against the rules.)
</p>

<aside class="notes">
<p>
No RVO. We're not naming a variable.
Will it still move? No.
</p>

<p>
We're not naming a variable. And it's not a prvalue - the conditional operator
produces an lvalue reference here. We have to copy.
</p>

<p>
This is perhaps a semi-common pattern that defeats RVO!
</p>

</aside>

</section>
<section id="slide-org2de9f13">
<h3 id="org2de9f13">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">get_S</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>; <span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">bool</span> <span style="color: #cb4b16;">b</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> b ? get_S<span style="color: #b58900;">()</span> : S<span style="color: #b58900;">{</span><span style="color: #859900;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes. (Returning temporary.)
</p>

<aside class="notes">
<p>
This RVOs. This time the conditional operator produces a prvalue because both of
its operands are prvalues.
</p>

</aside>

</section>
<section id="slide-org2dae4d1">
<h3 id="org2dae4d1">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span><span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
  s = S<span style="color: #b58900;">{</span><span style="color: #859900;">2</span><span style="color: #b58900;">}</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> s;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes.
</p>

<aside class="notes">
<p>
Yep. Plain NRVO.
</p>

</aside>

</section>
<section id="slide-orgf4dde36">
<h3 id="orgf4dde36">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">will_it_rvo</span><span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">s</span><span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> <span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes.
</p>
<p class="fragment (appear)">
<a href="http://eel.is/c++draft/class.copy.elision#3.1" class="fragment (appear)">class.copy.elision &sect; 3.1</a>
</p>

<aside class="notes">
<p>
The standard explicitly allows this &#x2013; (possibly parenthesized) <i>id-expression</i>.
</p>

<p>
However&#x2026; there seems to be a bug in GCC where it doesn't RVO this. MSVC does
and Clang does.
</p>

<p>
Technically GCC is still adhering to the standard, because it's not required to
RVO. It does in C++11 mode, just not in C++14 or C++17 mode.
</p>

</aside>

</section>
<section id="slide-org8f88850">
<h3 id="org8f88850">Exhibit C</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">unsigned</span> <span style="color: #268bd2;">long</span> <span style="color: #268bd2;">long</span> <span style="color: #2aa198;">Time</span><span style="color: #2aa198;">()</span> <span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #b58900; font-weight: bold;">override</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">auto</span> <span style="color: #cb4b16;">ts</span> = <span style="color: #859900;">std</span>::get<span style="color: #b58900;">&lt;</span><span style="color: #859900;">1</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">std</span>::move<span style="color: #94BFF3;">(</span><span style="color: #859900;">Base</span>::metrics_-&gt;GetDataPointAndTime<span style="color: #dc322f;">()</span><span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span>;
  <span style="color: #b58900; font-weight: bold;">return</span> ts;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
Superfluous (potentially dangerous?) call to <code>std::move</code>.
</p>

<p>
NRVO is not guaranteed in debug mode. Better:
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">unsigned</span> <span style="color: #268bd2;">long</span> <span style="color: #268bd2;">long</span> <span style="color: #2aa198;">Time</span><span style="color: #2aa198;">()</span> <span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #b58900; font-weight: bold;">override</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> <span style="color: #859900;">std</span>::get<span style="color: #b58900;">&lt;</span><span style="color: #859900;">1</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">Base</span>::metrics_-&gt;GetDataPointAndTime<span style="color: #94BFF3;">()</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Just an integral type here, so no big deal. But if it gets changed, or this
pattern gets copied&#x2026;
</p>

</aside>

</section>
<section id="slide-orga426e92">
<h3 id="orga426e92">Guidelines for RVO-friendliness</h3>
<ul>
<li>don't const-qualify returned value types</li>
<li>almost never return <code>std::move(x)</code></li>
<li>return temporaries where you can</li>
<li>when you return named things, avoid conditions</li>
<li>don't parenthesize return expressions</li>

</ul>

<aside class="notes">
<p>
First point does not affect RVO but is generally useless.
</p>

<p>
Returning <code>std::move(x)</code> is only for ref-qualified accessors.
</p>

<p>
URVO is easier for the compiler than NRVO. You are likely to get URVO in debug
builds.
</p>

<p>
Beware of the conditional operator.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org3654f75">
<h2 id="org3654f75">3. Putting stuff into a <code>vector</code></h2>
<p>
Should you use <code>push_back</code> or should you use <code>emplace_back</code>?
</p>

<p>
How should you use them?
</p>

<div class='vertspace2'></div>
<blockquote nil><p>&quot;Didst thou not say, when I did push thee back --<br>Which was when I perceived thee -- that thou camest<br>From good descending?&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>Pericles</em></div></blockquote>

</section>
<section id="slide-orgcf1cdda">
<h3 id="orgcf1cdda"><code>push_back</code> and <code>emplace_back</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">void</span> <span style="color: #2aa198;">push_back</span><span style="color: #2aa198;">(</span><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">T</span>&amp; <span style="color: #cb4b16;">x</span><span style="color: #2aa198;">)</span>;
<span style="color: #268bd2;">void</span> <span style="color: #2aa198;">push_back</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">T</span>&amp;&amp; <span style="color: #cb4b16;">x</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">reference</span> <span style="color: #2aa198;">emplace_back</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">Args</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Until C++17, <code>emplace_back</code> returns <code>void</code>.
</p>

</aside>

</section>
<section id="slide-org6d915e4">
<h3 id="org6d915e4">Example 1</h3>
<p>
What's the difference here?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s</span>;
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">...</span>

v.push_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
There is no difference.
</p>

</aside>

</section>
<section id="slide-org767aaa3">
<h3 id="org767aaa3">Example 1.1</h3>
<p>
What's the difference here?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span> <span style="color: #cb4b16;">s</span>;

v.push_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">string</span>&amp; <span style="color: #cb4b16;">last_s</span> = v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
If we want to capture a reference to the thing that was pushed, we can use
<code>emplace_back</code>.
</p>

</aside>

</section>
<section id="slide-org33372f2">
<h3 id="org33372f2">Example 2</h3>
<p>
What's the difference here?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">char</span>* <span style="color: #cb4b16;">s</span> = <span style="color: #D01A4E;">"Hello"</span>;

v.push_back<span style="color: #2aa198;">(</span>s<span style="color: #2aa198;">)</span>;
v.emplace_back<span style="color: #2aa198;">(</span>s<span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
<code>push_back</code> constructs a temporary then moves it.
</p>

<p>
<code>emplace_back</code> constructs directly in place.
</p>

<p>
Remember, for string, a move is usually as expensive as a copy.
</p>

</aside>

</section>
<section id="slide-org2060a1f">
<h3 id="org2060a1f">Example 2.1</h3>
<p>
Default in-place construct.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">first default-construct in the vector</span>
<span style="color: #268bd2;">S</span>&amp; <span style="color: #cb4b16;">s</span> = v.emplace_back<span style="color: #2aa198;">()</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">now mutate s</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">...</span>
</pre>
</div>

<p>
<code>emplace_back</code> takes a parameter pack. Parameter packs can be empty.
</p>

<aside class="notes">
<p>
<code>emplace_back</code> is especially useful for this use case.
</p>

</aside>

</section>
<section id="slide-org4882e99">
<h3 id="org4882e99">Example 3</h3>
<p>
In-place construct with <code>explicit</code> constructor.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">recall: S has an explicit constructor from int</span>
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">push_back can't do explicit construction</span>
v.push_back<span style="color: #2aa198;">(</span><span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;  <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">compiler error!</span>

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">explicit construction is no problem for emplace_back</span>
<span style="color: #268bd2;">S</span>&amp; <span style="color: #cb4b16;">s</span> = v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
<code>emplace_back</code> does perfect forwarding. It can call <code>explicit</code> constructors.
</p>

<aside class="notes">
<p>
<code>emplace_back</code> is especially useful for this use case.
</p>

</aside>

</section>
<section id="slide-orgaf04c3a">
<h3 id="orgaf04c3a">Example: copy</h3>
<p>
Recall: our <code>S</code> class has a constructor from <code>Foo</code>, and an <code>explicit</code> constructor
from <code>int</code>.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">array</span><span style="color: #2aa198;">&lt;</span>Foo, <span style="color: #859900;">3</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">a</span> = <span style="color: #2aa198;">{</span> Foo<span style="color: #b58900;">{}</span>, Foo<span style="color: #b58900;">{}</span>, Foo<span style="color: #b58900;">{}</span> <span style="color: #2aa198;">}</span>;
v.reserve<span style="color: #2aa198;">(</span>a.size<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900;">std</span>::copy<span style="color: #2aa198;">(</span>a.cbegin<span style="color: #b58900;">()</span>, a.cend<span style="color: #b58900;">()</span>, <span style="color: #859900;">std</span>::back_inserter<span style="color: #b58900;">(</span>v<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
What does <code>back_insert_iterator</code> do here?
</p>

<aside class="notes">
<p>
For each element, we construct an <code>S</code> (from the <code>Foo</code>) and then we move it into
the <code>vector</code>.
</p>

</aside>

</section>
<section id="slide-orgb5ced6f">
<h3 id="orgb5ced6f">Example: copy</h3>
<p>
What if we have an <code>array</code> of <code>int</code>?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">array</span> <span style="color: #cb4b16;">a</span> = <span style="color: #2aa198;">{</span> <span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span>,<span style="color: #859900;">4</span>,<span style="color: #859900;">5</span> <span style="color: #2aa198;">}</span>;
v.reserve<span style="color: #2aa198;">(</span>a.size<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900;">std</span>::copy<span style="color: #2aa198;">(</span>a.cbegin<span style="color: #b58900;">()</span>, a.cend<span style="color: #b58900;">()</span>, <span style="color: #859900;">std</span>::back_inserter<span style="color: #b58900;">(</span>v<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p class="fragment (appear)">
Oops. The compiler is angry at us.
</p>

<aside class="notes">
<p>
<code>back_insert_iterator</code> calls <code>push_back</code> - it can't call our explicit
constructor.
</p>

</aside>

</section>
<section id="slide-org369e3d0">
<h3 id="org369e3d0">Example: copy?</h3>
<p>
OK, no problem, right?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">array</span> <span style="color: #cb4b16;">a</span> = <span style="color: #2aa198;">{</span> <span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span>,<span style="color: #859900;">4</span>,<span style="color: #859900;">5</span> <span style="color: #2aa198;">}</span>;
v.reserve<span style="color: #2aa198;">(</span>a.size<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900;">std</span>::transform<span style="color: #2aa198;">(</span>a.cbegin<span style="color: #b58900;">()</span>, a.cend<span style="color: #b58900;">()</span>, <span style="color: #859900;">std</span>::back_inserter<span style="color: #b58900;">(</span>v<span style="color: #b58900;">)</span>,
               <span style="color: #b58900;">[]</span> <span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span> <span style="color: #cb4b16;">i</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #94BFF3;">{</span>i<span style="color: #94BFF3;">}</span>; <span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
For each element, we construct an <code>S</code> (from the <code>int</code>) and then we move it into
the <code>vector</code>. No extra cost over the first solution, because the <code>return</code> from the
lambda RVOs.
</p>

<p>
But what we actually want to do is construct in place.
</p>

</aside>

</section>
<section id="slide-org140b069">
<h3 id="org140b069"><code>back_emplacer</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">Container</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">back_emplace_iterator</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">back_emplace_iterator</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">Container</span>&amp; <span style="color: #cb4b16;">c</span><span style="color: #b58900;">)</span> : c<span style="color: #b58900;">(</span>&amp;c<span style="color: #b58900;">)</span> <span style="color: #b58900;">{}</span>

  <span style="color: #268bd2;">back_emplace_iterator</span>&amp; <span style="color: #b58900; font-weight: bold;">operator</span><span style="color: #2aa198;">++</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> *<span style="color: #b58900; font-weight: bold;">this</span>; <span style="color: #b58900;">}</span>
  <span style="color: #268bd2;">back_emplace_iterator</span>&amp; <span style="color: #b58900; font-weight: bold;">operator</span><span style="color: #2aa198;">*</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> *<span style="color: #b58900; font-weight: bold;">this</span>; <span style="color: #b58900;">}</span>

  <span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #b58900;">&lt;</span><span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">Arg</span><span style="color: #b58900;">&gt;</span>
  <span style="color: #268bd2;">back_emplace_iterator</span>&amp; <span style="color: #b58900; font-weight: bold;">operator</span><span style="color: #2aa198;">=</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">Arg</span>&amp;&amp; <span style="color: #cb4b16;">arg</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    c-&gt;emplace_back<span style="color: #94BFF3;">(</span><span style="color: #859900;">std</span>::forward<span style="color: #dc322f;">&lt;</span><span style="color: #268bd2;">Arg</span><span style="color: #dc322f;">&gt;(</span><span style="color: #cb4b16;">arg</span><span style="color: #dc322f;">)</span><span style="color: #94BFF3;">)</span>;
    <span style="color: #b58900; font-weight: bold;">return</span> *<span style="color: #b58900; font-weight: bold;">this</span>;
  <span style="color: #b58900;">}</span>

<span style="color: #b58900; font-weight: bold;">private</span>:
  <span style="color: #268bd2;">Container</span>* <span style="color: #cb4b16;">c</span>;
<span style="color: #2aa198;">}</span>;
</pre>
</div>

</section>
<section id="slide-org48d6298">
<h3 id="org48d6298"><code>back_emplacer</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">pre-CTAD maker function</span>

<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">Container</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">auto</span> <span style="color: #2aa198;">back_emplacer</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">Container</span>&amp; <span style="color: #cb4b16;">c</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> back_emplace_iterator<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">Container</span><span style="color: #b58900;">&gt;(</span>c<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

</section>
<section id="slide-org76f3356">
<h3 id="org76f3356"><code>back_emplacer</code></h3>
<p>
What if we have an <code>array</code> of <code>int</code>?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">array</span> <span style="color: #cb4b16;">a</span> = <span style="color: #2aa198;">{</span> <span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span>,<span style="color: #859900;">4</span>,<span style="color: #859900;">5</span> <span style="color: #2aa198;">}</span>;
v.reserve<span style="color: #2aa198;">(</span>a.size<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900;">std</span>::copy<span style="color: #2aa198;">(</span>a.cbegin<span style="color: #b58900;">()</span>, a.cend<span style="color: #b58900;">()</span>, back_emplacer<span style="color: #b58900;">(</span>v<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

</section>
<section id="slide-org9636497">
<h3 id="org9636497">Exhibit D</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string_view<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">tokens</span>;
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">...</span>
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">string_view</span> <span style="color: #cb4b16;">token</span> = <span style="color: #ff00ff;">/* </span><span style="color: #ff00ff;">stuff */</span>;
tokens.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::move<span style="color: #b58900;">(</span>token<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
A few things here:
</p>
<ul>
<li><code>string_view</code> is a pointer + length. recommendation is to pass by value;
<code>move</code> gains nothing anyway.</li>
<li><code>push_back</code> works with rvalues just fine - <code>emplace_back</code> gains nothing here.</li>
<li>if you want to, you should pass <code>/* stuff */</code> directly to <code>emplace_back</code>.</li>

</ul>

</aside>

</section>
<section id="slide-org9ee0e60">
<h3 id="org9ee0e60">Exhibit E</h3>
<div class="org-src-container">

<pre  class="src src-c++">context-&gt;m_result-&gt;m_headers.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::string<span style="color: #b58900;">(</span>headerData, numBytes<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
A superfluous move! Better:
</p>

<div class="org-src-container">

<pre  class="src src-c++">context-&gt;m_result-&gt;m_headers.emplace_back<span style="color: #2aa198;">(</span>headerData, numBytes<span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
Don't explicitly call a constructor with <code>emplace_back</code>.
</p>

<aside class="notes">
<p>
And remember, likely a superfluous copy if the string is small-buffer-optimized.
</p>

</aside>

</section>
<section id="slide-org5999168">
<h3 id="org5999168"><code>vector</code> of <code>pair</code> = <code>map</code></h3>
<p>
Sometimes, we use a  sorted <code>vector</code> of <code>pair</code> as a replacement for <code>map</code>.
</p>

<p>
What do you do if part of your <code>pair</code> has a multi-argument constructor?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">Foo</span> <span style="color: #2aa198;">{</span> <span style="color: #2aa198;">Foo</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span>, <span style="color: #859900;">std</span>::string, <span style="color: #268bd2;">double</span><span style="color: #b58900;">)</span>; <span style="color: #2aa198;">}</span>;

<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">pair</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span>, <span style="color: #268bd2;">Foo</span><span style="color: #b58900;">&gt;</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">this is very common!</span>
v.push_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span><span style="color: #859900;">1</span>, Foo<span style="color: #94BFF3;">{</span><span style="color: #859900;">42</span>, <span style="color: #D01A4E;">"hello"</span>, <span style="color: #859900;">3.14</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">this is no better</span>
v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span><span style="color: #859900;">1</span>, Foo<span style="color: #94BFF3;">{</span><span style="color: #859900;">42</span>, <span style="color: #D01A4E;">"hello"</span>, <span style="color: #859900;">3.14</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">how can we do better?</span>
v.emplace_back<span style="color: #2aa198;">(</span> <span style="color: #ff00ff;">/* </span><span style="color: #ff00ff;">what here? */</span> <span style="color: #2aa198;">)</span>;
</pre>
</div>

</section>
<section id="slide-org59dfef2">
<h3 id="org59dfef2"><code>piecewise_construct</code> to the rescue!</h3>
<p>
<code>pair</code> has a constructor that will handle your multi-argument constructor.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args1</span>, <span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args2</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #2aa198;">pair</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">piecewise_construct_t</span>,
     <span style="color: #268bd2;">tuple</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">Args1</span><span style="color: #2aa198;">...</span><span style="color: #b58900;">&gt;</span> <span style="color: #cb4b16;">first_args</span>,
     <span style="color: #268bd2;">tuple</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">Args2</span><span style="color: #2aa198;">...</span><span style="color: #b58900;">&gt;</span> <span style="color: #cb4b16;">second_args</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Types</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">constexpr</span> <span style="color: #268bd2;">tuple</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">Types</span>&amp;&amp;<span style="color: #2aa198;">...</span><span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">forward_as_tuple</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">Types</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span> <span style="color: #b58900; font-weight: bold;">noexcept</span>;
</pre>
</div>

<p>
<code>piecewise_construct_t</code> is a tag type.
</p>

</section>
<section id="slide-org6ab65b7">
<h3 id="org6ab65b7">Using <code>piecewise_construct</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">Foo</span> <span style="color: #2aa198;">{</span> <span style="color: #2aa198;">Foo</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span>, <span style="color: #859900;">std</span>::string, <span style="color: #268bd2;">double</span><span style="color: #b58900;">)</span>; <span style="color: #2aa198;">}</span>;

<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">pair</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span>, <span style="color: #268bd2;">Foo</span><span style="color: #b58900;">&gt;</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">instead of this...</span>
v.push_back<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span><span style="color: #859900;">1</span>, Foo<span style="color: #94BFF3;">{</span><span style="color: #859900;">42</span>, <span style="color: #D01A4E;">"hello"</span>, <span style="color: #859900;">3.14</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">...we can do this</span>
v.emplace_back<span style="color: #2aa198;">(</span>
  <span style="color: #859900;">std</span>::piecewise_construct,
  <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">(</span><span style="color: #859900;">1</span><span style="color: #b58900;">)</span>,                   <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">args to int "constructor"</span>
  <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">(</span><span style="color: #859900;">42</span>, <span style="color: #D01A4E;">"hello"</span>, <span style="color: #859900;">3.14</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span><span style="color: #88090B;">)</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">args to Foo constructor</span>
</pre>
</div>
<p>
Perfect forwarding and in-place construction.
</p>

</section>
<section id="slide-org563e400">
<h3 id="org563e400">Recommendations</h3>
<ul>
<li><code>push_back</code> is perfectly fine for rvalues</li>
<li>use <code>emplace_back</code> only when you need its powers
<ul>
<li>in-place construction (including nullary construction)</li>
<li>a reference to what's added (C++17)</li>

</ul></li>
<li>never pass an explicit temporary to <code>emplace_back</code></li>
<li>try to construct in place when you can</li>
<li>use <code>piecewise_construct</code> / <code>forward_as_tuple</code> to forward args through <code>pair</code></li>

</ul>

</section>
</section>
<section>
<section id="slide-org9c78bad">
<h2 id="org9c78bad">4. <code>initializer_list</code></h2>
<div class='vertspace2'></div>
<blockquote nil><p>&quot;I fear these stubborn lines lack power to move.&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>Love's Labours Lost</em></div></blockquote>

</section>
<section id="slide-orgae092ab">
<h3 id="orgae092ab">What is <code>initializer_list</code>?</h3>
<p>
When you write:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span><span style="color: #2aa198;">{</span> <span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span> <span style="color: #2aa198;">}</span>;
</pre>
</div>
<p>
It's as if you wrote:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">int</span> <span style="color: #cb4b16;">a</span><span style="color: #2aa198;">[]</span> = <span style="color: #2aa198;">{</span> <span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span> <span style="color: #2aa198;">}</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = <span style="color: #859900;">std</span>::initializer_list<span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;(</span>a, a+<span style="color: #859900;">3</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Notice: the backing array is <code>const</code>.
</p>

</aside>

</section>
<section id="slide-org7f6bfcd">
<h3 id="org7f6bfcd"><code>initializer_list</code> has <code>const</code> storage, 1</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">Is</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">auto</span> <span style="color: #2aa198;">f</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> <span style="color: #859900;">std</span>::<span style="color: #268bd2;">initializer_list</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;{</span> Is<span style="color: #2aa198;">...</span> <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">void</span> <span style="color: #2aa198;">foo</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span> <span style="color: #cb4b16;">i</span>: <span style="color: #94BFF3;">{</span><span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span>
    cout &lt;&lt; i &lt;&lt; <span style="color: #D01A4E;">'</span><span style="color: #5f127b; font-weight: bold;">\</span><span style="color: #b58900; font-weight: bold;">n</span><span style="color: #D01A4E;">'</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">void</span> <span style="color: #2aa198;">bar</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span> <span style="color: #cb4b16;">i</span>: f<span style="color: #94BFF3;">&lt;</span><span style="color: #859900;">1</span>,<span style="color: #859900;">2</span>,<span style="color: #859900;">3</span><span style="color: #94BFF3;">&gt;()</span><span style="color: #b58900;">)</span>
    cout &lt;&lt; i &lt;&lt; <span style="color: #D01A4E;">'</span><span style="color: #5f127b; font-weight: bold;">\</span><span style="color: #b58900; font-weight: bold;">n</span><span style="color: #D01A4E;">'</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<aside class="notes">
<p>
This is nasty, because it could work on one compiler and you wouldn't notice it.
</p>

<p>
The compiler probably won't warn for this.
</p>

<p>
<code>initializer_list</code> is a "view" type like <code>string_view</code> and doesn't own its
contents.
</p>

</aside>

</section>
<section id="slide-org2bf7983">
<h3 id="org2bf7983"><code>initializer_list</code> has <code>const</code> storage, 2</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">unique_ptr</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = <span style="color: #2aa198;">{</span> make_unique<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">1</span><span style="color: #b58900;">)</span>, make_unique<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">2</span><span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>;
</pre>
</div>
<p>
That also means <code>move</code> can't work.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #859900;">std</span>::<span style="color: #268bd2;">unique_ptr</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">a</span><span style="color: #2aa198;">[]</span> = <span style="color: #2aa198;">{</span> <span style="color: #859900;">std</span>::make_unique<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">1</span><span style="color: #b58900;">)</span>,
                                   <span style="color: #859900;">std</span>::make_unique<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">2</span><span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">unique_ptr</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;</span><span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> =
  <span style="color: #859900;">std</span>::initializer_list<span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">unique_ptr</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span><span style="color: #b58900;">&gt;</span><span style="color: #2aa198;">&gt;(</span>a, a+<span style="color: #859900;">3</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
You can't move from an <code>initializer_list</code> - this won't compile.
</p>

</aside>

</section>
<section id="slide-org0a0937e">
<h3 id="org0a0937e">But they're so convenient!</h3>
<p>
I'd much rather write:
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = <span style="color: #2aa198;">{</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>, S<span style="color: #b58900;">{</span><span style="color: #859900;">2</span><span style="color: #b58900;">}</span>, S<span style="color: #b58900;">{</span><span style="color: #859900;">3</span><span style="color: #b58900;">}</span> <span style="color: #2aa198;">}</span>;
</pre>
</div>
<p>
(3 constructs, 3 copies, 3 destructs)
</p>

<p>
Than:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
v.reserve<span style="color: #2aa198;">(</span><span style="color: #859900;">3</span><span style="color: #2aa198;">)</span>;
v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">2</span><span style="color: #2aa198;">)</span>;
v.emplace_back<span style="color: #2aa198;">(</span><span style="color: #859900;">3</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
<p>
(3 constructs)
</p>

<aside class="notes">
<p>
The first version is probably OK for builtin primitive types.
</p>

<p>
It's way worse than the second version for types with more than trivial
construction.
</p>

</aside>

</section>
<section id="slide-org238d67f">
<h3 id="org238d67f">We can make it a little better&#x2026;</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = <span style="color: #2aa198;">{</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>, S<span style="color: #b58900;">{</span><span style="color: #859900;">2</span><span style="color: #b58900;">}</span>, S<span style="color: #b58900;">{</span><span style="color: #859900;">3</span><span style="color: #b58900;">}</span> <span style="color: #2aa198;">}</span>;
</pre>
</div>
<p>
(3 constructs, 3 copies, 3 destructs)
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #cb4b16;">a</span><span style="color: #2aa198;">[</span><span style="color: #859900;">3</span><span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">{</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>, S<span style="color: #b58900;">{</span><span style="color: #859900;">2</span><span style="color: #b58900;">}</span>, S<span style="color: #b58900;">{</span><span style="color: #859900;">3</span><span style="color: #b58900;">}</span> <span style="color: #2aa198;">}</span>;
<span style="color: #859900;">std</span>::<span style="color: #268bd2;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">S</span><span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">v</span><span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">make_move_iterator</span><span style="color: #b58900;">(</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">begin</span><span style="color: #94BFF3;">(</span><span style="color: #cb4b16;">a</span><span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span>,
                 <span style="color: #859900;">std</span>::<span style="color: #268bd2;">make_move_iterator</span><span style="color: #b58900;">(</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">end</span><span style="color: #94BFF3;">(</span><span style="color: #cb4b16;">a</span><span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
<p>
(3 constructs, 3 moves, 3 destructs)
</p>

</section>
<section id="slide-org607a1a7">
<h3 id="org607a1a7">What we really need&#x2026;</h3>
<p>
Is an in-place constructor for <code>vector</code>. (For everything?)
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">vector</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">in_place_t</span>, <span style="color: #268bd2;">Args</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
Future (?) proposal by Simon Brand.
</p>

<p>
<a href="https://wg21.tartanllama.xyz/initializer_list">https://wg21.tartanllama.xyz/initializer_list</a>
</p>

</section>
<section id="slide-org055c31e">
<h3 id="org055c31e">Exhibit F</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">unordered_set</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">kKeywords</span> = <span style="color: #2aa198;">{</span>
        <span style="color: #D01A4E;">"alignas"</span>, <span style="color: #D01A4E;">"alignof"</span>, <span style="color: #D01A4E;">"and"</span>, <span style="color: #D01A4E;">"and_eq"</span>, <span style="color: #D01A4E;">"asm"</span>, <span style="color: #D01A4E;">"auto"</span>, <span style="color: #D01A4E;">"bitand"</span>, <span style="color: #D01A4E;">"bitor"</span>,
        <span style="color: #D01A4E;">"bool"</span>, <span style="color: #D01A4E;">"break"</span>, <span style="color: #D01A4E;">"case"</span>, <span style="color: #D01A4E;">"catch"</span>, <span style="color: #D01A4E;">"char"</span>, <span style="color: #D01A4E;">"class"</span>, <span style="color: #D01A4E;">"compl"</span>, <span style="color: #D01A4E;">"const"</span>,
        <span style="color: #D01A4E;">"constexpr"</span>, <span style="color: #D01A4E;">"const_cast"</span>, <span style="color: #D01A4E;">"continue"</span>, <span style="color: #D01A4E;">"decltype"</span>, <span style="color: #D01A4E;">"default"</span>, <span style="color: #D01A4E;">"delete"</span>, <span style="color: #333333; background-color: #000000;">"do"</span><span style="color: #333333; background-color: #000000;">,</span>
        <span style="color: #D01A4E;">"double"</span>, <span style="color: #D01A4E;">"dynamic_cast"</span>, <span style="color: #D01A4E;">"else"</span>, <span style="color: #D01A4E;">"enum"</span>, <span style="color: #D01A4E;">"explicit"</span>, <span style="color: #D01A4E;">"extern"</span>, <span style="color: #D01A4E;">"false"</span>,
        <span style="color: #D01A4E;">"float"</span>, <span style="color: #D01A4E;">"for"</span>, <span style="color: #D01A4E;">"friend"</span>, <span style="color: #D01A4E;">"goto"</span>, <span style="color: #D01A4E;">"if"</span>, <span style="color: #D01A4E;">"inline"</span>, <span style="color: #D01A4E;">"int"</span>, <span style="color: #D01A4E;">"long"</span>, <span style="color: #D01A4E;">"mutabl</span><span style="color: #333333; background-color: #000000;">e"</span><span style="color: #333333; background-color: #000000;">,</span>
        <span style="color: #D01A4E;">"namespace"</span>, <span style="color: #D01A4E;">"new"</span>, <span style="color: #D01A4E;">"noexcept"</span>, <span style="color: #D01A4E;">"not"</span>, <span style="color: #D01A4E;">"not_eq"</span>, <span style="color: #D01A4E;">"NULL"</span>, <span style="color: #D01A4E;">"operator"</span>, <span style="color: #D01A4E;">"or</span><span style="color: #333333; background-color: #000000;">"</span><span style="color: #333333; background-color: #000000;">,</span>
        <span style="color: #D01A4E;">"or_eq"</span>, <span style="color: #D01A4E;">"private"</span>, <span style="color: #D01A4E;">"protected"</span>, <span style="color: #D01A4E;">"public"</span>, <span style="color: #D01A4E;">"register"</span>, <span style="color: #D01A4E;">"reinterpret_cast</span><span style="color: #333333; background-color: #000000;">"</span><span style="color: #333333; background-color: #000000;">,</span>
        <span style="color: #D01A4E;">"return"</span>, <span style="color: #D01A4E;">"short"</span>, <span style="color: #D01A4E;">"signed"</span>, <span style="color: #D01A4E;">"sizeof"</span>, <span style="color: #D01A4E;">"static"</span>, <span style="color: #D01A4E;">"static_assert"</span>,
        <span style="color: #D01A4E;">"static_cast"</span>, <span style="color: #D01A4E;">"struct"</span>, <span style="color: #D01A4E;">"switch"</span>, <span style="color: #D01A4E;">"template"</span>, <span style="color: #D01A4E;">"this"</span>, <span style="color: #D01A4E;">"thread_local"</span>,
        <span style="color: #D01A4E;">"throw"</span>, <span style="color: #D01A4E;">"true"</span>, <span style="color: #D01A4E;">"try"</span>, <span style="color: #D01A4E;">"typedef"</span>, <span style="color: #D01A4E;">"typeid"</span>, <span style="color: #D01A4E;">"typename"</span>, <span style="color: #D01A4E;">"union"</span>, <span style="color: #D01A4E;">"unsig</span><span style="color: #333333; background-color: #000000;">ned"</span><span style="color: #333333; background-color: #000000;">,</span>
        <span style="color: #D01A4E;">"using"</span>, <span style="color: #D01A4E;">"virtual"</span>, <span style="color: #D01A4E;">"void"</span>, <span style="color: #D01A4E;">"volatile"</span>, <span style="color: #D01A4E;">"wchar_t"</span>, <span style="color: #D01A4E;">"while"</span>, <span style="color: #D01A4E;">"xor"</span>, <span style="color: #D01A4E;">"xor_</span><span style="color: #333333; background-color: #000000;">eq"</span>
<span style="color: #2aa198;">}</span>;
</pre>
</div>

</section>
<section id="slide-org2c2b72c">
<h3 id="org2c2b72c">Caveat Constructor</h3>
<p>
<code>std::string</code> is an interesting case here. We intuit/are taught:
</p>

<blockquote nil><p>Delay construction, allocation, etc. as late as possible.</p></blockquote>

<p>
But that might hurt us with <code>std::string</code>.
</p>

<p>
<a href="https://www.youtube.com/watch?v=sSlmmZMFsXQ">"Initializer Lists are Broken, Let's Fix Them"</a> &#x2013; Jason Turner, C++Now 2018
</p>

</section>
<section id="slide-orge40768d">
<h3 id="orge40768d">Surprising: <code>string</code> vs <code>const char*</code></h3>
<p>
SBO-strings
<a href="http://quick-bench.com/5dPSX8rx-R8_BIUYbYOp6DcqhAc">http://quick-bench.com/5dPSX8rx-R8_BIUYbYOp6DcqhAc</a>
</p>

<p>
Non SBO-strings 1:
<a href="http://quick-bench.com/mr6ZIQ8Jy0ghe1scBcTznYF2s5w">http://quick-bench.com/mr6ZIQ8Jy0ghe1scBcTznYF2s5w</a>
</p>

<p>
Non SBO-strings 2:
<a href="http://quick-bench.com/vzlG11LwZN-uMAKdK8X1XgRuaWs">http://quick-bench.com/vzlG11LwZN-uMAKdK8X1XgRuaWs</a>
</p>

<aside class="notes">
<p>
Two things mess with our mental model for strings. First - the small buffer
optimization. As previously mentioned, it makes copy the same cost as move.
</p>

<p>
Second - we often make strings from string literals. What's the type of a string
literal at declaration? Array of char. What's the type of it when you pass it to
a function? It decays to pointer to char.
</p>

<p>
So, if a string isn't small-buffer optimized, move is cheap. And if we're
constructing it from a string literal, the compiler knows the size. If we let it
decay to a char*, we're going to call strlen at some point.
</p>

</aside>

</section>
<section id="slide-orge7b2dfc">
<h3 id="orge7b2dfc">Recommendations</h3>
<ul>
<li>use <code>initializer_list</code> only for literal types</li>
<li>consider using <code>array</code> and manually moving</li>
<li>probably don't use <code>initializer_list</code> for anything that'll get run more than
once</li>
<li>wait for an <code>in_place_t</code> constructor on <code>vector</code> ?</li>
<li>watch Jason's talk</li>
<li>wait for P1249 (<code>std::forward</code> from <code>std::initializer_list</code>)?</li>

</ul>

<aside class="notes">
<p>
I'm not sure what to recommend. Really the first point.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org959515c">
<h2 id="org959515c">5. Putting stuff into a <code>map</code></h2>
<p>
(or other associative container)
</p>

<p>
It's a bit complicated.
</p>

<div class='vertspace2'></div>
<blockquote nil><p>&quot;A plague upon it! I have forgot the map.&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>Henry IV, Part I</em></div></blockquote>

<aside class="notes">
<p>
When I say <code>map</code>, I mean <code>map</code>, <code>unordered_map</code>, <code>multimap</code>, <code>unordered_multimap</code>,
etc, and also the various flavours of <code>set</code>.
</p>

<p>
Note: the <code>value_type</code> of a <code>map</code> is <code>pair&lt;const K, V&gt;</code>. Confusingly, if we want
to refer to just the value in the map and not the key, it's called the
<code>mapped_type</code>.
</p>

</aside>

</section>
<section id="slide-org8993dd3">
<h3 id="org8993dd3"><code>initializer_list</code> with <code>map</code></h3>
<p>
It's perfectly possible to initialize a map with an <code>initializer_list</code>.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">recall S has an implicit constructor from Foo</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span> <span style="color: #2aa198;">{</span> <span style="color: #b58900;">{</span><span style="color: #859900;">0</span>, Foo<span style="color: #94BFF3;">{}</span><span style="color: #b58900;">}</span> <span style="color: #2aa198;">}</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">how many constructs/copies/moves?</span>
</pre>
</div>

<p>
Use aggregate initialization with <code>pair</code>.
</p>

<p>
Is this good?
</p>

<aside class="notes">
<p>
Same as the <code>vector</code> init case basically. <code>initializer_list</code> still suffers from
the same problems.
</p>

<p>
You can't use explicit constructors easily here.
</p>

<p>
If you have explicit constructors you might need to explicitly call out the type
 of pair; it's not going to make a lot of difference.
</p>

</aside>

</section>
<section id="slide-org3367efa">
<h3 id="org3367efa">Alternative: templatery</h3>
<p>
<a href="https://gist.github.com/elbeno/609e929ef6898f09e96a#file-for_each_args-cpp-L55">https://gist.github.com/elbeno/609e929ef6898f09e96a#file-for_each_args-cpp-L55</a>
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">call an N-ary function on each lot of N args passed in</span>
<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">size_t</span> <span style="color: #cb4b16;">N</span>, <span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">F</span>, <span style="color: #b58900; font-weight: bold;">typename</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Ts</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">void</span> <span style="color: #2aa198;">for_each_n_args</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">F</span>&amp;&amp; <span style="color: #cb4b16;">f</span>, <span style="color: #268bd2;">Ts</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">ts</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
for_each_n_args<span style="color: #2aa198;">&lt;</span><span style="color: #859900;">2</span><span style="color: #2aa198;">&gt;(</span>
  <span style="color: #b58900;">[</span>&amp;<span style="color: #b58900;">]</span> <span style="color: #b58900;">(</span><span style="color: #b58900; font-weight: bold;">auto</span>&amp;&amp; <span style="color: #cb4b16;">k</span>, <span style="color: #b58900; font-weight: bold;">auto</span>&amp;&amp; <span style="color: #cb4b16;">v</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
      m.emplace<span style="color: #94BFF3;">(</span>forward<span style="color: #dc322f;">&lt;</span><span style="color: #b58900; font-weight: bold;">decltype</span><span style="color: #859900;">(</span>k<span style="color: #859900;">)</span><span style="color: #dc322f;">&gt;(</span>k<span style="color: #dc322f;">)</span>,
                forward<span style="color: #dc322f;">&lt;</span><span style="color: #b58900; font-weight: bold;">decltype</span><span style="color: #859900;">(</span>v<span style="color: #859900;">)</span><span style="color: #dc322f;">&gt;(</span>v<span style="color: #dc322f;">)</span><span style="color: #94BFF3;">)</span>; <span style="color: #b58900;">}</span>,
  <span style="color: #859900;">0</span>, <span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">we can call explicit constructor</span>
</pre>
</div>

<p>
If you know the types, you can probably write the lambda in a less ugly way.
</p>

<aside class="notes">
<p>
<code>for_each_n_args</code> is a function template that perfectly-forwards its arguments
in groups of N to the function you give it.
</p>

<p>
Everything here gets constructed in place. No moves or copies.
</p>

<p>
This lambda deals with single-argument constructors for value. But&#x2026;
</p>

</aside>

</section>
<section id="slide-org482e3ae">
<h3 id="org482e3ae">Alternative: multi-arg templatery</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
for_each_n_args<span style="color: #2aa198;">&lt;</span><span style="color: #859900;">3</span><span style="color: #2aa198;">&gt;(</span>
  <span style="color: #b58900;">[</span>&amp;<span style="color: #b58900;">]</span> <span style="color: #b58900;">(</span><span style="color: #b58900; font-weight: bold;">auto</span>&amp;&amp; <span style="color: #cb4b16;">k</span>, <span style="color: #b58900; font-weight: bold;">auto</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">v</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
      m.emplace<span style="color: #94BFF3;">(</span>
        <span style="color: #859900;">std</span>::piecewise_construct,
        <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #dc322f;">(</span><span style="color: #859900;">std</span>::forward<span style="color: #859900;">&lt;</span><span style="color: #b58900; font-weight: bold;">decltype</span><span style="color: #268bd2;">(</span>k<span style="color: #268bd2;">)</span><span style="color: #859900;">&gt;(</span>k<span style="color: #859900;">)</span><span style="color: #dc322f;">)</span>,
        <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #dc322f;">(</span><span style="color: #859900;">std</span>::forward<span style="color: #859900;">&lt;</span><span style="color: #b58900; font-weight: bold;">decltype</span><span style="color: #268bd2;">(</span>v<span style="color: #268bd2;">)</span><span style="color: #859900;">&gt;(</span>v<span style="color: #859900;">)</span><span style="color: #2aa198;">...</span><span style="color: #dc322f;">)</span>; <span style="color: #88090B;">}</span>,
  <span style="color: #859900;">0</span>, <span style="color: #859900;">1</span>, <span style="color: #859900;">2</span><span style="color: #88090B;">)</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">explicit multi-arg value constructor</span>
</pre>
</div>

<p>
Everything constructed in place.
</p>

<aside class="notes">
<p>
Here we are calling S's two-arg constructor.
</p>

<p>
<code>for_each_n_args</code> also works with vector (including vector-of-pair) as an
alternative to <code>initializer_list</code>
</p>

<p>
There are some issues with calling <code>explicit</code> constructors&#x2026; it depends on the
compiler/library. It is supposed to work.
</p>

</aside>

</section>
<section id="slide-org6b6f6ef">
<h3 id="org6b6f6ef">Enough about initializing</h3>
<p>
How about putting things into an existing <code>map</code>?
</p>

</section>
<section id="slide-orgba0ebfa">
<h3 id="orgba0ebfa">The Easy Way: <code>operator[]</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">recall S has an implicit constructor from Foo</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">but an explicit constructor from int</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m<span style="color: #2aa198;">[</span><span style="color: #859900;">0</span><span style="color: #2aa198;">]</span> = S<span style="color: #2aa198;">{</span><span style="color: #859900;">1</span><span style="color: #2aa198;">}</span>;
m<span style="color: #2aa198;">[</span><span style="color: #859900;">1</span><span style="color: #2aa198;">]</span> = Foo<span style="color: #2aa198;">{}</span>;
</pre>
</div>

<p>
How many constructs/moves/copies?
</p>

<aside class="notes">
<p>
These each have a construct, a default construct, and a move.
</p>

<p>
The advantage of this is that when you know the element is there already, it's
fine. You just get a lookup and an assign.
</p>

<p>
But if the element isn't there, you never get a copy construct or a move
construct here.
</p>

<p>
You always get an assign! Because you always get a default construct if the
element isn't there.
</p>

<p>
In fact this is the only function on map that requires your mapped_type to have
a default constructor! It's fine to use objects without default constructors in
a map, if you never use this function. And that can be a significant thing.
</p>

</aside>

</section>
<section id="slide-org1caa5da">
<h3 id="org1caa5da">The Other Easy Way: <code>insert</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">recall S has an implicit constructor from Foo</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">but an explicit constructor from int</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">pair&lt;iterator,bool&gt; insert(value_type&amp;&amp; value);</span>

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">template &lt;class T1, class T2&gt;</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">pair&lt;V1,V2&gt; make_pair(T1&amp;&amp; t, T2&amp;&amp; u);</span>

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">alternatives:</span>
m.insert<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span><span style="color: #859900;">0</span>, S<span style="color: #94BFF3;">{</span><span style="color: #859900;">1</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
m.insert<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::pair<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">int</span>, <span style="color: #268bd2;">S</span>&amp;&amp;<span style="color: #b58900;">&gt;(</span><span style="color: #859900;">0</span>, S<span style="color: #94BFF3;">{</span><span style="color: #859900;">1</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
m.insert<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span><span style="color: #859900;">0</span>, <span style="color: #859900;">1</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
How many constructs/moves/copies?
</p>

<aside class="notes">
<p>

</p>

<p>
The first line here creates an S, moves it into pair&lt;int, S&gt;, then moves the
pair into the map.
</p>

<p>
Remember that make_pair deduces the type of its arguments. And V1 and V2 here
are the decayed types of T1 and T2.
</p>

<p>
The second line forces a pair of type &lt;int, S&amp;&amp;&gt;, so you get one move after the
initial construct.
</p>

<p>
The third line makes a pair&lt;int, int&gt; then uses that pair to construct a pair of
&lt;int, S&gt; in the map.
</p>

</aside>

</section>
<section id="slide-org9a59063">
<h3 id="org9a59063"><code>emplace</code></h3>
<p>
Enter the <i>wonderful C++11 panacea</i> that is move semantics.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">recall S has an implicit constructor from Foo</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">but an explicit constructor from int</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">template &lt;class... Args&gt;</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">pair&lt;iterator,bool&gt; emplace(Args&amp;&amp;... args);</span>

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">this was 2 moves</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">m.insert(make_pair(0, S{1}));</span>

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">much better, right?</span>
m.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span><span style="color: #859900;">0</span>, S<span style="color: #94BFF3;">{</span><span style="color: #859900;">1</span><span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
You guessed it&#x2026;
</p>

<aside class="notes">
<p>
Don't do this. It is <i>exactly</i> the same as <code>insert</code> here. Two moves.
</p>

</aside>

</section>
<section id="slide-org0c73f9b">
<h3 id="org0c73f9b"><code>emplace</code>, better usage</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">recall S has an implicit constructor from Foo</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">but an explicit constructor from int</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">template &lt;class... Args&gt;</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">pair&lt;iterator,bool&gt; emplace(Args&amp;&amp;... args);</span>

m.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">0</span>, <span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">no moves, just a construct</span>
</pre>
</div>

<aside class="notes">
<p>
Again, the point of <code>emplace</code> is in-place construction.
</p>

<p>
It doesn't help you over <code>insert</code> if you just pass rvalues. <code>insert</code> works just
fine with rvalues.
</p>

</aside>

</section>
<section id="slide-orgbd4afe8">
<h3 id="orgbd4afe8"><code>emplace</code> problem</h3>
<p>
What do we do when we want to default-construct the value?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">0</span><span style="color: #2aa198;">)</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">default construct S please!</span>
</pre>
</div>

<p class="fragment (appear)">
<i>error 2665: <code>std::pair&lt;const _Kty,_Ty&gt;::pair</code>: none of the 2 overloads could
convert all the argument types</i>
</p>

<aside class="notes">
<p>
Here's a problem: how can we tell <code>emplace</code> to zero-arg construct the value when
we can't syntactically pass "zero arguments" in the place of an argument.
</p>

<p>
We don't want to default-construct an S explicitly here and move it in.
</p>

</aside>


</section>
<section id="slide-org90e55bf">
<h3 id="org90e55bf"><code>emplace</code> problem</h3>
<p>
What do we do when we want to default-construct the value?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m<span style="color: #2aa198;">[</span><span style="color: #859900;">0</span><span style="color: #2aa198;">]</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">default construct S please!</span>
</pre>
</div>

<p class="fragment (appear)">
_
</p>

<aside class="notes">
<p>
We could use <code>operator[]</code> but that would be weird.
</p>

<p>
I don't like expression statements and I would probably write <code>operator[]</code> with
nodiscard.
</p>

<p>
Remember the <code>value_type</code> of the <code>map</code> is a <code>pair</code> - that's what <code>emplace</code> is
trying to construct.
</p>

</aside>

</section>
<section id="slide-org41401b9">
<h3 id="org41401b9"><code>emplace</code> with zero-arg constructor</h3>
<p>
Our old friend <code>piecewise_construct</code> can help.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::piecewise_construct,
          <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">(</span><span style="color: #859900;">0</span><span style="color: #b58900;">)</span>,
          <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">default construct S please!</span>
</pre>
</div>

<p>
Tuples are allowed to be empty!
</p>

<p>
Yes, we can also use this for more-than-one-arg constructors.
</p>

<aside class="notes">
<p>
Here's the piecewise constructor on <code>pair</code> again.
</p>

</aside>

</section>
<section id="slide-org844c885">
<h3 id="org844c885">Exhibit G</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">explicit ClientIdRecord(</span>
<span style="color: #ff00ff;">//  </span><span style="color: #ff00ff;">const string&amp; clientId, const ProcessId&amp; clientProc, const ProcessId&amp; server</span><span style="color: #333333; background-color: #000000;">Proc);</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">Storage</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">unordered_set</span><span style="color: #2aa198;">&lt;</span>ClientIdRecord<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">Storage</span> <span style="color: #cb4b16;">m_storage</span>;
m_storage.emplace<span style="color: #2aa198;">(</span>inClientId, clientProc, serverProc<span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
Perfectly fine as far as <code>emplace</code> usage.
</p>

<p>
Then we want to change the <code>unordered_set</code> to an <code>unordered_map</code>.
</p>

<aside class="notes">
<p>
ClientIdRecord has a 3-argument constructor.
</p>

<p>
<code>inClientId</code> is a string.
</p>

<p>
One in-place construct. This is fine.
</p>

</aside>

</section>
<section id="slide-orgc4d6ad7">
<h3 id="orgc4d6ad7">Exhibit G</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">explicit ClientIdRecord(</span>
<span style="color: #ff00ff;">//  </span><span style="color: #ff00ff;">const string&amp; clientId, const ProcessId&amp; clientProc, const ProcessId&amp; server</span><span style="color: #333333; background-color: #000000;">Proc);</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">Storage</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">unordered_map</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string, ClientIdRecord<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">Storage</span> <span style="color: #cb4b16;">m_storage</span>;
m_storage.emplace<span style="color: #2aa198;">(</span>
  <span style="color: #859900;">std</span>::make_pair<span style="color: #b58900;">(</span>inClientId,
                 ClientIdRecord<span style="color: #94BFF3;">(</span>inClientId, clientProc, serverProc<span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
Is this optimal?
</p>

<aside class="notes">
<p>
2 extra moves here.
</p>

<p>
How do we do better?
</p>

</aside>

</section>
<section id="slide-org1da0b3c">
<h3 id="org1da0b3c">Exhibit G</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">Storage</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">unordered_map</span><span style="color: #2aa198;">&lt;</span><span style="color: #859900;">std</span>::string, ClientIdRecord<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">Storage</span> <span style="color: #cb4b16;">m_storage</span>;
m_storage.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::piecewise_construct,
                  <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">(</span>inClientId<span style="color: #b58900;">)</span>,
                  <span style="color: #859900;">std</span>::forward_as_tuple<span style="color: #b58900;">(</span>inClientId, clientProc, serverProc<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
Use <code>piecewise_construct</code> again.
</p>

</section>
<section id="slide-orgc92a61c">
<h3 id="orgc92a61c"><code>emplace</code> problem 2</h3>
<p>
What do you do if you want to <code>emplace</code> the result of a function call?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">get_S</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>; <span style="color: #2aa198;">}</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">0</span>, get_S<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
How can we avoid the move?
</p>

<p>
Is it possible to in-place construct here?
</p>

</section>
<section id="slide-org468d747">
<h3 id="org468d747">In-place construct a function call result</h3>
<p>
We can't avoid evaluating the function call before calling <code>emplace</code>.
</p>

<p>
But, we can control when the result of the function call becomes an <code>S</code>.
</p>

</section>
<section id="slide-org3b448c5">
<h3 id="org3b448c5">In-place construct a function call result</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">F</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">struct</span> <span style="color: #268bd2;">with_result_of_t</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">T</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">result_of_t</span><span style="color: #b58900;">&lt;</span>F<span style="color: #94BFF3;">()</span><span style="color: #b58900;">&gt;</span>;
  <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">with_result_of_t</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">F</span> <span style="color: #cb4b16;">f</span><span style="color: #b58900;">)</span> : f<span style="color: #b58900;">(</span><span style="color: #859900;">std</span>::move<span style="color: #94BFF3;">(</span>f<span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{}</span>
  <span style="color: #b58900; font-weight: bold;">operator</span> <span style="color: #268bd2;">T</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> f<span style="color: #94BFF3;">()</span>; <span style="color: #b58900;">}</span>

<span style="color: #b58900; font-weight: bold;">private</span>:
  <span style="color: #268bd2;">F</span> <span style="color: #cb4b16;">f</span>;
<span style="color: #2aa198;">}</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">prior to CTAD</span>
<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">F</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">inline</span> <span style="color: #b58900; font-weight: bold;">auto</span> <span style="color: #2aa198;">with_result_of</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">F</span>&amp;&amp; <span style="color: #cb4b16;">f</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900; font-weight: bold;">return</span> with_result_of_t<span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">F</span><span style="color: #b58900;">&gt;(</span><span style="color: #859900;">std</span>::forward<span style="color: #94BFF3;">&lt;</span><span style="color: #268bd2;">F</span><span style="color: #94BFF3;">&gt;(</span>f<span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Capture the function and call it only at the point that we want to convert the
result to an <code>S</code>.
</p>

<p>
<code>invoke_result_t</code> is C++17 - before that you can use <code>result_of_t</code>.
</p>

</aside>

</section>
<section id="slide-org8b9600f">
<h3 id="org8b9600f"><code>emplace</code> problem 2</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">S</span> <span style="color: #2aa198;">get_S</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #b58900;">{</span><span style="color: #859900;">1</span><span style="color: #b58900;">}</span>; <span style="color: #2aa198;">}</span>

<span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, <span style="color: #268bd2;">S</span><span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">0</span>, with_result_of<span style="color: #b58900;">(</span><span style="color: #94BFF3;">[]</span> <span style="color: #94BFF3;">{</span> <span style="color: #b58900; font-weight: bold;">return</span> get_S<span style="color: #dc322f;">()</span>; <span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">m.emplace(0, with_result_of(get_S));</span>
</pre>
</div>

<p>
Compilers are really good at optimizing single-use lambdas.
</p>

<aside class="notes">
<p>
You would think the second line here would work just as well. But VC++
doesn't manage to elide the move.
</p>

</aside>

</section>
<section id="slide-org751d071">
<h3 id="org751d071">C++17: <code>insert_or_assign</code></h3>
<p>
Of course, <code>insert</code> / <code>emplace</code> and <code>operator[]</code> actually do different things.
</p>

<p>
What do you do if you want to insert, or assign if the element is already there?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span> <span style="color: #268bd2;">M</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">pair</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">iterator</span>, <span style="color: #268bd2;">bool</span><span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">insert_or_assign</span><span style="color: #2aa198;">(</span><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">key_type</span>&amp; <span style="color: #cb4b16;">k</span>, <span style="color: #268bd2;">M</span>&amp;&amp; <span style="color: #cb4b16;">obj</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span> <span style="color: #268bd2;">M</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">pair</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">iterator</span>, <span style="color: #268bd2;">bool</span><span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">insert_or_assign</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">key_type</span>&amp;&amp; <span style="color: #cb4b16;">k</span>, <span style="color: #268bd2;">M</span>&amp;&amp; <span style="color: #cb4b16;">obj</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<p>
Introduced with C++17.
</p>

<aside class="notes">
<p>
<code>insert_or_assign</code> doesn't need default construction (unlike <code>operator[]</code>).
</p>

<p>
<code>insert_or_assign</code> was introduced with C++17. Can be written as a free function,
but difficult/impossible to make as efficient as map can as a member function.
</p>

</aside>

</section>
<section id="slide-orgeb55a03">
<h3 id="orgeb55a03">C++17: <code>insert_or_assign</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;
m.insert_or_assign<span style="color: #2aa198;">(</span><span style="color: #859900;">0</span>, Foo<span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">implicit construction - fine</span>

<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">m.insert_or_assign(1, 1);  // explicit construction - error!</span>
m.insert_or_assign<span style="color: #2aa198;">(</span><span style="color: #859900;">1</span>, with_result_of<span style="color: #b58900;">(</span><span style="color: #94BFF3;">[]{</span> <span style="color: #b58900; font-weight: bold;">return</span> S<span style="color: #dc322f;">{</span><span style="color: #859900;">1</span><span style="color: #dc322f;">}</span>; <span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">RVO</span>
</pre>
</div>

<aside class="notes">
<p>
Unfortunately there is no <code>emplace_or_assign</code>. (In the assign case presumably
could not avoid making a temporary to assign). But you can use the same
<code>with_result_of</code> technique with <code>insert_or_assign</code>.
</p>

</aside>

</section>
<section id="slide-orgbd64b59">
<h3 id="orgbd64b59">In case you're not keeping count&#x2026;</h3>
<p>
We now have at least 3 different interface styles for putting things in a
<code>map</code>&#x2026;
</p>

<ul>
<li><code>insert</code> takes a <code>value_type</code> (aka <code>pair</code>)</li>
<li><code>emplace</code> takes a parameter pack</li>
<li><code>insert_or_assign</code> takes a key and a value</li>

</ul>

<aside class="notes">
<p>
This is unfortunate.
</p>

</aside>

</section>
<section id="slide-org7e6bd42">
<h3 id="org7e6bd42">And potentially a 4th!</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">using</span> <span style="color: #268bd2;">M</span> = <span style="color: #859900;">std</span>::<span style="color: #268bd2;">map</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span>;
<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m</span>;

<span style="color: #268bd2;">M</span> <span style="color: #cb4b16;">m2</span><span style="color: #2aa198;">{</span><span style="color: #b58900;">{</span><span style="color: #859900;">1</span>, Foo<span style="color: #94BFF3;">{}</span><span style="color: #b58900;">}</span><span style="color: #2aa198;">}</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">pretend initialization becomes efficient &amp; simple</span>

m.insert<span style="color: #2aa198;">(</span>m2.extract<span style="color: #b58900;">(</span><span style="color: #859900;">1</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Yet another way! If at some future time, initialization becomes simpler than the
various ways to insert, this "idiom" could catch on&#x2026;
</p>

</aside>

</section>
<section id="slide-org99f1b7a">
<h3 id="org99f1b7a">Exhibit H</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">K</span>, <span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #268bd2;">V</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">typename</span> <span style="color: #859900;">LRUCache</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">K</span>, <span style="color: #268bd2;">V</span><span style="color: #2aa198;">&gt;</span>::<span style="color: #268bd2;">EntryPtr</span> <span style="color: #859900;">LRUCache</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">K</span>, <span style="color: #268bd2;">V</span><span style="color: #2aa198;">&gt;</span>::<span style="color: #2aa198;">Insert</span><span style="color: #2aa198;">(</span><span style="color: #b58900; font-weight: bold;">const</span> <span style="color: #268bd2;">K</span>&amp; <span style="color: #cb4b16;">key</span>, <span style="color: #268bd2;">V</span> <span style="color: #cb4b16;">value</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">Is the key already present?</span>
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>m_entries.find<span style="color: #94BFF3;">(</span>key<span style="color: #94BFF3;">)</span> != m_entries.end<span style="color: #94BFF3;">()</span><span style="color: #b58900;">)</span> <span style="color: #b58900; font-weight: bold;">return</span> <span style="color: #859900;">nullptr</span>;

  <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">Is the cache full?</span>
  <span style="color: #b58900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>m_entries.size<span style="color: #94BFF3;">()</span> == m_capacity<span style="color: #b58900;">)</span> Evict<span style="color: #b58900;">(</span><span style="color: #859900;">1</span><span style="color: #b58900;">)</span>;

  <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">Insert the new value.</span>
  <span style="color: #268bd2;">EntryPtr</span> <span style="color: #cb4b16;">e</span> = <span style="color: #859900;">std</span>::make_shared<span style="color: #b58900;">&lt;</span>Entry<span style="color: #b58900;">&gt;(</span>key, <span style="color: #859900;">std</span>::move<span style="color: #94BFF3;">(</span>value<span style="color: #94BFF3;">)</span><span style="color: #b58900;">)</span>;
  Append<span style="color: #b58900;">(</span>e.get<span style="color: #94BFF3;">()</span><span style="color: #b58900;">)</span>;
  m_entries<span style="color: #b58900;">[</span>key<span style="color: #b58900;">]</span> = e;

  <span style="color: #b58900; font-weight: bold;">return</span> e;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Given everything we've learned, let's critique this code.
</p>

<p>
We can see that it's inserting a KV pair into a cache with a least-recently-used
eviction strategy. There is a map that owns a shared_ptr, and that shared_ptr is
also weakly-referenced from a deque (see Append call)?
</p>

<ul>
<li>use pass-by-value to simplify handling</li>
<li>use <code>make_shared</code></li>

<li>use <code>operator[]</code> - default construct shared_ptr + assign</li>
<li>extra shared_ptr ref</li>

</ul>

</aside>

</section>
<section id="slide-orgfba7edd">
<h3 id="orgfba7edd">Exhibit H</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">Insert the new value.</span>
<span style="color: #b58900; font-weight: bold;">auto</span> <span style="color: #2aa198;">[</span>it, _<span style="color: #2aa198;">]</span> =
  m_entries.emplace<span style="color: #2aa198;">(</span>key, with_result_of<span style="color: #b58900;">(</span><span style="color: #94BFF3;">[</span>&amp;<span style="color: #94BFF3;">]</span> <span style="color: #94BFF3;">{</span>
    <span style="color: #b58900; font-weight: bold;">return</span> <span style="color: #859900;">std</span>::make_shared<span style="color: #dc322f;">&lt;</span>Entry<span style="color: #dc322f;">&gt;(</span>key, <span style="color: #859900;">std</span>::move<span style="color: #859900;">(</span>value<span style="color: #859900;">)</span><span style="color: #dc322f;">)</span>; <span style="color: #94BFF3;">}</span><span style="color: #b58900;">)</span>;
Append<span style="color: #b58900;">(</span>it-&gt;second.get<span style="color: #94BFF3;">()</span><span style="color: #b58900;">)</span>;
<span style="color: #b58900; font-weight: bold;">return</span> it-&gt;second;
</pre>
</div>

<aside class="notes">
<ul>
<li>m_entries can still be any associative container (no loss of generality)</li>
<li>save 2 shared_ptr reference updates (plus check on assign of the default-constructed one)</li>

</ul>

<p>
We use with_result_of here to construct the shared_ptr directly in place.
</p>

</aside>

</section>
<section id="slide-org6eddab3">
<h3 id="org6eddab3">Recommendations</h3>
<p>
Yes, C++ is complicated.
</p>

<ul>
<li>Initialization: consider <code>for_each_n_args</code></li>
<li>You can use <code>insert</code> with <code>make_pair</code> and implicit construction
<ul>
<li>But don't use call-site explicit construction</li>

</ul></li>
<li>Use <code>emplace</code> but beware of explicit construction</li>
<li>Use <code>piecewise_construct</code> for other than single-arg construction</li>
<li>Try to avoid <code>operator[]</code></li>
<li>Adopt <code>insert_or_assign</code> when it's available</li>
<li>Consider <code>with_result_of</code></li>

</ul>

</section>
</section>
<section>
<section id="slide-org96c6bbf">
<h2 id="org96c6bbf">6. Putting stuff into other things</h2>
<p>
Like <code>optional</code>, <code>variant</code>, <code>any</code>.
</p>

<div class='vertspace2'></div>
<blockquote nil><p>&quot;There's more depends on this than on the value.&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>The Merchant of Venice</em></div></blockquote>

</section>
<section id="slide-org941c6f2">
<h3 id="org941c6f2"><code>optional</code> and friends</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">constexpr</span> <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">optional</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">in_place_t</span>, <span style="color: #268bd2;">Args</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span> <span style="color: #268bd2;">T</span>, <span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">constexpr</span> <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">variant</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">in_place_type_t</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">T</span><span style="color: #b58900;">&gt;</span>, <span style="color: #268bd2;">Args</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">size_t</span> <span style="color: #cb4b16;">I</span>, <span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">constexpr</span> <span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">variant</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">in_place_index_t</span><span style="color: #b58900;">&lt;</span>I<span style="color: #b58900;">&gt;</span>, <span style="color: #268bd2;">Args</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900; font-weight: bold;">template</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900; font-weight: bold;">class</span> <span style="color: #268bd2;">ValueType</span>, <span style="color: #b58900; font-weight: bold;">class</span><span style="color: #2aa198;">...</span> <span style="color: #268bd2;">Args</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900; font-weight: bold;">explicit</span> <span style="color: #2aa198;">any</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">in_place_type_t</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">ValueType</span><span style="color: #b58900;">&gt;</span>, <span style="color: #268bd2;">Args</span>&amp;&amp;<span style="color: #2aa198;">...</span> <span style="color: #cb4b16;">args</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
All these new vocabulary types have constructors that take <code>in_place</code> tag
arguments. They work similarly to <code>piecewise_construct</code> but they're only
constructing one thing.
</p>

</aside>

</section>
<section id="slide-org1074a48">
<h3 id="org1074a48"><code>optional</code> construction</h3>
<p>
implicit constructor
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span> = Foo<span style="color: #2aa198;">{}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (naive method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span> = S<span style="color: #2aa198;">{</span><span style="color: #859900;">1</span><span style="color: #2aa198;">}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (in-place method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span><span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::in_place, <span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
In the first case, it's fine: just one in-place construct.
</p>

<p>
In the second case, we have an <code>explicit</code> constructor. So if we use this style,
we get a construct and a move.
</p>

<p>
The third case is the way to go for in-place construction. It can also be used
with an implicit constructor of course.
</p>

</aside>

</section>
<section id="slide-orgcb2da4a">
<h3 id="orgcb2da4a"><code>optional</code> assignment</h3>
<p>
implicit constructor
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span>;
opt = Foo<span style="color: #2aa198;">{}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (naive method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span>;
opt = S<span style="color: #2aa198;">{</span><span style="color: #859900;">1</span><span style="color: #2aa198;">}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (in-place method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span>;
opt.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Similar story here.
</p>

</aside>

</section>
<section id="slide-org301dd51">
<h3 id="org301dd51"><code>optional</code> recommendations</h3>
<ul>
<li>use the <code>in_place_t</code> constructor</li>
<li>avoid <code>explicit</code> construction</li>
<li>use <code>emplace</code> for assignment</li>

</ul>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">optional</span><span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">opt</span><span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::in_place, <span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
opt.emplace<span style="color: #2aa198;">(</span><span style="color: #859900;">2</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
You'll never go wrong with these.
</p>

<p>
Again we could use the with_result_of to in-place construct the result of a
function call.
</p>

</aside>

</section>
<section id="slide-org915c7af">
<h3 id="org915c7af"><code>variant</code> construction</h3>
<p>
implicit constructor
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = Foo<span style="color: #2aa198;">{}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (naive method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = S<span style="color: #2aa198;">{</span><span style="color: #859900;">1</span><span style="color: #2aa198;">}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (oops method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span> = <span style="color: #859900;">1</span>;
</pre>
</div>

<aside class="notes">
<p>
Similar story as <code>optional</code>.
</p>

<p>
But there is the potential for a bug with the <code>explicit</code> constructor. What makes
this somewhat likely is that it might be the case that someone makes a
constructor explicit later on.
</p>

</aside>

</section>
<section id="slide-orgedbf5d1">
<h3 id="orgedbf5d1"><code>variant</code> construction</h3>
<p>
Recommendation: use either of these two constructions.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">v</span><span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">in_place_type</span><span style="color: #b58900;">&lt;</span>S<span style="color: #b58900;">&gt;</span>, <span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">v</span><span style="color: #2aa198;">(</span><span style="color: #859900;">std</span>::<span style="color: #268bd2;">in_place_index</span><span style="color: #b58900;">&lt;</span><span style="color: #859900;">1</span><span style="color: #b58900;">&gt;</span>, <span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
I would generally prefer the first except in cases where the same type occurs in
multiple places in the <code>variant</code>, which is relatively rarer.
</p>

</aside>

</section>
<section id="slide-orga6c0d7a">
<h3 id="orga6c0d7a"><code>variant</code> assignment</h3>
<p>
Similar story to construction.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;

v = Foo<span style="color: #2aa198;">{}</span>; <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">fine</span>
v = S<span style="color: #2aa198;">{</span><span style="color: #859900;">1</span><span style="color: #2aa198;">}</span>;  <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">constructs a temporary</span>
v = <span style="color: #859900;">1</span>;     <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">oops</span>
</pre>
</div>

</section>
<section id="slide-orgc289168">
<h3 id="orgc289168"><code>variant</code> danger!</h3>
<p>
Implicitly-typed <code>variant</code> construction/assignment can be dangerous.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #268bd2;">int</span> <span style="color: #2aa198;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #b58900;">&lt;</span><span style="color: #268bd2;">bool</span>, <span style="color: #859900;">std</span>::string<span style="color: #b58900;">&gt;</span> <span style="color: #cb4b16;">v</span> = <span style="color: #D01A4E;">"Hello"</span>;
  <span style="color: #859900;">std</span>::cout &lt;&lt; <span style="color: #D01A4E;">"index is "</span> &lt;&lt; v.index<span style="color: #b58900;">()</span> &lt;&lt; <span style="color: #D01A4E;">'</span><span style="color: #5f127b; font-weight: bold;">\</span><span style="color: #b58900; font-weight: bold;">n</span><span style="color: #D01A4E;">'</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
What does this output?
</p>

<aside class="notes">
<p>
Avoid implicit type conversions. They're dangerous. The first possible one will apply.
</p>

</aside>

</section>
<section id="slide-org967b8e0">
<h3 id="org967b8e0">Safe, efficient <code>variant</code> assignment</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">template &lt;class T, class... Args&gt;</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">T&amp; emplace(Args&amp;&amp;... args);</span>
v.emplace<span style="color: #2aa198;">&lt;</span>S<span style="color: #2aa198;">&gt;(</span><span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;  <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">S{1}</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #859900;">std</span>::<span style="color: #268bd2;">variant</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2;">int</span>, S<span style="color: #2aa198;">&gt;</span> <span style="color: #cb4b16;">v</span>;
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">template &lt;size_t I, class... Args&gt;</span>
<span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">variant_alternative_t&lt;I, variant&gt;&amp; emplace(Args&amp;&amp;... args);</span>
v.emplace<span style="color: #2aa198;">&lt;</span><span style="color: #859900;">1</span><span style="color: #2aa198;">&gt;(</span><span style="color: #859900;">1</span><span style="color: #2aa198;">)</span>;  <span style="color: #ff00ff;">// </span><span style="color: #ff00ff;">S{1}</span>
</pre>
</div>

</section>
<section id="slide-orgf6d9412">
<h3 id="orgf6d9412"><code>variant</code> recommendations</h3>
<ul>
<li>always be explicit about types</li>
<li>use <code>in_place_type</code> or <code>in_place_index</code> constructors</li>
<li>use <code>emplace&lt;T&gt;</code> or <code>emplace&lt;I&gt;</code></li>
<li>avoid <code>operator=</code> (except actual <code>variant</code>-to-<code>variant</code>)</li>

</ul>

<aside class="notes">
<p>
Obviously <code>operator=</code> is used implicitly by the compiler.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orge67d3ea">
<h2 id="orge67d3ea">7. Final Guidelines and Recommendations</h2>
<div class='vertspace2'></div>
<blockquote nil><p>&quot;Share the advice betwixt you; if both gain all,<br>The gift doth stretch itself as 'tis receiv'd,<br>And is enough for both.&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>All's Well That Ends Well</em></div></blockquote>

</section>
<section id="slide-org7bcda77">
<h3 id="org7bcda77">Recommendations</h3>
<p>
Think about copies and moves.
</p>

<p>
Moves aren't free, and may not be cheap.
</p>

<p>
Usually, in-place construction is preferable. And it is nearly always possible.
</p>

<p>
Know how RVO works, and check that the compiler is doing it when you think it is.
</p>

<p>
Beware <code>initializer_list</code>.
</p>

<p>
Feel free to ping me with any questions, any time.
</p>
</section>
</section>
</div>
</div>
<script src="../reveal.js/lib/js/head.min.js"></script>
<script src="../reveal.js/js/reveal.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,

overview: true,
width: 1600,
height: 900,
margin: 0.10,
minScale: 0.50,
maxScale: 2.50,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'none', // see README of reveal.js for options
transitionSpeed: 'default',

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]

});
</script>
</body>
</html>
