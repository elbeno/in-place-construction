<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Everyday Efficiency: In-place Construction</title>
<meta name="author" content="(Ben Deane)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="../reveal.js/css/theme/blood.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h2>Everyday Efficiency: In-place Construction</h2><div class='vertspace2'></div><blockquote nil><p>&quot;Make no collection of it: let him show<br>His skill is in the construction.&quot;</p><div></div><div class='author'>-- William Shakespeare, <em>Cymbeline</em></div></blockquote><div class='vertspace3'></div><h3>Ben Deane / <a href="http://twitter.com/ben_deane">@ben_deane</a></h3><h4>November 2018</h4>
</section>
<script type="text/javascript" src="./rison.js"></script>
<script type="text/javascript" src="./presentation.js"></script>

<section>
<section id="slide-org37c2963">
<h2 id="org37c2963">Get Ready</h2>
<ol>
<li>What happens when we <code>move</code> something?</li>
<li>Copy elision (RVO)</li>
<li>Putting stuff into a <code>vector</code></li>
<li><code>initializer_list</code></li>
<li>Putting stuff into a <code>map</code></li>
<li>Putting stuff into other things</li>
<li>Final thoughts</li>

</ol>

<aside class="notes">
<p>
There will be a lot of code snippets in this talk.
</p>

<p>
I will be asking a lot of questions.
</p>

<p>
I'm assuming everyone is using C++14, although most things we talk about will
require no more than C++11. I'll mention a couple of C++17 features.
</p>

<p>
Most of what you see is common to either <code>blz</code> or toolchain-STL. I've omitted
namespaces from the slides for brevity.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org6e0acc5">
<h2 id="org6e0acc5">Disclaimer</h2>
<p>
I'm going to critique some code in this talk.
</p>

<p>
If it's your code, please don't feel slighted.
</p>

<p>
I assure you that I write and have written plenty of suboptimal code.
</p>

<p>
Let's make code better together!
</p>

</section>
</section>
<section>
<section id="slide-org35b607f">
<h2 id="org35b607f">Preliminaries</h2>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #8b2252;">stdio.h</span><span style="color: #707183;">&gt;</span>

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Foo</span> <span style="color: #707183;">{}</span>;

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">S</span>
<span style="color: #707183;">{</span>
  <span style="color: #0000ff;">S</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{</span> puts<span style="color: #909183;">(</span><span style="color: #8b2252;">"Default construct</span><span style="color: #8b2252; font-weight: bold;">\</span><span style="color: #8b2252; font-weight: bold;">n</span><span style="color: #8b2252;">"</span><span style="color: #909183;">)</span>; <span style="color: #7388d6;">}</span>
  <span style="color: #0000ff;">S</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">Foo</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span> puts<span style="color: #909183;">(</span><span style="color: #8b2252;">"Value construct</span><span style="color: #8b2252; font-weight: bold;">\</span><span style="color: #8b2252; font-weight: bold;">n</span><span style="color: #8b2252;">"</span><span style="color: #909183;">)</span>; <span style="color: #7388d6;">}</span>
  <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">S</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span> puts<span style="color: #909183;">(</span><span style="color: #8b2252;">"Explicit value construct (1)</span><span style="color: #8b2252; font-weight: bold;">\</span><span style="color: #8b2252; font-weight: bold;">n</span><span style="color: #8b2252;">"</span><span style="color: #909183;">)</span>; <span style="color: #7388d6;">}</span>
  <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">S</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span>, <span style="color: #228b22;">int</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span> puts<span style="color: #909183;">(</span><span style="color: #8b2252;">"Explicit value construct (2)</span><span style="color: #8b2252; font-weight: bold;">\</span><span style="color: #8b2252; font-weight: bold;">n</span><span style="color: #8b2252;">"</span><span style="color: #909183;">)</span>;<span style="color: #7388d6;">}</span>
  ~<span style="color: #0000ff;">S</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{</span> puts<span style="color: #909183;">(</span><span style="color: #8b2252;">"Destruct</span><span style="color: #8b2252; font-weight: bold;">\</span><span style="color: #8b2252; font-weight: bold;">n</span><span style="color: #8b2252;">"</span><span style="color: #909183;">)</span>; <span style="color: #7388d6;">}</span>
  <span style="color: #0000ff;">S</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">S</span>&amp;<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span> puts<span style="color: #909183;">(</span><span style="color: #8b2252;">"Copy construct</span><span style="color: #8b2252; font-weight: bold;">\</span><span style="color: #8b2252; font-weight: bold;">n</span><span style="color: #8b2252;">"</span><span style="color: #909183;">)</span>; <span style="color: #7388d6;">}</span>
  <span style="color: #0000ff;">S</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">S</span>&amp;&amp;<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span> puts<span style="color: #909183;">(</span><span style="color: #8b2252;">"Move construct</span><span style="color: #8b2252; font-weight: bold;">\</span><span style="color: #8b2252; font-weight: bold;">n</span><span style="color: #8b2252;">"</span><span style="color: #909183;">)</span>; <span style="color: #7388d6;">}</span>
  <span style="color: #228b22;">S</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">=</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">S</span>&amp;<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span> puts<span style="color: #909183;">(</span><span style="color: #8b2252;">"Copy assign</span><span style="color: #8b2252; font-weight: bold;">\</span><span style="color: #8b2252; font-weight: bold;">n</span><span style="color: #8b2252;">"</span><span style="color: #909183;">)</span>; <span style="color: #a020f0;">return</span> *<span style="color: #a020f0;">this</span>; <span style="color: #7388d6;">}</span>
  <span style="color: #228b22;">S</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">=</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">S</span>&amp;&amp;<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span> puts<span style="color: #909183;">(</span><span style="color: #8b2252;">"Move assign</span><span style="color: #8b2252; font-weight: bold;">\</span><span style="color: #8b2252; font-weight: bold;">n</span><span style="color: #8b2252;">"</span><span style="color: #909183;">)</span>; <span style="color: #a020f0;">return</span> *<span style="color: #a020f0;">this</span>; <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>;

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
    <span style="color: #228b22;">S</span> <span style="color: #a0522d;">s</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
You're going to see a lot of this later in the talk, when we examine how various
snippets of code behave.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgcecaac9">
<h2 id="orgcecaac9">1. What happens when we <code>move</code> something?</h2>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v1</span> = <span style="color: #707183;">{</span><span style="color: #008b8b;">1</span>, <span style="color: #008b8b;">2</span>, <span style="color: #008b8b;">3</span>, <span style="color: #008b8b;">4</span>, <span style="color: #008b8b;">5</span><span style="color: #707183;">}</span>;
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v2</span> = <span style="color: #008b8b;">std</span>::move<span style="color: #707183;">(</span>v1<span style="color: #707183;">)</span>;
</pre>
</div>

<p>
What's in <code>v1</code> after the move?
</p>

<aside class="notes">
<p>
The standard says "valid but unspecified". We know that we're allowed to destroy
it, because for things to be otherwise would be a nonsense. <code>v1</code> <span class="underline">will</span> be
destroyed like any other C++ object when it goes out of scope.
</p>

<p>
Here's where we deviate from the standard. How is <code>vector</code> implemented,
basically? (pointer-to-buffer, size, capacity). On destruction, what must it do?
</p>

</aside>

</section>
<section id="slide-orgc9aae21">
<h3 id="orgc9aae21">A moved-from <code>vector</code></h3>
<p>
It must be destroyable.
</p>

<p>
What is sufficient? What is likely?
</p>
<ul>
<li>begin pointer is null?</li>
<li>size is zero?</li>
<li>capacity is zero?</li>

</ul>

</section>
<section id="slide-org7d0d1e7">
<h3 id="org7d0d1e7">Exhibit A</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #008b8b;">WebSocketHandshakerImpl</span>::<span style="color: #0000ff;">ProcessServerHandshake</span><span style="color: #707183;">(</span><span style="color: #228b22;">HttpMessage</span> <span style="color: #a0522d;">message</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #006400;">// </span><span style="color: #006400;">some stuff...</span>

  m_result.extra = <span style="color: #008b8b;">std</span>::move<span style="color: #7388d6;">(</span>m_readBuffer<span style="color: #7388d6;">)</span>;
  m_result.headers = <span style="color: #008b8b;">std</span>::move<span style="color: #7388d6;">(</span>message.headers<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
This code assumes that it's safe to do whatever comes later to a moved-from <code>vector</code>.
</p>

</section>
<section id="slide-org2746a53">
<h3 id="org2746a53">Now consider:</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">s1</span> = <span style="color: #8b2252;">"Greetings, planet"</span>;
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">s2</span> = <span style="color: #008b8b;">std</span>::move<span style="color: #707183;">(</span>s1<span style="color: #707183;">)</span>;
</pre>
</div>

<p>
What's the moved-from state of <code>s1</code>?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">s3</span> = <span style="color: #8b2252;">"Hello, world"</span>;
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">s4</span> = <span style="color: #008b8b;">std</span>::move<span style="color: #707183;">(</span>s3<span style="color: #707183;">)</span>;
</pre>
</div>

<p>
What's the moved-from state of <code>s3</code>?
</p>

<aside class="notes">
<p>
What is the state of s1 in the second case? Same as the vector case basically.
</p>

<p>
But the first example is small-string optimized. What happens when you move from
a small string? You have to copy.
</p>

<p>
What is the state of s1 in the first case? It happens that all major
implementations (blz included) will set the size to zero on a move, even when in
the small string buffer. So it's actually ever so slightly <i>slower</i> than a copy.
</p>

<p>
If you're lucky, the optimizer can help you out and spot dead stores&#x2026;
</p>

<p>
Bloomberg's STL does not clear a moved-from SSO string.
</p>

</aside>

</section>
<section id="slide-org8839973">
<h3 id="org8839973">Observation</h3>
<p>
Moving from a <code>string</code> usually <i>isn't any faster</i> than copying from it.
</p>

<p>
(If you doubt this, ask yourself why the small string optimization exists in the
first place.)
</p>

<p>
Moves <i>only</i> matter for objects on the heap.
</p>

<p>
<a href="http://quick-bench.com/7zo0OLXgCyR3v_KwZKNIe5Z5Z64">http://quick-bench.com/7zo0OLXgCyR3v_KwZKNIe5Z5Z64</a>
</p>

<aside class="notes">
<p>
And as noted, it may be technically slower.
</p>

</aside>

</section>
<section id="slide-org6eacc6d">
<h3 id="org6eacc6d">Exhibit B</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #008b8b;">Context</span>::<span style="color: #0000ff;">Trigger</span><span style="color: #707183;">(</span><span style="color: #006400;">/* </span><span style="color: #006400;">some args */</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #006400;">// </span><span style="color: #006400;">Make sure that it will trigger only once.</span>
  <span style="color: #a020f0;">const</span> <span style="color: #228b22;">OnResponseCallback</span> <span style="color: #a0522d;">cb</span> = <span style="color: #008b8b;">std</span>::move<span style="color: #7388d6;">(</span>m_responseCallback<span style="color: #7388d6;">)</span>;

  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>cb<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">{</span>
    cb<span style="color: #909183;">(</span>errorCode, errorReason, payload, size, opaque<span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
Is this comment telling the truth?
</p>

<aside class="notes">
<p>
Playing with fire. The comment is misleading. We're relying on implementation.
</p>

<p>
Function has a small buffer optimization just like string. There's no reason for
function to be null after a move.
</p>

<p>
Think back to the vector case now: what happens if the container is replaced
with a small-buffer optimizable container?
</p>

</aside>

</section>
<section id="slide-org19bb428">
<h3 id="org19bb428">Guideline (specific)</h3>
<p>
Don't assume things are empty after a <code>move</code>.
</p>

<p>
Use <code>exchange</code> to make sure. Assigning an empty object is a trivial price for
safety.
</p>

<div class="org-src-container">

<pre  class="src src-c++">m_result.extra = <span style="color: #008b8b;">std</span>::exchange<span style="color: #707183;">(</span>m_readBuffer, <span style="color: #7388d6;">{}</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">const</span> <span style="color: #228b22;">OnResponseCallback</span> <span style="color: #a0522d;">cb</span> = <span style="color: #008b8b;">std</span>::exchange<span style="color: #707183;">(</span>m_responseCallback, <span style="color: #008b8b;">nullptr</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Make your code safe for future small-buffer optimizations.
</p>

</section>
<section id="slide-org53effa8">
<h3 id="org53effa8">Guideline (more general)</h3>
<p>
If you didn't write the move constructor/operator yourself, after a <code>move</code>, you
may assume:
</p>

<ul>
<li>the object is destroyable</li>
<li>the object is (re-)assignable</li>

</ul>

<p>
<i>NOTHING ELSE</i>
</p>

<p>
Note: This is a stronger constraint than what the standard says.
</p>

<aside class="notes">
<p>
[defns.valid] "the object's invariants are met and operations on the object
behave as specified for its type"
</p>

<p>
The standard says you can call any function without preconditions.
</p>

<p>
But I'm not saying anything that, I'm just saying something <i>more</i> constrained,
and safer.
</p>

</aside>

</section>
<section id="slide-orgf400d23">
<h3 id="orgf400d23">Let's look at this again</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #008b8b;">WebSocketHandshakerImpl</span>::<span style="color: #0000ff;">ProcessServerHandshake</span><span style="color: #707183;">(</span><span style="color: #228b22;">HttpMessage</span> <span style="color: #a0522d;">message</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #006400;">// </span><span style="color: #006400;">some stuff...</span>

  <span style="color: #006400;">// </span><span style="color: #006400;">which would be right here? this?</span>
  m_result.headers = <span style="color: #008b8b;">std</span>::move<span style="color: #7388d6;">(</span>message.headers<span style="color: #7388d6;">)</span>;

  <span style="color: #006400;">// </span><span style="color: #006400;">or this?</span>
  m_result.headers = <span style="color: #008b8b;">std</span>::move<span style="color: #7388d6;">(</span>message<span style="color: #7388d6;">)</span>.headers;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
The first option is saying a much stronger thing. The result of <code>move</code> is always
an rvalue reference. That's literally all <code>move</code> does: a cast to an rvalue
reference.
</p>

<p>
The second one is using C++ member access rules to infer the rvalue-ness of the
member. That's fine. We still get the rvalue.
</p>

<p>
The first one is saying "this is definitely an rvalue - trust me!".
</p>

<p>
The second is saying "hey, this is an rvalue, unless something else prevents it".
</p>

<p>
So what would "prevent it"?
</p>

</aside>

</section>
<section id="slide-org87940a0">
<h3 id="org87940a0">There may be trouble ahead</h3>
<p>
Let's say we want always want pretty much the same headers for all requests.
</p>

<p>
What if we decided to change this&#x2026;
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">HttpMessage</span>
<span style="color: #707183;">{</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">requestLine</span>;
  <span style="color: #228b22;">Headers</span> <span style="color: #a0522d;">headers</span>;
<span style="color: #707183;">}</span>;
</pre>
</div>
<p>
&#x2026;to this?
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">HttpMessage</span>
<span style="color: #707183;">{</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">requestLine</span>;
  <span style="color: #228b22;">Headers</span>&amp; <span style="color: #a0522d;">headers</span>;
<span style="color: #707183;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
What happens when we change <code>Header</code> to a reference?
</p>

<p>
The HttpMessage itself can be an rvalue, but what it's referencing isn't.
</p>

</aside>

</section>
<section id="slide-org83ea9a5">
<h3 id="org83ea9a5">Guideline</h3>
<p>
Use <code>std::move(obj).member</code> rather than <code>std::move(obj.member)</code>
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">always safe, non-reference member is still an rvalue</span>
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">x</span> = <span style="color: #008b8b;">std</span>::move<span style="color: #707183;">(</span>obj<span style="color: #707183;">)</span>.member;

<span style="color: #006400;">// </span><span style="color: #006400;">could erroneously move from an lvalue-ref!</span>
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">x</span> = <span style="color: #008b8b;">std</span>::move<span style="color: #707183;">(</span>obj.member<span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
If we cast obj to an rvalue-ref, its member will also (usually) be an rvalue
ref, no problem. We aren't losing anything and we're gaining safety.
</p>

</aside>

</section>
<section id="slide-org02e905a">
<h3 id="org02e905a"><code>move</code> safety guidelines</h3>
<ul>
<li>after <code>std::move</code>, destroy or assign <i>only</i></li>
<li>use <code>std::exchange</code> to move-and-clear</li>
<li>use <code>std::move(obj).member</code>, not <code>std::move(obj.member)</code></li>

</ul>

<aside class="notes">
<p>
The last two points here are useful a lot of the time for writing move
constructors. You're going to be working in terms of the subobjects.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org9ee9622">
<h2 id="org9ee9622">2. Copy Elision (RVO)</h2>
<p>
What is the return value optimization?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">string</span> <span style="color: #0000ff;">bar</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">string</span> <span style="color: #a0522d;">a</span><span style="color: #7388d6;">{</span><span style="color: #8b2252;">"Hi"</span><span style="color: #7388d6;">}</span>;
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">b</span> = <span style="color: #008b8b;">42</span>;
  <span style="color: #006400;">// </span><span style="color: #006400;">...</span>
  <span style="color: #a020f0;">return</span> a;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">foo</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">string</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">{</span>bar<span style="color: #909183;">()</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
The caller sets aside space in its own stack frame for the result of the
function, and the callee constructs the result directly in that space.
</p>

<p>
bar() has two local variables.
</p>

<p>
when foo() calls bar() it "passes" the address of the stack variable s.
</p>

</aside>

</section>
<section id="slide-org74c6152">
<h3 id="org74c6152">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orgb9a5029">
<h3 id="orgb9a5029">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orgd917d8a">
<h3 id="orgd917d8a">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo3.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org5b2a8b2">
<h3 id="org5b2a8b2">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo4.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orgfaf61d5">
<h3 id="orgfaf61d5">RVO in pictures: No RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./no-rvo5.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org60bdfb5">
<h3 id="org60bdfb5">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orge5f9876">
<h3 id="orge5f9876">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orgdb890e3">
<h3 id="orgdb890e3">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo3.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orge467365">
<h3 id="orge467365">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo4.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-org314a4d9">
<h3 id="org314a4d9">RVO in pictures: RVO</h3>
<div class='vertspace2'></div>

<div class="figure">
<p><object type="image/svg+xml" data="./rvo5.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

</section>
<section id="slide-orgeaef19c">
<h3 id="orgeaef19c">When can RVO not apply?</h3>
<p>
RVO Rules: what is returned has to be either:
</p>

<ul>
<li>a temporary (prvalue)</li>
<li>the name of a stack variable</li>

</ul>

</section>
<section id="slide-org5ba66c2">
<h3 id="org5ba66c2">When can RVO not apply?</h3>
<p>
RVO Ability: sometimes, the callee <i>can't</i> construct the object in-place.
</p>

<ul>
<li>if there is no opportunity to</li>
<li>if it's not of the right type</li>
<li>if the callee doesn't know enough</li>

</ul>

<aside class="notes">
<p>
Function arguments that are passed to you already-constructed can't be RVOed on
return. But you can move them.
</p>

<p>
You have to know at construction time that you're going to be returning that
variable in order to RVO it.
</p>

</aside>

</section>
<section id="slide-orgaaaaabd">
<h3 id="orgaaaaabd">No RVO because no opportunity</h3>
<p>
You can't RVO a variable if you didn't get the chance to construct it in the
first place.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #0000ff;">sad_function</span><span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">s</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  s += <span style="color: #8b2252;">"No RVO for you!"</span>;
  <span style="color: #a020f0;">return</span> s;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
But the compiler will still move it. (Since C++11)
</p>

<aside class="notes">
<p>
C++11 mandates that if you can't do the RVO, you must try to move and only copy
as a last resort.
</p>

</aside>

</section>
<section id="slide-orgd77f673">
<h3 id="orgd77f673">No RVO because wrong type, 1</h3>
<p>
An rvalue-ref is not the same type.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #0000ff;">sad_function</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">s</span> = <span style="color: #8b2252;">"No RVO for you!"</span>;
  <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::move<span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
Don't <code>return std::move(x)</code> in most cases - you will get a move when you didn't need anything!
</p>

<aside class="notes">
<p>
There are legitimate cases for returning an rvalue reference.
</p>

<p>
One of the few times when <code>return std::move(x)</code> is proper is when you're returning a
member variable out of a rvalue-ref-qualified member function.
</p>

</aside>

</section>
<section id="slide-orgbbd0e34">
<h3 id="orgbbd0e34">No RVO because wrong type, 2</h3>
<p>
Factory functions can't RVO.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Base</span> <span style="color: #707183;">{</span> <span style="color: #0000ff;">...</span> <span style="color: #707183;">}</span>;
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Derived</span> : <span style="color: #228b22;">Base</span> <span style="color: #707183;">{</span> <span style="color: #0000ff;">...</span> <span style="color: #707183;">}</span>;

<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">shared_ptr</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">Base</span><span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">factory</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::make_shared<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Derived</span><span style="color: #7388d6;">&gt;()</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
But will still move.
</p>

<aside class="notes">
<p>
This is also true of any types that are inter-convertible.
e.g. returning a pair when the function returns a tuple, or something like that.
</p>

</aside>

</section>
<section id="slide-orgc8a54d6">
<h3 id="orgc8a54d6">No RVO because not enough info</h3>
<p>
It has to be decidable at construction time.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #0000ff;">undecided_function</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">happy</span> = <span style="color: #8b2252;">"Hooray"</span>;
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">sad</span> = <span style="color: #8b2252;">"Boo hoo"</span>;

  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>getHappiness<span style="color: #909183;">()</span> &gt; <span style="color: #008b8b;">0.5</span><span style="color: #7388d6;">)</span>
    <span style="color: #a020f0;">return</span> happy;
  <span style="color: #a020f0;">else</span>
    <span style="color: #a020f0;">return</span> sad;
<span style="color: #707183;">}</span>

</pre>
</div>
<p>
Again, return value will still be moved.
</p>

</section>
<section id="slide-orgfefd17d">
<h3 id="orgfefd17d">Why is RVO important?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::string, <span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span>;

<span style="color: #228b22;">M</span> <span style="color: #0000ff;">build_map</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
  m.insert<span style="color: #7388d6;">(</span><span style="color: #008b8b;">std</span>::make_pair<span style="color: #909183;">(</span><span style="color: #8b2252;">"Jenny"</span>, <span style="color: #008b8b;">8675309</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">return</span> m;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
RVO is really important for performance. It's probably the single most important
optimization compilers make. Hence why it's been around for decades, even
without a standard.
</p>

<p>
If we accidentally inhibit RVO, we might also inhibit <code>move</code>. We might get a
copy.
</p>

<p>
<code>move</code> isn't necessarily cheap. Microsoft's node-based containers allocate in
their move constructors because they use sentinel nodes.
</p>

</aside>

</section>
<section id="slide-org3932d4a">
<h3 id="org3932d4a">Quiz time</h3>
<p>
Wake up!
</p>

<p>
And tell me if the upcoming code snippets will activate RVO.
</p>

</section>
<section id="slide-orgfcd7ffb">
<h3 id="orgfcd7ffb">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">const</span> <span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes.
</p>

<aside class="notes">
<p>
Yes. You're allowed to cv-qualify return types and RVO still works.
</p>

<p>
But don't do this. The compiler ignores const-qualified builtin types anyway.
</p>

</aside>

</section>
<section id="slide-orgc687fcb">
<h3 id="orgc687fcb">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>b<span style="color: #7388d6;">)</span>
    <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">else</span>
    <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes. Even in debug builds.
</p>

<aside class="notes">
<p>
Yes. This is URVO, and works pretty reliably even in debug builds.
</p>

</aside>

</section>
<section id="slide-orgf83ad04">
<h3 id="orgf83ad04">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span>, <span style="color: #228b22;">S</span> <span style="color: #a0522d;">s</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>b<span style="color: #7388d6;">)</span>
    s = S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">return</span> s;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
No (no opportunity).
</p>

<aside class="notes">
<p>
No - can't RVO a function parameter. It will move though.
</p>

</aside>

</section>
<section id="slide-org29affe3">
<h3 id="org29affe3">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">get_S</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span> <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>; <span style="color: #707183;">}</span>

<span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>b<span style="color: #7388d6;">)</span>
    <span style="color: #a020f0;">return</span> get_S<span style="color: #7388d6;">()</span>;
  <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes (can elide multiple copies).
</p>

<aside class="notes">
<p>
Yes. This RVOs.
RVO is allowed to elide multiple copies down the callstack.
</p>

</aside>

</section>
<section id="slide-org855e403">
<h3 id="org855e403">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>b<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">{</span>
    <span style="color: #228b22;">S</span> <span style="color: #a0522d;">s</span><span style="color: #909183;">{</span><span style="color: #008b8b;">1</span><span style="color: #909183;">}</span>;
    <span style="color: #a020f0;">return</span> s;
  <span style="color: #7388d6;">}</span>
  <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes (Clang), no (MSVC/GCC).
</p>

<aside class="notes">
<p>
There's nothing stopping it&#x2026; but only Clang successfully RVO's this.
</p>

</aside>

</section>
<section id="slide-org5266152">
<h3 id="org5266152">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">S</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>b<span style="color: #7388d6;">)</span>
    <span style="color: #a020f0;">return</span> s;
  <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
No. Possibly in future?
</p>

<aside class="notes">
<p>
We hoisted the S out of the condition.
</p>

<p>
No RVO here (a sufficiently smart compiler might be able to&#x2026;)
</p>

<p>
It still moves.
</p>

</aside>

</section>
<section id="slide-orgaf011fd">
<h3 id="orgaf011fd">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">S</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">return</span> b ? s : S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
No. (Against the rules.)
</p>

<aside class="notes">
<p>
No RVO. We're not naming a variable.
Will it still move? No.
</p>

<p>
We're not naming a variable. And it's not a prvalue - the conditional operator
produces an lvalue reference here. We have to copy.
</p>

<p>
This is perhaps a semi-common pattern that defeats RVO!
</p>

</aside>

</section>
<section id="slide-orgad9b027">
<h3 id="orgad9b027">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">get_S</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span> <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>; <span style="color: #707183;">}</span>

<span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">(</span><span style="color: #228b22;">bool</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> b ? get_S<span style="color: #7388d6;">()</span> : S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes. (Returning temporary.)
</p>

<aside class="notes">
<p>
This RVOs. This time the conditional operator produces a prvalue because both of
its operands are prvalues.
</p>

</aside>

</section>
<section id="slide-orgec26282">
<h3 id="orgec26282">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">S</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
  s = S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">2</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">return</span> s;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes.
</p>

<aside class="notes">
<p>
Yep. Plain NRVO.
</p>

</aside>

</section>
<section id="slide-orgfedde95">
<h3 id="orgfedde95">Will it RVO?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">will_it_rvo</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">S</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p class="fragment (appear)">
Yes.
</p>
<p class="fragment (appear)">
<a href="http://eel.is/c++draft/class.copy.elision#3.1" class="fragment (appear)">class.copy.elision &sect; 3.1</a>
</p>

<aside class="notes">
<p>
The standard explicitly allows this &#x2013; (possibly parenthesized) <i>id-expression</i>.
</p>

<p>
However&#x2026; there seems to be a bug in GCC where it doesn't RVO this. MSVC does
and Clang does.
</p>

<p>
Technically GCC is still adhering to the standard, because it's not required to
RVO. It does in C++11 mode, just not in C++14 or C++17 mode.
</p>

</aside>

</section>
<section id="slide-org84d6f38">
<h3 id="org84d6f38">Exhibit C</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #228b22;">long</span> <span style="color: #0000ff;">Time</span><span style="color: #707183;">()</span> <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">override</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">ts</span> = <span style="color: #008b8b;">std</span>::get<span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">std</span>::move<span style="color: #909183;">(</span><span style="color: #008b8b;">Base</span>::metrics_-&gt;GetDataPointAndTime<span style="color: #709870;">()</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">return</span> ts;
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
Superfluous (potentially dangerous?) call to <code>std::move</code>.
</p>

<p>
NRVO is not guaranteed in debug mode. Better:
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #228b22;">long</span> <span style="color: #0000ff;">Time</span><span style="color: #707183;">()</span> <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">override</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">blz</span>::get<span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">Base</span>::metrics_-&gt;GetDataPointAndTime<span style="color: #909183;">()</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Just an integral type here, so no big deal. But if it gets changed, or this
pattern gets copied&#x2026;
</p>

</aside>

</section>
<section id="slide-orgf0ead63">
<h3 id="orgf0ead63">Guidelines for RVO-friendliness</h3>
<ul>
<li>don't const-qualify returned value types</li>
<li>almost never return <code>std::move(x)</code></li>
<li>return temporaries where you can</li>
<li>when you return named things, avoid conditions</li>
<li>don't parenthesize return expressions</li>

</ul>

<aside class="notes">
<p>
First point does not affect RVO but is generally useless.
</p>

<p>
Returning <code>std::move(x)</code> is only for ref-qualified accessors.
</p>

<p>
URVO is easier for the compiler than NRVO. You are likely to get URVO in debug
builds.
</p>

<p>
Beware of the conditional operator.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org242a98d">
<h2 id="org242a98d">3. Putting stuff into a <code>vector</code></h2>
<p>
Should you use <code>push_back</code> or should you use <code>emplace_back</code>?
</p>

<p>
How should you use them?
</p>

</section>
<section id="slide-org19110d0">
<h3 id="org19110d0"><code>push_back</code> and <code>emplace_back</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">push_back</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">T</span>&amp; <span style="color: #a0522d;">x</span><span style="color: #707183;">)</span>;
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">push_back</span><span style="color: #707183;">(</span><span style="color: #228b22;">T</span>&amp;&amp; <span style="color: #a0522d;">x</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">reference</span> <span style="color: #0000ff;">emplace_back</span><span style="color: #707183;">(</span><span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Until C++17, <code>emplace_back</code> returns <code>void</code>.
</p>

<p>
<code>blz</code>'s emplace<sub>back</sub> returns a reference.
</p>

</aside>

</section>
<section id="slide-org889a7e6">
<h3 id="org889a7e6">Example 1</h3>
<p>
What's the difference here?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::string<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">s</span>;
<span style="color: #006400;">// </span><span style="color: #006400;">...</span>

v.push_back<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::move<span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
v.emplace_back<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::move<span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
There is no difference.
</p>

</aside>

</section>
<section id="slide-orgbdd49af">
<h3 id="orgbdd49af">Example 1.1</h3>
<p>
What's the difference here?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::string<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">s</span>;

v.push_back<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::move<span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">last_s</span> = v.emplace_back<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::move<span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
If we want to capture a reference to the thing that was pushed, we can use
<code>emplace_back</code>.
</p>

</aside>

</section>
<section id="slide-orge6fc776">
<h3 id="orge6fc776">Example 2</h3>
<p>
What's the difference here?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::string<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span> = <span style="color: #8b2252;">"Hello"</span>;

v.push_back<span style="color: #707183;">(</span>s<span style="color: #707183;">)</span>;
v.emplace_back<span style="color: #707183;">(</span>s<span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
<code>push_back</code> constructs a temporary then moves it.
</p>

<p>
<code>emplace_back</code> constructs directly in place.
</p>

<p>
Remember, for string, a move is usually as expensive as a copy.
</p>

</aside>

</section>
<section id="slide-orgcbd2226">
<h3 id="orgcbd2226">Example 2.1</h3>
<p>
Default in-place construct.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">first default-construct in the vector</span>
<span style="color: #228b22;">S</span>&amp; <span style="color: #a0522d;">s</span> = v.emplace_back<span style="color: #707183;">()</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">now mutate s</span>
<span style="color: #006400;">// </span><span style="color: #006400;">...</span>
</pre>
</div>

<p>
<code>emplace_back</code> takes a parameter pack. Parameter packs can be empty.
</p>

<aside class="notes">
<p>
<code>emplace_back</code> is especially useful for this use case.
</p>

</aside>

</section>
<section id="slide-org46daa82">
<h3 id="org46daa82">Example 3</h3>
<p>
In-place construct with <code>explicit</code> constructor.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">recall: S has an explicit constructor from int</span>
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">push_back can't do explicit construction</span>
v.push_back<span style="color: #707183;">(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;  <span style="color: #006400;">// </span><span style="color: #006400;">compiler error!</span>

<span style="color: #006400;">// </span><span style="color: #006400;">explicit construction is no problem for emplace_back</span>
<span style="color: #228b22;">S</span>&amp; <span style="color: #a0522d;">s</span> = v.emplace_back<span style="color: #707183;">(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
<code>emplace_back</code> does perfect forwarding. It can call <code>explicit</code> constructors.
</p>

<aside class="notes">
<p>
<code>emplace_back</code> is especially useful for this use case.
</p>

</aside>

</section>
<section id="slide-orgf1884e2">
<h3 id="orgf1884e2">Example: copy</h3>
<p>
Recall: our <code>S</code> class has a constructor from <code>Foo</code>, and an <code>explicit</code> constructor
from <code>int</code>.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">array</span><span style="color: #707183;">&lt;</span>Foo, <span style="color: #008b8b;">3</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">a</span> = <span style="color: #707183;">{</span> Foo<span style="color: #7388d6;">{}</span>, Foo<span style="color: #7388d6;">{}</span>, Foo<span style="color: #7388d6;">{}</span> <span style="color: #707183;">}</span>;
v.reserve<span style="color: #707183;">(</span>a.size<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>;

<span style="color: #008b8b;">std</span>::copy<span style="color: #707183;">(</span>a.cbegin<span style="color: #7388d6;">()</span>, a.cend<span style="color: #7388d6;">()</span>, <span style="color: #008b8b;">std</span>::back_inserter<span style="color: #7388d6;">(</span>v<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
What does <code>back_insert_iterator</code> do here?
</p>

<aside class="notes">
<p>
For each element, we construct an <code>S</code> (from the <code>Foo</code>) and then we move it into
the <code>vector</code>.
</p>

</aside>

</section>
<section id="slide-org33f9ec3">
<h3 id="org33f9ec3">Example: copy</h3>
<p>
What if we have an <code>array</code> of <code>int</code>?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">array</span> <span style="color: #a0522d;">a</span> = <span style="color: #707183;">{</span> <span style="color: #008b8b;">1</span>,<span style="color: #008b8b;">2</span>,<span style="color: #008b8b;">3</span>,<span style="color: #008b8b;">4</span>,<span style="color: #008b8b;">5</span> <span style="color: #707183;">}</span>;
v.reserve<span style="color: #707183;">(</span>a.size<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>;

<span style="color: #008b8b;">std</span>::copy<span style="color: #707183;">(</span>a.cbegin<span style="color: #7388d6;">()</span>, a.cend<span style="color: #7388d6;">()</span>, <span style="color: #008b8b;">std</span>::back_inserter<span style="color: #7388d6;">(</span>v<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p class="fragment (appear)">
Oops. The compiler is angry at us.
</p>

<aside class="notes">
<p>
<code>back_insert_iterator</code> calls <code>push_back</code> - it can't call our explicit
constructor.
</p>

</aside>

</section>
<section id="slide-org65e4726">
<h3 id="org65e4726">Example: copy?</h3>
<p>
OK, no problem, right?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">array</span> <span style="color: #a0522d;">a</span> = <span style="color: #707183;">{</span> <span style="color: #008b8b;">1</span>,<span style="color: #008b8b;">2</span>,<span style="color: #008b8b;">3</span>,<span style="color: #008b8b;">4</span>,<span style="color: #008b8b;">5</span> <span style="color: #707183;">}</span>;
v.reserve<span style="color: #707183;">(</span>a.size<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>;

<span style="color: #008b8b;">std</span>::transform<span style="color: #707183;">(</span>a.cbegin<span style="color: #7388d6;">()</span>, a.cend<span style="color: #7388d6;">()</span>, <span style="color: #008b8b;">std</span>::back_inserter<span style="color: #7388d6;">(</span>v<span style="color: #7388d6;">)</span>,
               <span style="color: #7388d6;">[]</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span> <span style="color: #a020f0;">return</span> S<span style="color: #909183;">{</span>i<span style="color: #909183;">}</span>; <span style="color: #7388d6;">}</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
For each element, we construct an <code>S</code> (from the <code>int</code>) and then we move it into
the <code>vector</code>. No extra cost over the first solution, because the <code>return</code> from the
lambda RVOs.
</p>

<p>
But what we actually want to do is construct in place.
</p>

</aside>

</section>
<section id="slide-orge403acf">
<h3 id="orge403acf"><code>back_emplacer</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Container</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">back_emplace_iterator</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">back_emplace_iterator</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">Container</span>&amp; <span style="color: #a0522d;">c</span><span style="color: #7388d6;">)</span> : c<span style="color: #7388d6;">(</span>&amp;c<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{}</span>

  <span style="color: #228b22;">back_emplace_iterator</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">++</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{</span> <span style="color: #a020f0;">return</span> *<span style="color: #a020f0;">this</span>; <span style="color: #7388d6;">}</span>
  <span style="color: #228b22;">back_emplace_iterator</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">*</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{</span> <span style="color: #a020f0;">return</span> *<span style="color: #a020f0;">this</span>; <span style="color: #7388d6;">}</span>

  <span style="color: #a020f0;">template</span> <span style="color: #7388d6;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Arg</span><span style="color: #7388d6;">&gt;</span>
  <span style="color: #228b22;">back_emplace_iterator</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">=</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">Arg</span>&amp;&amp; <span style="color: #a0522d;">arg</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
    c-&gt;emplace_back<span style="color: #909183;">(</span><span style="color: #008b8b;">std</span>::forward<span style="color: #709870;">&lt;</span><span style="color: #228b22;">Arg</span><span style="color: #709870;">&gt;(</span><span style="color: #a0522d;">arg</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>;
    <span style="color: #a020f0;">return</span> *<span style="color: #a020f0;">this</span>;
  <span style="color: #7388d6;">}</span>

<span style="color: #a020f0;">private</span>:
  <span style="color: #228b22;">Container</span>* <span style="color: #a0522d;">c</span>;
<span style="color: #707183;">}</span>;
</pre>
</div>

</section>
<section id="slide-org964333c">
<h3 id="org964333c"><code>back_emplacer</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">pre-CTAD maker function</span>

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Container</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">back_emplacer</span><span style="color: #707183;">(</span><span style="color: #228b22;">Container</span>&amp; <span style="color: #a0522d;">c</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> back_emplace_iterator<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Container</span><span style="color: #7388d6;">&gt;(</span>c<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-org4b10f23">
<h3 id="org4b10f23"><code>back_emplacer</code></h3>
<p>
What if we have an <code>array</code> of <code>int</code>?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">array</span> <span style="color: #a0522d;">a</span> = <span style="color: #707183;">{</span> <span style="color: #008b8b;">1</span>,<span style="color: #008b8b;">2</span>,<span style="color: #008b8b;">3</span>,<span style="color: #008b8b;">4</span>,<span style="color: #008b8b;">5</span> <span style="color: #707183;">}</span>;
v.reserve<span style="color: #707183;">(</span>a.size<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>;

<span style="color: #008b8b;">std</span>::copy<span style="color: #707183;">(</span>a.cbegin<span style="color: #7388d6;">()</span>, a.cend<span style="color: #7388d6;">()</span>, back_emplacer<span style="color: #7388d6;">(</span>v<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

</section>
<section id="slide-org7a4d4e1">
<h3 id="org7a4d4e1">Exhibit D</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::string_view<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">tokens</span>;
<span style="color: #006400;">// </span><span style="color: #006400;">...</span>
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string_view</span> <span style="color: #a0522d;">token</span> = <span style="color: #006400;">/* </span><span style="color: #006400;">stuff */</span>;
tokens.emplace_back<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::move<span style="color: #7388d6;">(</span>token<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
A few things here:
</p>
<ul>
<li><code>string_view</code> is a pointer + length. recommendation is to pass by value;
<code>move</code> gains nothing anyway.</li>
<li><code>push_back</code> works with rvalues just fine - <code>emplace_back</code> gains nothing here.</li>
<li>if you want to, you should pass <code>/* stuff */</code> directly to <code>emplace_back</code>.</li>

</ul>

</aside>

</section>
<section id="slide-org11fcf8c">
<h3 id="org11fcf8c">Exhibit E</h3>
<div class="org-src-container">

<pre  class="src src-c++">context-&gt;m_result-&gt;m_headers.emplace_back<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::string<span style="color: #7388d6;">(</span>headerData, numBytes<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
A superfluous move! Better:
</p>

<div class="org-src-container">

<pre  class="src src-c++">context-&gt;m_result-&gt;m_headers.emplace_back<span style="color: #707183;">(</span>headerData, numBytes<span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Don't explicitly call a constructor with <code>emplace_back</code>.
</p>

<aside class="notes">
<p>
And remember, likely a superfluous copy if the string is small-buffer-optimized.
</p>

</aside>

</section>
<section id="slide-org0c65923">
<h3 id="org0c65923"><code>vector</code> of <code>pair</code> = <code>map</code></h3>
<p>
Sometimes, we use a  sorted <code>vector</code> of <code>pair</code> as a replacement for <code>map</code>.
</p>

<p>
What do you do if part of your <code>pair</code> has a multi-argument constructor?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Foo</span> <span style="color: #707183;">{</span> <span style="color: #0000ff;">Foo</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span>, <span style="color: #008b8b;">std</span>::string, <span style="color: #228b22;">double</span><span style="color: #7388d6;">)</span>; <span style="color: #707183;">}</span>;

<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">pair</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span>, <span style="color: #228b22;">Foo</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">this is very common!</span>
v.push_back<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::make_pair<span style="color: #7388d6;">(</span><span style="color: #008b8b;">1</span>, Foo<span style="color: #909183;">{</span><span style="color: #008b8b;">42</span>, <span style="color: #8b2252;">"hello"</span>, <span style="color: #008b8b;">3.14</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">this is no better</span>
v.emplace_back<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::make_pair<span style="color: #7388d6;">(</span><span style="color: #008b8b;">1</span>, Foo<span style="color: #909183;">{</span><span style="color: #008b8b;">42</span>, <span style="color: #8b2252;">"hello"</span>, <span style="color: #008b8b;">3.14</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">how can we do better?</span>
v.emplace_back<span style="color: #707183;">(</span> <span style="color: #006400;">/* </span><span style="color: #006400;">what here? */</span> <span style="color: #707183;">)</span>;
</pre>
</div>

</section>
<section id="slide-org22c7014">
<h3 id="org22c7014"><code>piecewise_construct</code> to the rescue!</h3>
<p>
<code>pair</code> has a constructor that will handle your multi-argument constructor.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args1</span>, <span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args2</span><span style="color: #707183;">&gt;</span>
<span style="color: #0000ff;">pair</span><span style="color: #707183;">(</span><span style="color: #228b22;">piecewise_construct_t</span>,
     <span style="color: #228b22;">tuple</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Args1</span><span style="color: #0000ff;">...</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">first_args</span>,
     <span style="color: #228b22;">tuple</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Args2</span><span style="color: #0000ff;">...</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">second_args</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Types</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">tuple</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">Types</span>&amp;&amp;<span style="color: #0000ff;">...</span><span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">forward_as_tuple</span><span style="color: #707183;">(</span><span style="color: #228b22;">Types</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span> <span style="color: #a020f0;">noexcept</span>;
</pre>
</div>

<p>
<code>piecewise_construct_t</code> is a tag type.
</p>

</section>
<section id="slide-orgaa26b99">
<h3 id="orgaa26b99">Using <code>piecewise_construct</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Foo</span> <span style="color: #707183;">{</span> <span style="color: #0000ff;">Foo</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span>, <span style="color: #008b8b;">std</span>::string, <span style="color: #228b22;">double</span><span style="color: #7388d6;">)</span>; <span style="color: #707183;">}</span>;

<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">pair</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span>, <span style="color: #228b22;">Foo</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">instead of this...</span>
v.push_back<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::make_pair<span style="color: #7388d6;">(</span><span style="color: #008b8b;">1</span>, Foo<span style="color: #909183;">{</span><span style="color: #008b8b;">42</span>, <span style="color: #8b2252;">"hello"</span>, <span style="color: #008b8b;">3.14</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">...we can do this</span>
v.emplace_back<span style="color: #707183;">(</span>
  <span style="color: #008b8b;">std</span>::piecewise_construct,
  <span style="color: #008b8b;">std</span>::forward_as_tuple<span style="color: #7388d6;">(</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span>,                   <span style="color: #006400;">// </span><span style="color: #006400;">args to int "constructor"</span>
  <span style="color: #008b8b;">std</span>::forward_as_tuple<span style="color: #7388d6;">(</span><span style="color: #008b8b;">42</span>, <span style="color: #8b2252;">"hello"</span>, <span style="color: #008b8b;">3.14</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span><span style="color: #88090B;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">args to Foo constructor</span>
</pre>
</div>
<p>
Perfect forwarding and in-place construction.
</p>

</section>
<section id="slide-org1ef5598">
<h3 id="org1ef5598">Recommendations</h3>
<ul>
<li><code>push_back</code> is perfectly fine for rvalues</li>
<li>use <code>emplace_back</code> only when you need its powers
<ul>
<li>in-place construction (including nullary construction)</li>
<li>a reference to what's added (C++17)</li>

</ul></li>
<li>never pass an explicit temporary to <code>emplace_back</code></li>
<li>try to construct in place when you can</li>
<li>use <code>piecewise_construct</code> / <code>forward_as_tuple</code> to forward args through <code>pair</code></li>

</ul>

</section>
</section>
<section>
<section id="slide-org4d7c1b1">
<h2 id="org4d7c1b1">4. <code>initializer_list</code></h2>
<div class='vertspace2'></div>
<blockquote nil><p>&quot;I fear these stubborn lines lack power to move&quot;</p>
<div></div><div class='author'>-- William Shakespeare, <em>Love's Labours Lost</em></div></blockquote>

</section>
<section id="slide-orga10277a">
<h3 id="orga10277a">What is <code>initializer_list</code>?</h3>
<p>
When you write:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span><span style="color: #707183;">{</span> <span style="color: #008b8b;">1</span>,<span style="color: #008b8b;">2</span>,<span style="color: #008b8b;">3</span> <span style="color: #707183;">}</span>;
</pre>
</div>
<p>
It's as if you wrote:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">a</span><span style="color: #707183;">[]</span> = <span style="color: #707183;">{</span> <span style="color: #008b8b;">1</span>,<span style="color: #008b8b;">2</span>,<span style="color: #008b8b;">3</span> <span style="color: #707183;">}</span>;
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = <span style="color: #008b8b;">std</span>::initializer_list<span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;(</span>a, a+<span style="color: #008b8b;">3</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Notice: the backing array is <code>const</code>.
</p>

</aside>

</section>
<section id="slide-orgce4cc19">
<h3 id="orgce4cc19"><code>initializer_list</code> has <code>const</code> storage, 1</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #0000ff;">...</span> <span style="color: #a0522d;">Is</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">f</span><span style="color: #707183;">()</span> <span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">initializer_list</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;{</span> Is<span style="color: #0000ff;">...</span> <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">foo</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>: <span style="color: #909183;">{</span><span style="color: #008b8b;">1</span>,<span style="color: #008b8b;">2</span>,<span style="color: #008b8b;">3</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span>
    cout &lt;&lt; i &lt;&lt; <span style="color: #8b2252;">'</span><span style="color: #8b2252; font-weight: bold;">\</span><span style="color: #8b2252; font-weight: bold;">n</span><span style="color: #8b2252;">'</span>;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">bar</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>: f<span style="color: #909183;">&lt;</span><span style="color: #008b8b;">1</span>,<span style="color: #008b8b;">2</span>,<span style="color: #008b8b;">3</span><span style="color: #909183;">&gt;()</span><span style="color: #7388d6;">)</span>
    cout &lt;&lt; i &lt;&lt; <span style="color: #8b2252;">'</span><span style="color: #8b2252; font-weight: bold;">\</span><span style="color: #8b2252; font-weight: bold;">n</span><span style="color: #8b2252;">'</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
This is nasty, because it could work on one compiler and you wouldn't notice it.
</p>

<p>
The compiler probably won't warn for this.
</p>

<p>
<code>initializer_list</code> is a "view" type like <code>string_view</code> and doesn't own its
contents.
</p>

</aside>

</section>
<section id="slide-org8e239f6">
<h3 id="org8e239f6"><code>initializer_list</code> has <code>const</code> storage, 2</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">unique_ptr</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = <span style="color: #707183;">{</span> make_unique<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span>, make_unique<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">2</span><span style="color: #7388d6;">)</span> <span style="color: #707183;">}</span>;
</pre>
</div>
<p>
That also means <code>move</code> can't work.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">const</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">unique_ptr</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">a</span><span style="color: #707183;">[]</span> = <span style="color: #707183;">{</span> <span style="color: #008b8b;">std</span>::make_unique<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span>,
                                   <span style="color: #008b8b;">std</span>::make_unique<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">2</span><span style="color: #7388d6;">)</span> <span style="color: #707183;">}</span>;
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">unique_ptr</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> =
  <span style="color: #008b8b;">std</span>::initializer_list<span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">unique_ptr</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;(</span>a, a+<span style="color: #008b8b;">3</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
You can't move from an <code>initializer_list</code> - this won't compile.
</p>

</aside>

</section>
<section id="slide-org988142a">
<h3 id="org988142a">But they're so convenient!</h3>
<p>
I'd much rather write:
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = <span style="color: #707183;">{</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>, S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">2</span><span style="color: #7388d6;">}</span>, S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">3</span><span style="color: #7388d6;">}</span> <span style="color: #707183;">}</span>;
</pre>
</div>
<p>
(3 constructs, 3 copies, 3 destructs)
</p>

<p>
Than:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
v.reserve<span style="color: #707183;">(</span><span style="color: #008b8b;">3</span><span style="color: #707183;">)</span>;
v.emplace_back<span style="color: #707183;">(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
v.emplace_back<span style="color: #707183;">(</span><span style="color: #008b8b;">2</span><span style="color: #707183;">)</span>;
v.emplace_back<span style="color: #707183;">(</span><span style="color: #008b8b;">3</span><span style="color: #707183;">)</span>;
</pre>
</div>
<p>
(3 constructs)
</p>

<aside class="notes">
<p>
The first version is probably OK for builtin primitive types.
</p>

<p>
It's way worse than the second version for types with more than trivial
construction.
</p>

</aside>

</section>
<section id="slide-org6dfbc66">
<h3 id="org6dfbc66">We can make it a little better&#x2026;</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = <span style="color: #707183;">{</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>, S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">2</span><span style="color: #7388d6;">}</span>, S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">3</span><span style="color: #7388d6;">}</span> <span style="color: #707183;">}</span>;
</pre>
</div>
<p>
(3 constructs, 3 copies, 3 destructs)
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #a0522d;">a</span><span style="color: #707183;">[</span><span style="color: #008b8b;">3</span><span style="color: #707183;">]</span> = <span style="color: #707183;">{</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>, S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">2</span><span style="color: #7388d6;">}</span>, S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">3</span><span style="color: #7388d6;">}</span> <span style="color: #707183;">}</span>;
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">S</span><span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">v</span><span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">make_move_iterator</span><span style="color: #7388d6;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">begin</span><span style="color: #909183;">(</span><span style="color: #a0522d;">a</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>,
                 <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">make_move_iterator</span><span style="color: #7388d6;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">end</span><span style="color: #909183;">(</span><span style="color: #a0522d;">a</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>
<p>
(3 constructs, 3 moves, 3 destructs)
</p>

</section>
<section id="slide-org8677121">
<h3 id="org8677121">What we really need&#x2026;</h3>
<p>
Is an in-place constructor for <code>vector</code>. (For everything?)
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">vector</span><span style="color: #707183;">(</span><span style="color: #228b22;">in_place_t</span>, <span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Future (?) proposal by Simon Brand.
</p>

<p>
<a href="https://wg21.tartanllama.xyz/initializer_list">https://wg21.tartanllama.xyz/initializer_list</a>
</p>

</section>
<section id="slide-org446461b">
<h3 id="org446461b">Exhibit F</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">unordered_set</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::string<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">kKeywords</span> = <span style="color: #707183;">{</span>
        <span style="color: #8b2252;">"alignas"</span>, <span style="color: #8b2252;">"alignof"</span>, <span style="color: #8b2252;">"and"</span>, <span style="color: #8b2252;">"and_eq"</span>, <span style="color: #8b2252;">"asm"</span>, <span style="color: #8b2252;">"auto"</span>, <span style="color: #8b2252;">"bitand"</span>, <span style="color: #8b2252;">"bitor"</span>,
        <span style="color: #8b2252;">"bool"</span>, <span style="color: #8b2252;">"break"</span>, <span style="color: #8b2252;">"case"</span>, <span style="color: #8b2252;">"catch"</span>, <span style="color: #8b2252;">"char"</span>, <span style="color: #8b2252;">"class"</span>, <span style="color: #8b2252;">"compl"</span>, <span style="color: #8b2252;">"const"</span>,
        <span style="color: #8b2252;">"constexpr"</span>, <span style="color: #8b2252;">"const_cast"</span>, <span style="color: #8b2252;">"continue"</span>, <span style="color: #8b2252;">"decltype"</span>, <span style="color: #8b2252;">"default"</span>, <span style="color: #8b2252;">"delete"</span>, <span style="color: #8b2252;">"do"</span>,
        <span style="color: #8b2252;">"double"</span>, <span style="color: #8b2252;">"dynamic_cast"</span>, <span style="color: #8b2252;">"else"</span>, <span style="color: #8b2252;">"enum"</span>, <span style="color: #8b2252;">"explicit"</span>, <span style="color: #8b2252;">"extern"</span>, <span style="color: #8b2252;">"false"</span>,
        <span style="color: #8b2252;">"float"</span>, <span style="color: #8b2252;">"for"</span>, <span style="color: #8b2252;">"friend"</span>, <span style="color: #8b2252;">"goto"</span>, <span style="color: #8b2252;">"if"</span>, <span style="color: #8b2252;">"inline"</span>, <span style="color: #8b2252;">"int"</span>, <span style="color: #8b2252;">"long"</span>, <span style="color: #8b2252;">"mutable"</span>,
        <span style="color: #8b2252;">"namespace"</span>, <span style="color: #8b2252;">"new"</span>, <span style="color: #8b2252;">"noexcept"</span>, <span style="color: #8b2252;">"not"</span>, <span style="color: #8b2252;">"not_eq"</span>, <span style="color: #8b2252;">"NULL"</span>, <span style="color: #8b2252;">"operator"</span>, <span style="color: #8b2252;">"or"</span>,
        <span style="color: #8b2252;">"or_eq"</span>, <span style="color: #8b2252;">"private"</span>, <span style="color: #8b2252;">"protected"</span>, <span style="color: #8b2252;">"public"</span>, <span style="color: #8b2252;">"register"</span>, <span style="color: #8b2252;">"reinterpret_cast"</span>,
        <span style="color: #8b2252;">"return"</span>, <span style="color: #8b2252;">"short"</span>, <span style="color: #8b2252;">"signed"</span>, <span style="color: #8b2252;">"sizeof"</span>, <span style="color: #8b2252;">"static"</span>, <span style="color: #8b2252;">"static_assert"</span>,
        <span style="color: #8b2252;">"static_cast"</span>, <span style="color: #8b2252;">"struct"</span>, <span style="color: #8b2252;">"switch"</span>, <span style="color: #8b2252;">"template"</span>, <span style="color: #8b2252;">"this"</span>, <span style="color: #8b2252;">"thread_local"</span>,
        <span style="color: #8b2252;">"throw"</span>, <span style="color: #8b2252;">"true"</span>, <span style="color: #8b2252;">"try"</span>, <span style="color: #8b2252;">"typedef"</span>, <span style="color: #8b2252;">"typeid"</span>, <span style="color: #8b2252;">"typename"</span>, <span style="color: #8b2252;">"union"</span>, <span style="color: #8b2252;">"unsigned"</span>,
        <span style="color: #8b2252;">"using"</span>, <span style="color: #8b2252;">"virtual"</span>, <span style="color: #8b2252;">"void"</span>, <span style="color: #8b2252;">"volatile"</span>, <span style="color: #8b2252;">"wchar_t"</span>, <span style="color: #8b2252;">"while"</span>, <span style="color: #8b2252;">"xor"</span>, <span style="color: #8b2252;">"xor_eq"</span>
<span style="color: #707183;">}</span>;
</pre>
</div>

</section>
<section id="slide-org572157b">
<h3 id="org572157b">Caveat Constructor</h3>
<p>
<code>std::string</code> is an interesting case here. We intuit/are taught:
</p>

<blockquote nil><p>Delay construction, allocation, etc. as late as possible.</p></blockquote>

<p>
But that might hurt us with <code>std::string</code>.
</p>

<p>
<a href="https://www.youtube.com/watch?v=sSlmmZMFsXQ">"Initializer Lists are Broken, Let's Fix Them"</a> &#x2013; Jason Turner, C++Now 2018
</p>

</section>
<section id="slide-org049fc7b">
<h3 id="org049fc7b">Surprising: <code>string</code> vs <code>const char*</code></h3>
<p>
SBO-strings
<a href="http://quick-bench.com/5dPSX8rx-R8_BIUYbYOp6DcqhAc">http://quick-bench.com/5dPSX8rx-R8_BIUYbYOp6DcqhAc</a>
</p>

<p>
Non SBO-strings 1:
<a href="http://quick-bench.com/mr6ZIQ8Jy0ghe1scBcTznYF2s5w">http://quick-bench.com/mr6ZIQ8Jy0ghe1scBcTznYF2s5w</a>
</p>

<p>
Non SBO-strings 2:
<a href="http://quick-bench.com/vzlG11LwZN-uMAKdK8X1XgRuaWs">http://quick-bench.com/vzlG11LwZN-uMAKdK8X1XgRuaWs</a>
</p>

<aside class="notes">
<p>
Two things mess with our mental model for strings. First - the small buffer
optimization. As previously mentioned, it makes copy the same cost as move.
</p>

<p>
Second - we often make strings from string literals. What's the type of a string
literal at declaration? Array of char. What's the type of it when you pass it to
a function? It decays to pointer to char.
</p>

<p>
So, if a string isn't small-buffer optimized, move is cheap. And if we're
constructing it from a string literal, the compiler knows the size. If we let it
decay to a char*, we're going to call strlen at some point.
</p>

</aside>

</section>
<section id="slide-org537275e">
<h3 id="org537275e">Recommendations</h3>
<ul>
<li>use <code>initializer_list</code> only for literal types</li>
<li>consider using <code>array</code> and manually moving</li>
<li>probably don't use <code>initializer_list</code> for anything that'll get run more than
once</li>
<li>wait for an <code>in_place_t</code> constructor on <code>vector</code> ?</li>
<li>watch Jason's talk</li>

</ul>

<aside class="notes">
<p>
I'm not sure what to recommend. Really the first point.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgc650212">
<h2 id="orgc650212">5. Putting stuff into a <code>map</code></h2>
<p>
(or other associative container)
</p>

<p>
It's a bit complicated.
</p>

<aside class="notes">
<p>
When I say <code>map</code>, I mean <code>map</code>, <code>unordered_map</code>, <code>multimap</code>, <code>unordered_multimap</code>,
etc, and also the various flavours of <code>set</code>.
</p>

<p>
Note: the <code>value_type</code> of a <code>map</code> is <code>pair&lt;const K, V&gt;</code>. Confusingly, if we want
to refer to just the value in the map and not the key, it's called the
<code>mapped_type</code>.
</p>

</aside>

</section>
<section id="slide-orgdfca5b2">
<h3 id="orgdfca5b2"><code>initializer_list</code> with <code>map</code></h3>
<p>
It's perfectly possible to initialize a map with an <code>initializer_list</code>.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">recall S has an implicit constructor from Foo</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span> <span style="color: #707183;">{</span> <span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span>, Foo<span style="color: #909183;">{}</span><span style="color: #7388d6;">}</span> <span style="color: #707183;">}</span>; <span style="color: #006400;">// </span><span style="color: #006400;">how many constructs/copies/moves?</span>
</pre>
</div>

<p>
Use aggregate initialization with <code>pair</code>.
</p>

<p>
Is this good?
</p>

<aside class="notes">
<p>
Same as the <code>vector</code> init case basically. <code>initializer_list</code> still suffers from
the same problems.
</p>

<p>
You can't use explicit constructors easily here.
</p>

<p>
If you have explicit constructors you might need to explicitly call out the type
 of pair; it's not going to make a lot of difference.
</p>

</aside>

</section>
<section id="slide-orgeec40c9">
<h3 id="orgeec40c9">Alternative: templatery</h3>
<p>
<a href="https://gist.github.com/elbeno/609e929ef6898f09e96a#file-for_each_args-cpp-L55">https://gist.github.com/elbeno/609e929ef6898f09e96a#file-for_each_args-cpp-L55</a>
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">call an N-ary function on each lot of N args passed in</span>
<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">N</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">F</span>, <span style="color: #a020f0;">typename</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Ts</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">for_each_n_args</span><span style="color: #707183;">(</span><span style="color: #228b22;">F</span>&amp;&amp; <span style="color: #a0522d;">f</span>, <span style="color: #228b22;">Ts</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">ts</span><span style="color: #707183;">)</span>;
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
for_each_n_args<span style="color: #707183;">&lt;</span><span style="color: #008b8b;">2</span><span style="color: #707183;">&gt;(</span>
  <span style="color: #7388d6;">[</span>&amp;<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #a020f0;">auto</span>&amp;&amp; <span style="color: #a0522d;">k</span>, <span style="color: #a020f0;">auto</span>&amp;&amp; <span style="color: #a0522d;">v</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
      m.emplace<span style="color: #909183;">(</span>forward<span style="color: #709870;">&lt;</span><span style="color: #a020f0;">decltype</span><span style="color: #907373;">(</span>k<span style="color: #907373;">)</span><span style="color: #709870;">&gt;(</span>k<span style="color: #709870;">)</span>,
                forward<span style="color: #709870;">&lt;</span><span style="color: #a020f0;">decltype</span><span style="color: #907373;">(</span>v<span style="color: #907373;">)</span><span style="color: #709870;">&gt;(</span>v<span style="color: #709870;">)</span><span style="color: #909183;">)</span>; <span style="color: #7388d6;">}</span>,
  <span style="color: #008b8b;">0</span>, <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">we can call explicit constructor</span>
</pre>
</div>

<p>
If you know the types, you can probably write the lambda in a less ugly way.
</p>

<aside class="notes">
<p>
<code>for_each_n_args</code> is a function template that perfectly-forwards its arguments
in groups of N to the function you give it.
</p>

<p>
It's in the Phoenix code base and it's useful for things like this.
</p>

<p>
Everything here gets constructed in place. No moves or copies.
</p>

<p>
This lambda deals with single-argument constructors for value. But&#x2026;
</p>

</aside>

</section>
<section id="slide-org8124ac5">
<h3 id="org8124ac5">Alternative: multi-arg templatery</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
for_each_n_args<span style="color: #707183;">&lt;</span><span style="color: #008b8b;">3</span><span style="color: #707183;">&gt;(</span>
  <span style="color: #7388d6;">[</span>&amp;<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #a020f0;">auto</span>&amp;&amp; <span style="color: #a0522d;">k</span>, <span style="color: #a020f0;">auto</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">v</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
      m.emplace<span style="color: #909183;">(</span>
        <span style="color: #008b8b;">std</span>::piecewise_construct,
        <span style="color: #008b8b;">std</span>::forward_as_tuple<span style="color: #709870;">(</span><span style="color: #008b8b;">std</span>::forward<span style="color: #907373;">&lt;</span><span style="color: #a020f0;">decltype</span><span style="color: #6276ba;">(</span>k<span style="color: #6276ba;">)</span><span style="color: #907373;">&gt;(</span>k<span style="color: #907373;">)</span><span style="color: #709870;">)</span>,
        <span style="color: #008b8b;">std</span>::forward_as_tuple<span style="color: #709870;">(</span><span style="color: #008b8b;">std</span>::forward<span style="color: #907373;">&lt;</span><span style="color: #a020f0;">decltype</span><span style="color: #6276ba;">(</span>v<span style="color: #6276ba;">)</span><span style="color: #907373;">&gt;(</span>v<span style="color: #907373;">)</span><span style="color: #0000ff;">...</span><span style="color: #709870;">)</span>; <span style="color: #88090B;">}</span>,
  <span style="color: #008b8b;">0</span>, <span style="color: #008b8b;">1</span>, <span style="color: #008b8b;">2</span><span style="color: #88090B;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">explicit multi-arg value constructor</span>
</pre>
</div>

<p>
Everything constructed in place.
</p>

<aside class="notes">
<p>
Here we are calling S's two-arg constructor.
</p>

<p>
<code>for_each_n_args</code> also works with vector (including vector-of-pair) as an
alternative to <code>initializer_list</code>
</p>

<p>
There are some issues with calling <code>explicit</code> constructors&#x2026; it depends on the
compiler/library. It is supposed to work.
</p>

</aside>

</section>
<section id="slide-org8a6c82f">
<h3 id="org8a6c82f">Enough about initializing</h3>
<p>
How about putting things into an existing <code>map</code>?
</p>

</section>
<section id="slide-org204fe38">
<h3 id="org204fe38">The Easy Way: <code>operator[]</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">recall S has an implicit constructor from Foo</span>
<span style="color: #006400;">// </span><span style="color: #006400;">but an explicit constructor from int</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
m<span style="color: #707183;">[</span><span style="color: #008b8b;">0</span><span style="color: #707183;">]</span> = S<span style="color: #707183;">{</span><span style="color: #008b8b;">1</span><span style="color: #707183;">}</span>;
m<span style="color: #707183;">[</span><span style="color: #008b8b;">1</span><span style="color: #707183;">]</span> = Foo<span style="color: #707183;">{}</span>;
</pre>
</div>

<p>
How many constructs/moves/copies?
</p>

<aside class="notes">
<p>
These each have a construct, a default construct, and a move.
</p>

<p>
The advantage of this is that when you know the element is there already, it's
fine. You just get a lookup and an assign.
</p>

<p>
But if the element isn't there, you never get a copy construct or a move
construct here.
</p>

<p>
You always get an assign! Because you always get a default construct if the
element isn't there.
</p>

<p>
In fact this is the only function on map that requires your mapped<sub>type</sub> to have
a default constructor! It's fine to use objects without default constructors in
a map, if you never use this function. And that can be a significant thing.
</p>

</aside>

</section>
<section id="slide-org81a5186">
<h3 id="org81a5186">The Other Easy Way: <code>insert</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">recall S has an implicit constructor from Foo</span>
<span style="color: #006400;">// </span><span style="color: #006400;">but an explicit constructor from int</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">pair&lt;iterator,bool&gt; insert(value_type&amp;&amp; value);</span>

<span style="color: #006400;">// </span><span style="color: #006400;">template &lt;class T1, class T2&gt;</span>
<span style="color: #006400;">// </span><span style="color: #006400;">pair&lt;V1,V2&gt; make_pair(T1&amp;&amp; t, T2&amp;&amp; u);</span>

<span style="color: #006400;">// </span><span style="color: #006400;">alternatives:</span>
m.insert<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::make_pair<span style="color: #7388d6;">(</span><span style="color: #008b8b;">0</span>, S<span style="color: #909183;">{</span><span style="color: #008b8b;">1</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
m.insert<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::pair<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span>, <span style="color: #228b22;">S</span>&amp;&amp;<span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">0</span>, S<span style="color: #909183;">{</span><span style="color: #008b8b;">1</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
m.insert<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::make_pair<span style="color: #7388d6;">(</span><span style="color: #008b8b;">0</span>, <span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
How many constructs/moves/copies?
</p>

<aside class="notes">
<p>

</p>

<p>
The first line here creates an S, moves it into pair&lt;int, S&gt;, then moves the
pair into the map.
</p>

<p>
Remember that make<sub>pair</sub> deduces the type of its arguments. And V1 and V2 here
are the decayed types of T1 and T2.
</p>

<p>
The second line forces a pair of type &lt;int, S&amp;&amp;&gt;, so you get one move after the
initial construct.
</p>

<p>
The third line makes a pair&lt;int, int&gt; then uses that pair to construct a pair of
&lt;int, S&gt; in the map. This doesn't currently work with <code>blz</code>. I'll get to why in
a minute.
</p>

</aside>

</section>
<section id="slide-org078ecb5">
<h3 id="org078ecb5"><code>emplace</code></h3>
<p>
Enter the <i>wonderful C++11 panacea</i> that is move semantics.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">recall S has an implicit constructor from Foo</span>
<span style="color: #006400;">// </span><span style="color: #006400;">but an explicit constructor from int</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">template &lt;class... Args&gt;</span>
<span style="color: #006400;">// </span><span style="color: #006400;">pair&lt;iterator,bool&gt; emplace(Args&amp;&amp;... args);</span>

<span style="color: #006400;">// </span><span style="color: #006400;">this was 2 moves</span>
<span style="color: #006400;">// </span><span style="color: #006400;">m.insert(make_pair(0, S{1}));</span>

<span style="color: #006400;">// </span><span style="color: #006400;">much better, right?</span>
m.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::make_pair<span style="color: #7388d6;">(</span><span style="color: #008b8b;">0</span>, S<span style="color: #909183;">{</span><span style="color: #008b8b;">1</span><span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
You guessed it&#x2026;
</p>

<aside class="notes">
<p>
Don't do this. It is <i>exactly</i> the same as <code>insert</code> here. Two moves.
</p>

</aside>

</section>
<section id="slide-org6678bf7">
<h3 id="org6678bf7"><code>emplace</code>, better usage</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">recall S has an implicit constructor from Foo</span>
<span style="color: #006400;">// </span><span style="color: #006400;">but an explicit constructor from int</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">template &lt;class... Args&gt;</span>
<span style="color: #006400;">// </span><span style="color: #006400;">pair&lt;iterator,bool&gt; emplace(Args&amp;&amp;... args);</span>

m.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">0</span>, <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">no moves, just a construct</span>
</pre>
</div>

<aside class="notes">
<p>
Again, the point of <code>emplace</code> is in-place construction.
</p>

<p>
It doesn't help you over <code>insert</code> if you just pass rvalues. <code>insert</code> works just
fine with rvalues.
</p>

</aside>

</section>
<section id="slide-org7ebc677">
<h3 id="org7ebc677"><code>emplace</code> problem</h3>
<p>
What do we do when we want to default-construct the value?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
m.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">0</span><span style="color: #707183;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">default construct S please!</span>
</pre>
</div>

<p class="fragment (appear)">
<i>error 2665: <code>std::pair&lt;const _Kty,_Ty&gt;::pair</code>: none of the 2 overloads could
convert all the argument types</i>
</p>

<aside class="notes">
<p>
Here's a problem: how can we tell <code>emplace</code> to zero-arg construct the value when
we can't syntactically pass "zero arguments" in the place of an argument.
</p>

<p>
We don't want to default-construct an S explicitly here and move it in.
</p>

<p>
We could use <code>operator[]</code> but that would be weird. I don't like expression
statements and I would probably write <code>operator[]</code> with nodiscard.
</p>

<p>
Remember the <code>value_type</code> of the <code>map</code> is a <code>pair</code> - that's what <code>emplace</code> is
trying to construct.
</p>

</aside>

</section>
<section id="slide-org7b675bc">
<h3 id="org7b675bc"><code>emplace</code> with zero-arg constructor</h3>
<p>
Our old friend <code>piecewise_construct</code> can help.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
m.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::piecewise_construct,
          <span style="color: #008b8b;">std</span>::forward_as_tuple<span style="color: #7388d6;">(</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">)</span>,
          <span style="color: #008b8b;">std</span>::forward_as_tuple<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">default construct S please!</span>
</pre>
</div>

<p>
Tuples are allowed to be empty!
</p>

<p>
Yes, we can also use this for more-than-one-arg constructors.
</p>

<aside class="notes">
<p>
Here's the piecewise constructor on <code>pair</code> again.
</p>

<p>
This also gets around the <code>blz</code> limitation on <code>explicit</code> constructors with
<code>emplace</code>. So there is a way to achieve optimality with <code>blz</code>.
</p>

</aside>

</section>
<section id="slide-org586fe58">
<h3 id="org586fe58">Exhibit G</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">explicit ClientIdRecord(</span>
<span style="color: #006400;">//  </span><span style="color: #006400;">const string&amp; clientId, const ProcessId&amp; clientProc, const ProcessId&amp; serverProc);</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">Storage</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">unordered_set</span><span style="color: #707183;">&lt;</span>ClientIdRecord<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">Storage</span> <span style="color: #a0522d;">m_storage</span>;
m_storage.emplace<span style="color: #707183;">(</span>inClientId, clientProc, serverProc<span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Perfectly fine as far as <code>emplace</code> usage.
</p>

<p>
Then we want to change the <code>unordered_set</code> to an <code>unordered_map</code>.
</p>

<aside class="notes">
<p>
ClientIdRecord has a 3-argument constructor.
</p>

<p>
<code>inClientId</code> is a string.
</p>

<p>
One in-place construct. This is fine.
</p>

</aside>

</section>
<section id="slide-orgfb74906">
<h3 id="orgfb74906">Exhibit G</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">explicit ClientIdRecord(</span>
<span style="color: #006400;">//  </span><span style="color: #006400;">const string&amp; clientId, const ProcessId&amp; clientProc, const ProcessId&amp; serverProc);</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">Storage</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">unordered_map</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::string, ClientIdRecord<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">Storage</span> <span style="color: #a0522d;">m_storage</span>;
m_storage.emplace<span style="color: #707183;">(</span>
  <span style="color: #008b8b;">std</span>::make_pair<span style="color: #7388d6;">(</span>inClientId,
                 ClientIdRecord<span style="color: #909183;">(</span>inClientId, clientProc, serverProc<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Is this optimal?
</p>

<aside class="notes">
<p>
2 extra moves here.
</p>

<p>
How do we do better?
</p>

</aside>

</section>
<section id="slide-org827f49a">
<h3 id="org827f49a">Exhibit G</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">Storage</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">unordered_map</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::string, ClientIdRecord<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">Storage</span> <span style="color: #a0522d;">m_storage</span>;
m_storage.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::piecewise_construct,
                  <span style="color: #008b8b;">std</span>::forward_as_tuple<span style="color: #7388d6;">(</span>inClientId<span style="color: #7388d6;">)</span>,
                  <span style="color: #008b8b;">std</span>::forward_as_tuple<span style="color: #7388d6;">(</span>inClientId, clientProc, serverProc<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Use <code>piecewise_construct</code> again.
</p>

</section>
<section id="slide-org5d55457">
<h3 id="org5d55457"><code>emplace</code> problem 2</h3>
<p>
What do you do if you want to <code>emplace</code> the result of a function call?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">get_S</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span> <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>; <span style="color: #707183;">}</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
m.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">0</span>, get_S<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
How can we avoid the move?
</p>

<p>
Is it possible to in-place construct here?
</p>

</section>
<section id="slide-org4334510">
<h3 id="org4334510">In-place construct a function call result</h3>
<p>
We can't avoid evaluating the function call before calling <code>emplace</code>.
</p>

<p>
But, we can control when the result of the function call becomes an <code>S</code>.
</p>

</section>
<section id="slide-org28ffa24">
<h3 id="org28ffa24">In-place construct a function call result</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">F</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">with_result_of_t</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">using</span> <span style="color: #228b22;">T</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">result_of_t</span><span style="color: #7388d6;">&lt;</span>F<span style="color: #909183;">()</span><span style="color: #7388d6;">&gt;</span>;
  <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">with_result_of_t</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">F</span> <span style="color: #a0522d;">f</span><span style="color: #7388d6;">)</span> : f<span style="color: #7388d6;">(</span><span style="color: #008b8b;">std</span>::move<span style="color: #909183;">(</span>f<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{}</span>
  <span style="color: #a020f0;">operator</span> <span style="color: #228b22;">T</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{</span> <span style="color: #a020f0;">return</span> f<span style="color: #909183;">()</span>; <span style="color: #7388d6;">}</span>

<span style="color: #a020f0;">private</span>:
  <span style="color: #228b22;">F</span> <span style="color: #a0522d;">f</span>;
<span style="color: #707183;">}</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">prior to CTAD</span>
<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">F</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">inline</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">with_result_of</span><span style="color: #707183;">(</span><span style="color: #228b22;">F</span>&amp;&amp; <span style="color: #a0522d;">f</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> with_result_of_t<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">F</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">std</span>::forward<span style="color: #909183;">&lt;</span><span style="color: #228b22;">F</span><span style="color: #909183;">&gt;(</span>f<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Capture the function and call it only at the point that we want to convert the
result to an <code>S</code>.
</p>

<p>
<code>invoke_result_t</code> is C++17 - before that you can use <code>result_of_t</code>.
</p>

</aside>

</section>
<section id="slide-org606a360">
<h3 id="org606a360"><code>emplace</code> problem 2</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">S</span> <span style="color: #0000ff;">get_S</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span> <span style="color: #a020f0;">return</span> S<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span>; <span style="color: #707183;">}</span>

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, <span style="color: #228b22;">S</span><span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
m.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">0</span>, with_result_of<span style="color: #7388d6;">(</span><span style="color: #909183;">[]</span> <span style="color: #909183;">{</span> <span style="color: #a020f0;">return</span> get_S<span style="color: #709870;">()</span>; <span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">m.emplace(0, with_result_of(get_S));</span>
</pre>
</div>

<p>
Compilers are really good at optimizing single-use lambdas.
</p>

<aside class="notes">
<p>
You would think the second line here would work just as well. But VC++
doesn't manage to elide the move.
</p>

</aside>

</section>
<section id="slide-org51a3a7d">
<h3 id="org51a3a7d">C++17: <code>insert_or_assign</code></h3>
<p>
Of course, <code>insert</code> / <code>emplace</code> and <code>operator[]</code> actually do different things.
</p>

<p>
What do you do if you want to insert, or assign if the element is already there?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">M</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">pair</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">iterator</span>, <span style="color: #228b22;">bool</span><span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">insert_or_assign</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">key_type</span>&amp; <span style="color: #a0522d;">k</span>, <span style="color: #228b22;">M</span>&amp;&amp; <span style="color: #a0522d;">obj</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">M</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">pair</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">iterator</span>, <span style="color: #228b22;">bool</span><span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">insert_or_assign</span><span style="color: #707183;">(</span><span style="color: #228b22;">key_type</span>&amp;&amp; <span style="color: #a0522d;">k</span>, <span style="color: #228b22;">M</span>&amp;&amp; <span style="color: #a0522d;">obj</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Introduced with C++17.
</p>

<aside class="notes">
<p>
<code>insert_or_assign</code> doesn't need default construction (unlike <code>operator[]</code>).
</p>

<p>
<code>insert_or_assign</code> was introduced with C++17. Can be written as a free function,
but difficult/impossible to make as efficient as map can as a member function.
</p>

</aside>

</section>
<section id="slide-orgcd786e1">
<h3 id="orgcd786e1">C++17: <code>insert_or_assign</code></h3>
<p>
Yet another slightly different interface&#x2026;
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">M</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">map</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span>;
<span style="color: #228b22;">M</span> <span style="color: #a0522d;">m</span>;
m.insert_or_assign<span style="color: #707183;">(</span><span style="color: #008b8b;">0</span>, Foo<span style="color: #7388d6;">{}</span><span style="color: #707183;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">implicit construction - fine</span>

<span style="color: #006400;">// </span><span style="color: #006400;">m.insert_or_assign(1, 1);  // explicit construction - error!</span>
m.insert_or_assign<span style="color: #707183;">(</span><span style="color: #008b8b;">1</span>, with_result_of<span style="color: #7388d6;">(</span><span style="color: #909183;">[]{</span> <span style="color: #a020f0;">return</span> S<span style="color: #709870;">{</span><span style="color: #008b8b;">1</span><span style="color: #709870;">}</span>; <span style="color: #909183;">}</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>; <span style="color: #006400;">// </span><span style="color: #006400;">RVO</span>
</pre>
</div>

<aside class="notes">
<p>
Unfortunately there is no <code>emplace_or_assign</code>. (In the assign case presumably
could not avoid making a temporary to assign). But you can use the same
<code>with_result_of</code> technique with <code>insert_or_assign</code>.
</p>

</aside>

</section>
<section id="slide-orgc28f230">
<h3 id="orgc28f230">Exhibit H</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">K</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">V</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">typename</span> <span style="color: #008b8b;">LRUCache</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">K</span>, <span style="color: #228b22;">V</span><span style="color: #707183;">&gt;</span>::<span style="color: #228b22;">EntryPtr</span> <span style="color: #008b8b;">LRUCache</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">K</span>, <span style="color: #228b22;">V</span><span style="color: #707183;">&gt;</span>::<span style="color: #0000ff;">Insert</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">K</span>&amp; <span style="color: #a0522d;">key</span>, <span style="color: #228b22;">V</span> <span style="color: #a0522d;">value</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #006400;">// </span><span style="color: #006400;">Is the key already present?</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>m_entries.find<span style="color: #909183;">(</span>key<span style="color: #909183;">)</span> != m_entries.end<span style="color: #909183;">()</span><span style="color: #7388d6;">)</span> <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">nullptr</span>;

  <span style="color: #006400;">// </span><span style="color: #006400;">Is the cache full?</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>m_entries.size<span style="color: #909183;">()</span> == m_capacity<span style="color: #7388d6;">)</span> Evict<span style="color: #7388d6;">(</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span>;

  <span style="color: #006400;">// </span><span style="color: #006400;">Insert the new value.</span>
  <span style="color: #228b22;">EntryPtr</span> <span style="color: #a0522d;">e</span> = <span style="color: #008b8b;">std</span>::make_shared<span style="color: #7388d6;">&lt;</span>Entry<span style="color: #7388d6;">&gt;(</span>key, <span style="color: #008b8b;">blz</span>::move<span style="color: #909183;">(</span>value<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
  Append<span style="color: #7388d6;">(</span>e.get<span style="color: #909183;">()</span><span style="color: #7388d6;">)</span>;
  m_entries<span style="color: #7388d6;">[</span>key<span style="color: #7388d6;">]</span> = e;

  <span style="color: #a020f0;">return</span> e;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Given everything we've learned, let's critique this code.
</p>

<p>
We can see that it's inserting a KV pair into a cache with a least-recently-used
eviction strategy. There is a map that owns a shared<sub>ptr</sub>, and that shared<sub>ptr</sub> is
also weakly-referenced from a deque (see Append call)?
</p>

<ul>
<li>use pass-by-value to simplify handling</li>
<li>use <code>make_shared</code></li>

<li>use <code>operator[]</code> - default construct shared<sub>ptr</sub> + assign</li>
<li>extra shared<sub>ptr</sub> ref</li>

</ul>

</aside>

</section>
<section id="slide-org6d6cd59">
<h3 id="org6d6cd59">Exhibit H</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">Insert the new value.</span>
<span style="color: #a020f0;">decltype</span><span style="color: #707183;">(</span>m_entries.begin<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span> <span style="color: #a0522d;">it</span>;
<span style="color: #008b8b;">std</span>::tie<span style="color: #707183;">(</span>it, <span style="color: #008b8b;">std</span>::ignore<span style="color: #707183;">)</span> =
  m_entries.emplace<span style="color: #707183;">(</span>key, <span style="color: #008b8b;">std</span>::make_shared<span style="color: #7388d6;">&lt;</span>Entry<span style="color: #7388d6;">&gt;(</span>key, <span style="color: #008b8b;">std</span>::move<span style="color: #909183;">(</span>value<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
Append<span style="color: #707183;">(</span>it-&gt;second.get<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">return</span> it-&gt;second;
</pre>
</div>

<aside class="notes">
<ul>
<li>m<sub>entries</sub> can still be any associative container (no loss of generality)</li>
<li>save 2 shared<sub>ptr</sub> reference updates (plus check on assign of the default-constructed one)</li>

</ul>

<p>
We could use with<sub>result</sub><sub>of</sub> here to construct the shared<sub>ptr</sub> directly in place.
</p>

</aside>

</section>
<section id="slide-orgb48f679">
<h3 id="orgb48f679">Recommendations</h3>
<p>
Yes, C++ is complicated.
</p>

<ul>
<li>Initialization: consider <code>for_each_n_args</code></li>
<li>You can use <code>insert</code> with <code>make_pair</code> and implicit construction
<ul>
<li>But don't use call-site explicit construction</li>

</ul></li>
<li>Use <code>emplace</code> but beware of explicit construction</li>
<li>Use <code>piecewise_construct</code> for other than single-arg construction</li>
<li>Try to avoid <code>operator[]</code></li>
<li>Adopt <code>insert_or_assign</code> when it's available</li>
<li>Consider <code>with_result_of</code></li>

</ul>

</section>
</section>
<section>
<section id="slide-org94a08f6">
<h2 id="org94a08f6">6. Putting stuff into other things</h2>
<p>
Like <code>optional</code>, <code>variant</code>, <code>any</code>.
</p>

</section>
<section id="slide-org90eaffb">
<h3 id="org90eaffb"><code>optional</code> and friends</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">optional</span><span style="color: #707183;">(</span><span style="color: #228b22;">in_place_t</span>, <span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span>, <span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">variant</span><span style="color: #707183;">(</span><span style="color: #228b22;">in_place_type_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #7388d6;">&gt;</span>, <span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span>;
<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">I</span>, <span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">variant</span><span style="color: #707183;">(</span><span style="color: #228b22;">in_place_index_t</span><span style="color: #7388d6;">&lt;</span>I<span style="color: #7388d6;">&gt;</span>, <span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">ValueType</span>, <span style="color: #a020f0;">class</span><span style="color: #0000ff;">...</span> <span style="color: #228b22;">Args</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">any</span><span style="color: #707183;">(</span><span style="color: #228b22;">in_place_type_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">ValueType</span><span style="color: #7388d6;">&gt;</span>, <span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> <span style="color: #a0522d;">args</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
All these new vocabulary types have constructors that take <code>in_place</code> tag
arguments. They work similarly to <code>piecewise_construct</code> but they're only
constructing one thing.
</p>

</aside>

</section>
<section id="slide-orgb583129">
<h3 id="orgb583129"><code>optional</code> construction</h3>
<p>
implicit constructor
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span> = Foo<span style="color: #707183;">{}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (naive method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span> = S<span style="color: #707183;">{</span><span style="color: #008b8b;">1</span><span style="color: #707183;">}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (in-place method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span><span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::in_place, <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
In the first case, it's fine: just one in-place construct.
</p>

<p>
In the second case, we have an <code>explicit</code> constructor. So if we use this style,
we get a construct and a move.
</p>

<p>
The third case is the way to go for in-place construction. It can also be used
with an implicit constructor of course.
</p>

</aside>

</section>
<section id="slide-org631af2c">
<h3 id="org631af2c"><code>optional</code> assignment</h3>
<p>
implicit constructor
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span>;
opt = Foo<span style="color: #707183;">{}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (naive method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span>;
opt = S<span style="color: #707183;">{</span><span style="color: #008b8b;">1</span><span style="color: #707183;">}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (in-place method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span>;
opt.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Similar story here.
</p>

</aside>

</section>
<section id="slide-orgc1803da">
<h3 id="orgc1803da"><code>optional</code> recommendations</h3>
<ul>
<li>use the <code>in_place_t</code> constructor</li>
<li>avoid <code>explicit</code> construction</li>
<li>use <code>emplace</code> for assignment</li>

</ul>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">opt</span><span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::in_place, <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
opt.emplace<span style="color: #707183;">(</span><span style="color: #008b8b;">2</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
You'll never go wrong with these.
</p>

<p>
Again we could use the with<sub>result</sub><sub>of</sub> to in-place construct the result of a
function call.
</p>

</aside>

</section>
<section id="slide-org70cda64">
<h3 id="org70cda64"><code>variant</code> construction</h3>
<p>
implicit constructor
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = Foo<span style="color: #707183;">{}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (naive method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = S<span style="color: #707183;">{</span><span style="color: #008b8b;">1</span><span style="color: #707183;">}</span>;
</pre>
</div>

<p>
<code>explicit</code> constructor (oops method)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span> = <span style="color: #008b8b;">1</span>;
</pre>
</div>

<aside class="notes">
<p>
Similar story as <code>optional</code>.
</p>

<p>
But there is the potential for a bug with the <code>explicit</code> constructor. What makes
this somewhat likely is that it might be the case that someone makes a
constructor explicit later on.
</p>

</aside>

</section>
<section id="slide-orgb85af5e">
<h3 id="orgb85af5e"><code>variant</code> construction</h3>
<p>
Recommendation: use either of these two constructions.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">v</span><span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">in_place_type</span><span style="color: #7388d6;">&lt;</span>S<span style="color: #7388d6;">&gt;</span>, <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">v</span><span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">in_place_index</span><span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">&gt;</span>, <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
I would generally prefer the first except in cases where the same type occurs in
multiple places in the <code>variant</code>, which is relatively rarer.
</p>

</aside>

</section>
<section id="slide-orgf3084ee">
<h3 id="orgf3084ee"><code>variant</code> assignment</h3>
<p>
Similar story to construction.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;

v = Foo<span style="color: #707183;">{}</span>; <span style="color: #006400;">// </span><span style="color: #006400;">fine</span>
v = S<span style="color: #707183;">{</span><span style="color: #008b8b;">1</span><span style="color: #707183;">}</span>;  <span style="color: #006400;">// </span><span style="color: #006400;">constructs a temporary</span>
v = <span style="color: #008b8b;">1</span>;     <span style="color: #006400;">// </span><span style="color: #006400;">oops</span>
</pre>
</div>

</section>
<section id="slide-orgfe58cf0">
<h3 id="orgfe58cf0"><code>variant</code> danger!</h3>
<p>
Implicitly-typed <code>variant</code> construction/assignment can be dangerous.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">variant</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">bool</span>, <span style="color: #008b8b;">std</span>::string<span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">v</span> = <span style="color: #8b2252;">"Hello"</span>;
  <span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #8b2252;">"index is "</span> &lt;&lt; v.index<span style="color: #7388d6;">()</span> &lt;&lt; <span style="color: #8b2252;">'</span><span style="color: #8b2252; font-weight: bold;">\</span><span style="color: #8b2252; font-weight: bold;">n</span><span style="color: #8b2252;">'</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
What does this output?
</p>

<aside class="notes">
<p>
Avoid implicit type conversions. They're dangerous. The first possible one will apply.
</p>

</aside>

</section>
<section id="slide-orgb0dd574">
<h3 id="orgb0dd574">Safe, efficient <code>variant</code> assignment</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #006400;">// </span><span style="color: #006400;">template &lt;class T, class... Args&gt;</span>
<span style="color: #006400;">// </span><span style="color: #006400;">T&amp; emplace(Args&amp;&amp;... args);</span>
v.emplace<span style="color: #707183;">&lt;</span>S<span style="color: #707183;">&gt;(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;  <span style="color: #006400;">// </span><span style="color: #006400;">S{1}</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">variant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, S<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
<span style="color: #006400;">// </span><span style="color: #006400;">template &lt;size_t I, class... Args&gt;</span>
<span style="color: #006400;">// </span><span style="color: #006400;">variant_alternative_t&lt;I, variant&gt;&amp; emplace(Args&amp;&amp;... args);</span>
v.emplace<span style="color: #707183;">&lt;</span><span style="color: #008b8b;">1</span><span style="color: #707183;">&gt;(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;  <span style="color: #006400;">// </span><span style="color: #006400;">S{1}</span>
</pre>
</div>

</section>
<section id="slide-orgaa2bba1">
<h3 id="orgaa2bba1"><code>variant</code> recommendations</h3>
<ul>
<li>always be explicit about types</li>
<li>use <code>in_place_type</code> or <code>in_place_index</code> constructors</li>
<li>use <code>emplace&lt;T&gt;</code> or <code>emplace&lt;I&gt;</code></li>
<li>avoid <code>operator=</code> (except actual <code>variant</code>-to-<code>variant</code>)</li>

</ul>

<aside class="notes">
<p>
Obviously <code>operator=</code> is used implicitly by the compiler.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgaff473f">
<h2 id="orgaff473f">7. Final Guidelines and Recommendations</h2>
<p>
Think about copies and moves.
</p>

<p>
Moves aren't free, and may not be cheap.
</p>

<p>
Usually, in-place construction is preferable. And it is nearly always possible.
</p>

<p>
Know how RVO works, and check that the compiler is doing it when you think it is.
</p>

<p>
Beware <code>initializer_list</code>.
</p>

<p>
Feel free to ping me with any questions, any time.
</p>
</section>
</section>
</div>
</div>
<script src="../reveal.js/lib/js/head.min.js"></script>
<script src="../reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
overview: true,
width: 1600,
height: 900,
margin: 0.10,
minScale: 0.50,
maxScale: 2.50,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
